!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},r.name);t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return D(e.substr(6));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

(["1"], [], true, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
!function(e){function n(e,n){e=e.replace(l,"");var r=e.match(u),t=(r[1].split(",")[n]||"require").replace(s,""),i=p[t]||(p[t]=new RegExp(a+t+f,"g"));i.lastIndex=0;for(var o,c=[];o=i.exec(e);)c.push(o[2]||o[3]);return c}function r(e,n,t,o){if("object"==typeof e&&!(e instanceof Array))return r.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof n&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var l=i.get(e);return l.__useDefault?l["default"]:l}throw new TypeError("Invalid require")}for(var a=[],f=0;f<e.length;f++)a.push(i["import"](e[f],o));Promise.all(a).then(function(e){n&&n.apply(null,e)},t)}function t(t,l,a){"string"!=typeof t&&(a=l,l=t,t=null),l instanceof Array||(a=l,l=["require","exports","module"].splice(0,a.length)),"function"!=typeof a&&(a=function(e){return function(){return e}}(a)),void 0===l[l.length-1]&&l.pop();var f,u,s;-1!=(f=o.call(l,"require"))&&(l.splice(f,1),t||(l=l.concat(n(a.toString(),f)))),-1!=(u=o.call(l,"exports"))&&l.splice(u,1),-1!=(s=o.call(l,"module"))&&l.splice(s,1);var p={name:t,deps:l,execute:function(n,t,o){for(var p=[],c=0;c<l.length;c++)p.push(n(l[c]));o.uri=o.id,o.config=function(){},-1!=s&&p.splice(s,0,o),-1!=u&&p.splice(u,0,t),-1!=f&&p.splice(f,0,function(e,t,l){return"string"==typeof e&&"function"!=typeof t?n(e):r.call(i,e,t,l,o.id)});var d=a.apply(-1==u?e:t,p);return"undefined"==typeof d&&o&&(d=o.exports),"undefined"!=typeof d?d:void 0}};if(t)c.anonDefine||c.isBundle?c.anonDefine&&c.anonDefine.name&&(c.anonDefine=null):c.anonDefine=p,c.isBundle=!0,i.registerDynamic(p.name,p.deps,!1,p.execute);else{if(c.anonDefine&&!c.anonDefine.name)throw new Error("Multiple anonymous defines in module "+t);c.anonDefine=p}}var i=$__System,o=Array.prototype.indexOf||function(e){for(var n=0,r=this.length;r>n;n++)if(this[n]===e)return n;return-1},l=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,a="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",f="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",u=/\(([^\)]*)\)/,s=/^\s+|\s+$/g,p={};t.amd={};var c={isBundle:!1,anonDefine:null};i.amdDefine=t,i.amdRequire=r}("undefined"!=typeof self?self:global);
(function() {
var define = $__System.amdDefine;
var __extends = (this && this.__extends) || function(d, b) {
  for (var p in b)
    if (b.hasOwnProperty(p))
      d[p] = b[p];
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Subject'), require('rxjs/observable/PromiseObservable'), require('rxjs/operator/toPromise'), require('rxjs/Observable')) : typeof define === 'function' && define.amd ? define("2", ["exports", "3", "4", "5", "6", "7"], factory) : (factory((global.ng = global.ng || {}, global.ng.compiler = global.ng.compiler || {}), global.ng.core, global.Rx, global.Rx, global.Rx.Observable.prototype, global.Rx));
}(this, function(exports, _angular_core, rxjs_Subject, rxjs_observable_PromiseObservable, rxjs_operator_toPromise, rxjs_Observable) {
  'use strict';
  var ElementSchemaRegistry = (function() {
    function ElementSchemaRegistry() {}
    return ElementSchemaRegistry;
  }());
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  var IS_DART = false;
  var global$1 = globalScope;
  var Type = Function;
  var _devMode = true;
  function assertionsEnabled() {
    return _devMode;
  }
  global$1.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  function isBoolean(obj) {
    return typeof obj === "boolean";
  }
  function isNumber(obj) {
    return typeof obj === "number";
  }
  function isString(obj) {
    return typeof obj === "string";
  }
  function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
  }
  var STRING_MAP_PROTO = Object.getPrototypeOf({});
  function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
  }
  function isArray(obj) {
    return Array.isArray(obj);
  }
  function noop() {}
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.name) {
      return token.name;
    }
    if (token.overriddenName) {
      return token.overriddenName;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  function serializeEnum(val) {
    return val;
  }
  function resolveEnumToken(enumValue, val) {
    return enumValue[val];
  }
  var StringWrapper = (function() {
    function StringWrapper() {}
    StringWrapper.fromCharCode = function(code) {
      return String.fromCharCode(code);
    };
    StringWrapper.charCodeAt = function(s, index) {
      return s.charCodeAt(index);
    };
    StringWrapper.split = function(s, regExp) {
      return s.split(regExp);
    };
    StringWrapper.equals = function(s, s2) {
      return s === s2;
    };
    StringWrapper.stripLeft = function(s, charVal) {
      if (s && s.length) {
        var pos = 0;
        for (var i = 0; i < s.length; i++) {
          if (s[i] != charVal)
            break;
          pos++;
        }
        s = s.substring(pos);
      }
      return s;
    };
    StringWrapper.stripRight = function(s, charVal) {
      if (s && s.length) {
        var pos = s.length;
        for (var i = s.length - 1; i >= 0; i--) {
          if (s[i] != charVal)
            break;
          pos--;
        }
        s = s.substring(0, pos);
      }
      return s;
    };
    StringWrapper.replace = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.slice = function(s, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function(s, from, cb) {
      return s.replace(from, function() {
        var matches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          matches[_i - 0] = arguments[_i];
        }
        matches.splice(-2, 2);
        return cb(matches);
      });
    };
    StringWrapper.contains = function(s, substr) {
      return s.indexOf(substr) != -1;
    };
    StringWrapper.compare = function(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    return StringWrapper;
  }());
  var StringJoiner = (function() {
    function StringJoiner(parts) {
      if (parts === void 0) {
        parts = [];
      }
      this.parts = parts;
    }
    StringJoiner.prototype.add = function(part) {
      this.parts.push(part);
    };
    StringJoiner.prototype.toString = function() {
      return this.parts.join("");
    };
    return StringJoiner;
  }());
  var NumberParseError = (function(_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
      _super.call(this);
      this.message = message;
    }
    NumberParseError.prototype.toString = function() {
      return this.message;
    };
    return NumberParseError;
  }(Error));
  var NumberWrapper = (function() {
    function NumberWrapper() {}
    NumberWrapper.toFixed = function(n, fractionDigits) {
      return n.toFixed(fractionDigits);
    };
    NumberWrapper.equal = function(a, b) {
      return a === b;
    };
    NumberWrapper.parseIntAutoRadix = function(text) {
      var result = parseInt(text);
      if (isNaN(result)) {
        throw new NumberParseError("Invalid integer literal when parsing " + text);
      }
      return result;
    };
    NumberWrapper.parseInt = function(text, radix) {
      if (radix == 10) {
        if (/^(\-|\+)?[0-9]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else if (radix == 16) {
        if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else {
        var result = parseInt(text, radix);
        if (!isNaN(result)) {
          return result;
        }
      }
      throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " + radix);
    };
    NumberWrapper.parseFloat = function(text) {
      return parseFloat(text);
    };
    Object.defineProperty(NumberWrapper, "NaN", {
      get: function() {
        return NaN;
      },
      enumerable: true,
      configurable: true
    });
    NumberWrapper.isNaN = function(value) {
      return isNaN(value);
    };
    NumberWrapper.isInteger = function(value) {
      return Number.isInteger(value);
    };
    return NumberWrapper;
  }());
  var RegExpWrapper = (function() {
    function RegExpWrapper() {}
    RegExpWrapper.create = function(regExpStr, flags) {
      if (flags === void 0) {
        flags = '';
      }
      flags = flags.replace(/g/g, '');
      return new global$1.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function(regExp, input) {
      regExp.lastIndex = 0;
      return regExp.exec(input);
    };
    RegExpWrapper.test = function(regExp, input) {
      regExp.lastIndex = 0;
      return regExp.test(input);
    };
    RegExpWrapper.matcher = function(regExp, input) {
      regExp.lastIndex = 0;
      return {
        re: regExp,
        input: input
      };
    };
    RegExpWrapper.replaceAll = function(regExp, input, replace) {
      var c = regExp.exec(input);
      var res = '';
      regExp.lastIndex = 0;
      var prev = 0;
      while (c) {
        res += input.substring(prev, c.index);
        res += replace(c);
        prev = c.index + c[0].length;
        regExp.lastIndex = prev;
        c = regExp.exec(input);
      }
      res += input.substring(prev);
      return res;
    };
    return RegExpWrapper;
  }());
  var RegExpMatcherWrapper = (function() {
    function RegExpMatcherWrapper() {}
    RegExpMatcherWrapper.next = function(matcher) {
      return matcher.re.exec(matcher.input);
    };
    return RegExpMatcherWrapper;
  }());
  var FunctionWrapper = (function() {
    function FunctionWrapper() {}
    FunctionWrapper.apply = function(fn, posArgs) {
      return fn.apply(null, posArgs);
    };
    return FunctionWrapper;
  }());
  function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
  }
  function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
  }
  function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
  }
  function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
      fnArgNames.push(argName);
      fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
  }
  function isPrimitive(obj) {
    return !isJsObject(obj);
  }
  var TextAst = (function() {
    function TextAst(value, ngContentIndex, sourceSpan) {
      this.value = value;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    TextAst.prototype.visit = function(visitor, context) {
      return visitor.visitText(this, context);
    };
    return TextAst;
  }());
  var BoundTextAst = (function() {
    function BoundTextAst(value, ngContentIndex, sourceSpan) {
      this.value = value;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    BoundTextAst.prototype.visit = function(visitor, context) {
      return visitor.visitBoundText(this, context);
    };
    return BoundTextAst;
  }());
  var AttrAst = (function() {
    function AttrAst(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    AttrAst.prototype.visit = function(visitor, context) {
      return visitor.visitAttr(this, context);
    };
    return AttrAst;
  }());
  var BoundElementPropertyAst = (function() {
    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {
      this.name = name;
      this.type = type;
      this.securityContext = securityContext;
      this.value = value;
      this.unit = unit;
      this.sourceSpan = sourceSpan;
    }
    BoundElementPropertyAst.prototype.visit = function(visitor, context) {
      return visitor.visitElementProperty(this, context);
    };
    return BoundElementPropertyAst;
  }());
  var BoundEventAst = (function() {
    function BoundEventAst(name, target, handler, sourceSpan) {
      this.name = name;
      this.target = target;
      this.handler = handler;
      this.sourceSpan = sourceSpan;
    }
    BoundEventAst.prototype.visit = function(visitor, context) {
      return visitor.visitEvent(this, context);
    };
    Object.defineProperty(BoundEventAst.prototype, "fullName", {
      get: function() {
        if (isPresent(this.target)) {
          return this.target + ":" + this.name;
        } else {
          return this.name;
        }
      },
      enumerable: true,
      configurable: true
    });
    return BoundEventAst;
  }());
  var ReferenceAst = (function() {
    function ReferenceAst(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    ReferenceAst.prototype.visit = function(visitor, context) {
      return visitor.visitReference(this, context);
    };
    return ReferenceAst;
  }());
  var VariableAst = (function() {
    function VariableAst(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    VariableAst.prototype.visit = function(visitor, context) {
      return visitor.visitVariable(this, context);
    };
    return VariableAst;
  }());
  var ElementAst = (function() {
    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
      this.name = name;
      this.attrs = attrs;
      this.inputs = inputs;
      this.outputs = outputs;
      this.references = references;
      this.directives = directives;
      this.providers = providers;
      this.hasViewContainer = hasViewContainer;
      this.children = children;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    ElementAst.prototype.visit = function(visitor, context) {
      return visitor.visitElement(this, context);
    };
    return ElementAst;
  }());
  var EmbeddedTemplateAst = (function() {
    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
      this.attrs = attrs;
      this.outputs = outputs;
      this.references = references;
      this.variables = variables;
      this.directives = directives;
      this.providers = providers;
      this.hasViewContainer = hasViewContainer;
      this.children = children;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    EmbeddedTemplateAst.prototype.visit = function(visitor, context) {
      return visitor.visitEmbeddedTemplate(this, context);
    };
    return EmbeddedTemplateAst;
  }());
  var BoundDirectivePropertyAst = (function() {
    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {
      this.directiveName = directiveName;
      this.templateName = templateName;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    BoundDirectivePropertyAst.prototype.visit = function(visitor, context) {
      return visitor.visitDirectiveProperty(this, context);
    };
    return BoundDirectivePropertyAst;
  }());
  var DirectiveAst = (function() {
    function DirectiveAst(directive, inputs, hostProperties, hostEvents, sourceSpan) {
      this.directive = directive;
      this.inputs = inputs;
      this.hostProperties = hostProperties;
      this.hostEvents = hostEvents;
      this.sourceSpan = sourceSpan;
    }
    DirectiveAst.prototype.visit = function(visitor, context) {
      return visitor.visitDirective(this, context);
    };
    return DirectiveAst;
  }());
  var ProviderAst = (function() {
    function ProviderAst(token, multiProvider, eager, providers, providerType, sourceSpan) {
      this.token = token;
      this.multiProvider = multiProvider;
      this.eager = eager;
      this.providers = providers;
      this.providerType = providerType;
      this.sourceSpan = sourceSpan;
    }
    ProviderAst.prototype.visit = function(visitor, context) {
      return null;
    };
    return ProviderAst;
  }());
  exports.ProviderAstType;
  (function(ProviderAstType) {
    ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
    ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
    ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
    ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
    ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
  })(exports.ProviderAstType || (exports.ProviderAstType = {}));
  var NgContentAst = (function() {
    function NgContentAst(index, ngContentIndex, sourceSpan) {
      this.index = index;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    NgContentAst.prototype.visit = function(visitor, context) {
      return visitor.visitNgContent(this, context);
    };
    return NgContentAst;
  }());
  exports.PropertyBindingType;
  (function(PropertyBindingType) {
    PropertyBindingType[PropertyBindingType["Property"] = 0] = "Property";
    PropertyBindingType[PropertyBindingType["Attribute"] = 1] = "Attribute";
    PropertyBindingType[PropertyBindingType["Class"] = 2] = "Class";
    PropertyBindingType[PropertyBindingType["Style"] = 3] = "Style";
  })(exports.PropertyBindingType || (exports.PropertyBindingType = {}));
  function templateVisitAll(visitor, asts, context) {
    if (context === void 0) {
      context = null;
    }
    var result = [];
    asts.forEach(function(ast) {
      var astResult = ast.visit(visitor, context);
      if (isPresent(astResult)) {
        result.push(astResult);
      }
    });
    return result;
  }
  var isDefaultChangeDetectionStrategy = _angular_core.__core_private__.isDefaultChangeDetectionStrategy;
  var ChangeDetectorState = _angular_core.__core_private__.ChangeDetectorState;
  var CHANGE_DETECTION_STRATEGY_VALUES = _angular_core.__core_private__.CHANGE_DETECTION_STRATEGY_VALUES;
  var LifecycleHooks = _angular_core.__core_private__.LifecycleHooks;
  var LIFECYCLE_HOOKS_VALUES = _angular_core.__core_private__.LIFECYCLE_HOOKS_VALUES;
  var ReflectorReader = _angular_core.__core_private__.ReflectorReader;
  var AppElement = _angular_core.__core_private__.AppElement;
  var AppView = _angular_core.__core_private__.AppView;
  var DebugAppView = _angular_core.__core_private__.DebugAppView;
  var ViewType = _angular_core.__core_private__.ViewType;
  var MAX_INTERPOLATION_VALUES = _angular_core.__core_private__.MAX_INTERPOLATION_VALUES;
  var checkBinding = _angular_core.__core_private__.checkBinding;
  var flattenNestedViewRenderNodes = _angular_core.__core_private__.flattenNestedViewRenderNodes;
  var interpolate = _angular_core.__core_private__.interpolate;
  var ViewUtils = _angular_core.__core_private__.ViewUtils;
  var VIEW_ENCAPSULATION_VALUES = _angular_core.__core_private__.VIEW_ENCAPSULATION_VALUES;
  var DebugContext = _angular_core.__core_private__.DebugContext;
  var StaticNodeDebugInfo = _angular_core.__core_private__.StaticNodeDebugInfo;
  var devModeEqual = _angular_core.__core_private__.devModeEqual;
  var uninitialized = _angular_core.__core_private__.uninitialized;
  var ValueUnwrapper = _angular_core.__core_private__.ValueUnwrapper;
  var TemplateRef_ = _angular_core.__core_private__.TemplateRef_;
  var SecurityContext = _angular_core.__core_private__.SecurityContext;
  var createProvider = _angular_core.__core_private__.createProvider;
  var isProviderLiteral = _angular_core.__core_private__.isProviderLiteral;
  var EMPTY_ARRAY = _angular_core.__core_private__.EMPTY_ARRAY;
  var EMPTY_MAP = _angular_core.__core_private__.EMPTY_MAP;
  var pureProxy1 = _angular_core.__core_private__.pureProxy1;
  var pureProxy2 = _angular_core.__core_private__.pureProxy2;
  var pureProxy3 = _angular_core.__core_private__.pureProxy3;
  var pureProxy4 = _angular_core.__core_private__.pureProxy4;
  var pureProxy5 = _angular_core.__core_private__.pureProxy5;
  var pureProxy6 = _angular_core.__core_private__.pureProxy6;
  var pureProxy7 = _angular_core.__core_private__.pureProxy7;
  var pureProxy8 = _angular_core.__core_private__.pureProxy8;
  var pureProxy9 = _angular_core.__core_private__.pureProxy9;
  var pureProxy10 = _angular_core.__core_private__.pureProxy10;
  var castByValue = _angular_core.__core_private__.castByValue;
  var Console = _angular_core.__core_private__.Console;
  var Map$1 = global$1.Map;
  var Set$1 = global$1.Set;
  var createMapFromPairs = (function() {
    try {
      if (new Map$1([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new Map$1(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new Map$1();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new Map$1(new Map$1())) {
        return function createMapFromMap(m) {
          return new Map$1(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new Map$1();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new Map$1()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new Map$1()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var StringMapWrapper = (function() {
    function StringMapWrapper() {}
    StringMapWrapper.create = function() {
      return {};
    };
    StringMapWrapper.contains = function(map, key) {
      return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function(map, key) {
      return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function(map, key, value) {
      map[key] = value;
    };
    StringMapWrapper.keys = function(map) {
      return Object.keys(map);
    };
    StringMapWrapper.values = function(map) {
      return Object.keys(map).reduce(function(r, a) {
        r.push(map[a]);
        return r;
      }, []);
    };
    StringMapWrapper.isEmpty = function(map) {
      for (var prop in map) {
        return false;
      }
      return true;
    };
    StringMapWrapper.delete = function(map, key) {
      delete map[key];
    };
    StringMapWrapper.forEach = function(map, callback) {
      for (var prop in map) {
        if (map.hasOwnProperty(prop)) {
          callback(map[prop], prop);
        }
      }
    };
    StringMapWrapper.merge = function(m1, m2) {
      var m = {};
      for (var attr in m1) {
        if (m1.hasOwnProperty(attr)) {
          m[attr] = m1[attr];
        }
      }
      for (var attr in m2) {
        if (m2.hasOwnProperty(attr)) {
          m[attr] = m2[attr];
        }
      }
      return m;
    };
    StringMapWrapper.equals = function(m1, m2) {
      var k1 = Object.keys(m1);
      var k2 = Object.keys(m2);
      if (k1.length != k2.length) {
        return false;
      }
      var key;
      for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (m1[key] !== m2[key]) {
          return false;
        }
      }
      return true;
    };
    return StringMapWrapper;
  }());
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  function _flattenArray(source, target) {
    if (isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  var createSetFromList = (function() {
    var test = new Set$1([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new Set$1(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new Set$1(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var SetWrapper = (function() {
    function SetWrapper() {}
    SetWrapper.createFromList = function(lst) {
      return createSetFromList(lst);
    };
    SetWrapper.has = function(s, key) {
      return s.has(key);
    };
    SetWrapper.delete = function(m, k) {
      m.delete(k);
    };
    return SetWrapper;
  }());
  var BaseException$1 = (function(_super) {
    __extends(BaseException$1, _super);
    function BaseException$1(message) {
      if (message === void 0) {
        message = "--";
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException$1.prototype.toString = function() {
      return this.message;
    };
    return BaseException$1;
  }(Error));
  function unimplemented() {
    throw new BaseException$1('unimplemented');
  }
  var AST = (function() {
    function AST() {}
    AST.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return null;
    };
    AST.prototype.toString = function() {
      return "AST";
    };
    return AST;
  }());
  var Quote = (function(_super) {
    __extends(Quote, _super);
    function Quote(prefix, uninterpretedExpression, location) {
      _super.call(this);
      this.prefix = prefix;
      this.uninterpretedExpression = uninterpretedExpression;
      this.location = location;
    }
    Quote.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitQuote(this, context);
    };
    Quote.prototype.toString = function() {
      return "Quote";
    };
    return Quote;
  }(AST));
  var EmptyExpr = (function(_super) {
    __extends(EmptyExpr, _super);
    function EmptyExpr() {
      _super.apply(this, arguments);
    }
    EmptyExpr.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
    };
    return EmptyExpr;
  }(AST));
  var ImplicitReceiver = (function(_super) {
    __extends(ImplicitReceiver, _super);
    function ImplicitReceiver() {
      _super.apply(this, arguments);
    }
    ImplicitReceiver.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitImplicitReceiver(this, context);
    };
    return ImplicitReceiver;
  }(AST));
  var Chain = (function(_super) {
    __extends(Chain, _super);
    function Chain(expressions) {
      _super.call(this);
      this.expressions = expressions;
    }
    Chain.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitChain(this, context);
    };
    return Chain;
  }(AST));
  var Conditional = (function(_super) {
    __extends(Conditional, _super);
    function Conditional(condition, trueExp, falseExp) {
      _super.call(this);
      this.condition = condition;
      this.trueExp = trueExp;
      this.falseExp = falseExp;
    }
    Conditional.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitConditional(this, context);
    };
    return Conditional;
  }(AST));
  var PropertyRead = (function(_super) {
    __extends(PropertyRead, _super);
    function PropertyRead(receiver, name) {
      _super.call(this);
      this.receiver = receiver;
      this.name = name;
    }
    PropertyRead.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPropertyRead(this, context);
    };
    return PropertyRead;
  }(AST));
  var PropertyWrite = (function(_super) {
    __extends(PropertyWrite, _super);
    function PropertyWrite(receiver, name, value) {
      _super.call(this);
      this.receiver = receiver;
      this.name = name;
      this.value = value;
    }
    PropertyWrite.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPropertyWrite(this, context);
    };
    return PropertyWrite;
  }(AST));
  var SafePropertyRead = (function(_super) {
    __extends(SafePropertyRead, _super);
    function SafePropertyRead(receiver, name) {
      _super.call(this);
      this.receiver = receiver;
      this.name = name;
    }
    SafePropertyRead.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitSafePropertyRead(this, context);
    };
    return SafePropertyRead;
  }(AST));
  var KeyedRead = (function(_super) {
    __extends(KeyedRead, _super);
    function KeyedRead(obj, key) {
      _super.call(this);
      this.obj = obj;
      this.key = key;
    }
    KeyedRead.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitKeyedRead(this, context);
    };
    return KeyedRead;
  }(AST));
  var KeyedWrite = (function(_super) {
    __extends(KeyedWrite, _super);
    function KeyedWrite(obj, key, value) {
      _super.call(this);
      this.obj = obj;
      this.key = key;
      this.value = value;
    }
    KeyedWrite.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitKeyedWrite(this, context);
    };
    return KeyedWrite;
  }(AST));
  var BindingPipe = (function(_super) {
    __extends(BindingPipe, _super);
    function BindingPipe(exp, name, args) {
      _super.call(this);
      this.exp = exp;
      this.name = name;
      this.args = args;
    }
    BindingPipe.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPipe(this, context);
    };
    return BindingPipe;
  }(AST));
  var LiteralPrimitive = (function(_super) {
    __extends(LiteralPrimitive, _super);
    function LiteralPrimitive(value) {
      _super.call(this);
      this.value = value;
    }
    LiteralPrimitive.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitLiteralPrimitive(this, context);
    };
    return LiteralPrimitive;
  }(AST));
  var LiteralArray = (function(_super) {
    __extends(LiteralArray, _super);
    function LiteralArray(expressions) {
      _super.call(this);
      this.expressions = expressions;
    }
    LiteralArray.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitLiteralArray(this, context);
    };
    return LiteralArray;
  }(AST));
  var LiteralMap = (function(_super) {
    __extends(LiteralMap, _super);
    function LiteralMap(keys, values) {
      _super.call(this);
      this.keys = keys;
      this.values = values;
    }
    LiteralMap.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitLiteralMap(this, context);
    };
    return LiteralMap;
  }(AST));
  var Interpolation = (function(_super) {
    __extends(Interpolation, _super);
    function Interpolation(strings, expressions) {
      _super.call(this);
      this.strings = strings;
      this.expressions = expressions;
    }
    Interpolation.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitInterpolation(this, context);
    };
    return Interpolation;
  }(AST));
  var Binary = (function(_super) {
    __extends(Binary, _super);
    function Binary(operation, left, right) {
      _super.call(this);
      this.operation = operation;
      this.left = left;
      this.right = right;
    }
    Binary.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitBinary(this, context);
    };
    return Binary;
  }(AST));
  var PrefixNot = (function(_super) {
    __extends(PrefixNot, _super);
    function PrefixNot(expression) {
      _super.call(this);
      this.expression = expression;
    }
    PrefixNot.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPrefixNot(this, context);
    };
    return PrefixNot;
  }(AST));
  var MethodCall = (function(_super) {
    __extends(MethodCall, _super);
    function MethodCall(receiver, name, args) {
      _super.call(this);
      this.receiver = receiver;
      this.name = name;
      this.args = args;
    }
    MethodCall.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitMethodCall(this, context);
    };
    return MethodCall;
  }(AST));
  var SafeMethodCall = (function(_super) {
    __extends(SafeMethodCall, _super);
    function SafeMethodCall(receiver, name, args) {
      _super.call(this);
      this.receiver = receiver;
      this.name = name;
      this.args = args;
    }
    SafeMethodCall.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitSafeMethodCall(this, context);
    };
    return SafeMethodCall;
  }(AST));
  var FunctionCall = (function(_super) {
    __extends(FunctionCall, _super);
    function FunctionCall(target, args) {
      _super.call(this);
      this.target = target;
      this.args = args;
    }
    FunctionCall.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitFunctionCall(this, context);
    };
    return FunctionCall;
  }(AST));
  var ASTWithSource = (function(_super) {
    __extends(ASTWithSource, _super);
    function ASTWithSource(ast, source, location) {
      _super.call(this);
      this.ast = ast;
      this.source = source;
      this.location = location;
    }
    ASTWithSource.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return this.ast.visit(visitor, context);
    };
    ASTWithSource.prototype.toString = function() {
      return this.source + " in " + this.location;
    };
    return ASTWithSource;
  }(AST));
  var TemplateBinding = (function() {
    function TemplateBinding(key, keyIsVar, name, expression) {
      this.key = key;
      this.keyIsVar = keyIsVar;
      this.name = name;
      this.expression = expression;
    }
    return TemplateBinding;
  }());
  var RecursiveAstVisitor = (function() {
    function RecursiveAstVisitor() {}
    RecursiveAstVisitor.prototype.visitBinary = function(ast, context) {
      ast.left.visit(this);
      ast.right.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitChain = function(ast, context) {
      return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitConditional = function(ast, context) {
      ast.condition.visit(this);
      ast.trueExp.visit(this);
      ast.falseExp.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitPipe = function(ast, context) {
      ast.exp.visit(this);
      this.visitAll(ast.args, context);
      return null;
    };
    RecursiveAstVisitor.prototype.visitFunctionCall = function(ast, context) {
      ast.target.visit(this);
      this.visitAll(ast.args, context);
      return null;
    };
    RecursiveAstVisitor.prototype.visitImplicitReceiver = function(ast, context) {
      return null;
    };
    RecursiveAstVisitor.prototype.visitInterpolation = function(ast, context) {
      return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitKeyedRead = function(ast, context) {
      ast.obj.visit(this);
      ast.key.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitKeyedWrite = function(ast, context) {
      ast.obj.visit(this);
      ast.key.visit(this);
      ast.value.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitLiteralArray = function(ast, context) {
      return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitLiteralMap = function(ast, context) {
      return this.visitAll(ast.values, context);
    };
    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function(ast, context) {
      return null;
    };
    RecursiveAstVisitor.prototype.visitMethodCall = function(ast, context) {
      ast.receiver.visit(this);
      return this.visitAll(ast.args, context);
    };
    RecursiveAstVisitor.prototype.visitPrefixNot = function(ast, context) {
      ast.expression.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyRead = function(ast, context) {
      ast.receiver.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyWrite = function(ast, context) {
      ast.receiver.visit(this);
      ast.value.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitSafePropertyRead = function(ast, context) {
      ast.receiver.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitSafeMethodCall = function(ast, context) {
      ast.receiver.visit(this);
      return this.visitAll(ast.args, context);
    };
    RecursiveAstVisitor.prototype.visitAll = function(asts, context) {
      var _this = this;
      asts.forEach(function(ast) {
        return ast.visit(_this, context);
      });
      return null;
    };
    RecursiveAstVisitor.prototype.visitQuote = function(ast, context) {
      return null;
    };
    return RecursiveAstVisitor;
  }());
  var TokenType;
  (function(TokenType) {
    TokenType[TokenType["Character"] = 0] = "Character";
    TokenType[TokenType["Identifier"] = 1] = "Identifier";
    TokenType[TokenType["Keyword"] = 2] = "Keyword";
    TokenType[TokenType["String"] = 3] = "String";
    TokenType[TokenType["Operator"] = 4] = "Operator";
    TokenType[TokenType["Number"] = 5] = "Number";
  })(TokenType || (TokenType = {}));
  var Lexer = (function() {
    function Lexer() {}
    Lexer.prototype.tokenize = function(text) {
      var scanner = new _Scanner(text);
      var tokens = [];
      var token = scanner.scanToken();
      while (token != null) {
        tokens.push(token);
        token = scanner.scanToken();
      }
      return tokens;
    };
    return Lexer;
  }());
  Lexer.decorators = [{type: _angular_core.Injectable}];
  var Token = (function() {
    function Token(index, type, numValue, strValue) {
      this.index = index;
      this.type = type;
      this.numValue = numValue;
      this.strValue = strValue;
    }
    Token.prototype.isCharacter = function(code) {
      return (this.type == TokenType.Character && this.numValue == code);
    };
    Token.prototype.isNumber = function() {
      return (this.type == TokenType.Number);
    };
    Token.prototype.isString = function() {
      return (this.type == TokenType.String);
    };
    Token.prototype.isOperator = function(operater) {
      return (this.type == TokenType.Operator && this.strValue == operater);
    };
    Token.prototype.isIdentifier = function() {
      return (this.type == TokenType.Identifier);
    };
    Token.prototype.isKeyword = function() {
      return (this.type == TokenType.Keyword);
    };
    Token.prototype.isKeywordDeprecatedVar = function() {
      return (this.type == TokenType.Keyword && this.strValue == "var");
    };
    Token.prototype.isKeywordLet = function() {
      return (this.type == TokenType.Keyword && this.strValue == "let");
    };
    Token.prototype.isKeywordNull = function() {
      return (this.type == TokenType.Keyword && this.strValue == "null");
    };
    Token.prototype.isKeywordUndefined = function() {
      return (this.type == TokenType.Keyword && this.strValue == "undefined");
    };
    Token.prototype.isKeywordTrue = function() {
      return (this.type == TokenType.Keyword && this.strValue == "true");
    };
    Token.prototype.isKeywordFalse = function() {
      return (this.type == TokenType.Keyword && this.strValue == "false");
    };
    Token.prototype.toNumber = function() {
      return (this.type == TokenType.Number) ? this.numValue : -1;
    };
    Token.prototype.toString = function() {
      switch (this.type) {
        case TokenType.Character:
        case TokenType.Identifier:
        case TokenType.Keyword:
        case TokenType.Operator:
        case TokenType.String:
          return this.strValue;
        case TokenType.Number:
          return this.numValue.toString();
        default:
          return null;
      }
    };
    return Token;
  }());
  function newCharacterToken(index, code) {
    return new Token(index, TokenType.Character, code, StringWrapper.fromCharCode(code));
  }
  function newIdentifierToken(index, text) {
    return new Token(index, TokenType.Identifier, 0, text);
  }
  function newKeywordToken(index, text) {
    return new Token(index, TokenType.Keyword, 0, text);
  }
  function newOperatorToken(index, text) {
    return new Token(index, TokenType.Operator, 0, text);
  }
  function newStringToken(index, text) {
    return new Token(index, TokenType.String, 0, text);
  }
  function newNumberToken(index, n) {
    return new Token(index, TokenType.Number, n, "");
  }
  var EOF = new Token(-1, TokenType.Character, 0, "");
  var $EOF = 0;
  var $TAB = 9;
  var $LF = 10;
  var $VTAB = 11;
  var $FF = 12;
  var $CR = 13;
  var $SPACE = 32;
  var $BANG = 33;
  var $DQ = 34;
  var $HASH = 35;
  var $$ = 36;
  var $PERCENT = 37;
  var $AMPERSAND = 38;
  var $SQ = 39;
  var $LPAREN = 40;
  var $RPAREN = 41;
  var $STAR = 42;
  var $PLUS = 43;
  var $COMMA = 44;
  var $MINUS = 45;
  var $PERIOD = 46;
  var $SLASH = 47;
  var $COLON = 58;
  var $SEMICOLON = 59;
  var $LT = 60;
  var $EQ = 61;
  var $GT = 62;
  var $QUESTION = 63;
  var $0 = 48;
  var $9 = 57;
  var $A = 65;
  var $E = 69;
  var $Z = 90;
  var $LBRACKET = 91;
  var $BACKSLASH = 92;
  var $RBRACKET = 93;
  var $CARET = 94;
  var $_ = 95;
  var $BT = 96;
  var $a = 97;
  var $e = 101;
  var $f = 102;
  var $n = 110;
  var $r = 114;
  var $t = 116;
  var $u = 117;
  var $v = 118;
  var $z = 122;
  var $LBRACE = 123;
  var $BAR = 124;
  var $RBRACE = 125;
  var $NBSP = 160;
  var ScannerError = (function(_super) {
    __extends(ScannerError, _super);
    function ScannerError(message) {
      _super.call(this);
      this.message = message;
    }
    ScannerError.prototype.toString = function() {
      return this.message;
    };
    return ScannerError;
  }(BaseException$1));
  var _Scanner = (function() {
    function _Scanner(input) {
      this.input = input;
      this.peek = 0;
      this.index = -1;
      this.length = input.length;
      this.advance();
    }
    _Scanner.prototype.advance = function() {
      this.peek = ++this.index >= this.length ? $EOF : StringWrapper.charCodeAt(this.input, this.index);
    };
    _Scanner.prototype.scanToken = function() {
      var input = this.input,
          length = this.length,
          peek = this.peek,
          index = this.index;
      while (peek <= $SPACE) {
        if (++index >= length) {
          peek = $EOF;
          break;
        } else {
          peek = StringWrapper.charCodeAt(input, index);
        }
      }
      this.peek = peek;
      this.index = index;
      if (index >= length) {
        return null;
      }
      if (isIdentifierStart(peek))
        return this.scanIdentifier();
      if (isDigit(peek))
        return this.scanNumber(index);
      var start = index;
      switch (peek) {
        case $PERIOD:
          this.advance();
          return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, $PERIOD);
        case $LPAREN:
        case $RPAREN:
        case $LBRACE:
        case $RBRACE:
        case $LBRACKET:
        case $RBRACKET:
        case $COMMA:
        case $COLON:
        case $SEMICOLON:
          return this.scanCharacter(start, peek);
        case $SQ:
        case $DQ:
          return this.scanString();
        case $HASH:
        case $PLUS:
        case $MINUS:
        case $STAR:
        case $SLASH:
        case $PERCENT:
        case $CARET:
          return this.scanOperator(start, StringWrapper.fromCharCode(peek));
        case $QUESTION:
          return this.scanComplexOperator(start, '?', $PERIOD, '.');
        case $LT:
        case $GT:
          return this.scanComplexOperator(start, StringWrapper.fromCharCode(peek), $EQ, '=');
        case $BANG:
        case $EQ:
          return this.scanComplexOperator(start, StringWrapper.fromCharCode(peek), $EQ, '=', $EQ, '=');
        case $AMPERSAND:
          return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
        case $BAR:
          return this.scanComplexOperator(start, '|', $BAR, '|');
        case $NBSP:
          while (isWhitespace(this.peek))
            this.advance();
          return this.scanToken();
      }
      this.error("Unexpected character [" + StringWrapper.fromCharCode(peek) + "]", 0);
      return null;
    };
    _Scanner.prototype.scanCharacter = function(start, code) {
      this.advance();
      return newCharacterToken(start, code);
    };
    _Scanner.prototype.scanOperator = function(start, str) {
      this.advance();
      return newOperatorToken(start, str);
    };
    _Scanner.prototype.scanComplexOperator = function(start, one, twoCode, two, threeCode, three) {
      this.advance();
      var str = one;
      if (this.peek == twoCode) {
        this.advance();
        str += two;
      }
      if (isPresent(threeCode) && this.peek == threeCode) {
        this.advance();
        str += three;
      }
      return newOperatorToken(start, str);
    };
    _Scanner.prototype.scanIdentifier = function() {
      var start = this.index;
      this.advance();
      while (isIdentifierPart(this.peek))
        this.advance();
      var str = this.input.substring(start, this.index);
      if (SetWrapper.has(KEYWORDS, str)) {
        return newKeywordToken(start, str);
      } else {
        return newIdentifierToken(start, str);
      }
    };
    _Scanner.prototype.scanNumber = function(start) {
      var simple = (this.index === start);
      this.advance();
      while (true) {
        if (isDigit(this.peek)) {} else if (this.peek == $PERIOD) {
          simple = false;
        } else if (isExponentStart(this.peek)) {
          this.advance();
          if (isExponentSign(this.peek))
            this.advance();
          if (!isDigit(this.peek))
            this.error('Invalid exponent', -1);
          simple = false;
        } else {
          break;
        }
        this.advance();
      }
      var str = this.input.substring(start, this.index);
      var value = simple ? NumberWrapper.parseIntAutoRadix(str) : NumberWrapper.parseFloat(str);
      return newNumberToken(start, value);
    };
    _Scanner.prototype.scanString = function() {
      var start = this.index;
      var quote = this.peek;
      this.advance();
      var buffer;
      var marker = this.index;
      var input = this.input;
      while (this.peek != quote) {
        if (this.peek == $BACKSLASH) {
          if (buffer == null)
            buffer = new StringJoiner();
          buffer.add(input.substring(marker, this.index));
          this.advance();
          var unescapedCode;
          if (this.peek == $u) {
            var hex = input.substring(this.index + 1, this.index + 5);
            try {
              unescapedCode = NumberWrapper.parseInt(hex, 16);
            } catch (e) {
              this.error("Invalid unicode escape [\\u" + hex + "]", 0);
            }
            for (var i = 0; i < 5; i++) {
              this.advance();
            }
          } else {
            unescapedCode = unescape(this.peek);
            this.advance();
          }
          buffer.add(StringWrapper.fromCharCode(unescapedCode));
          marker = this.index;
        } else if (this.peek == $EOF) {
          this.error('Unterminated quote', 0);
        } else {
          this.advance();
        }
      }
      var last = input.substring(marker, this.index);
      this.advance();
      var unescaped = last;
      if (buffer != null) {
        buffer.add(last);
        unescaped = buffer.toString();
      }
      return newStringToken(start, unescaped);
    };
    _Scanner.prototype.error = function(message, offset) {
      var position = this.index + offset;
      throw new ScannerError("Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
    };
    return _Scanner;
  }());
  function isWhitespace(code) {
    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
  }
  function isIdentifierStart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || (code == $_) || (code == $$);
  }
  function isIdentifier(input) {
    if (input.length == 0)
      return false;
    var scanner = new _Scanner(input);
    if (!isIdentifierStart(scanner.peek))
      return false;
    scanner.advance();
    while (scanner.peek !== $EOF) {
      if (!isIdentifierPart(scanner.peek))
        return false;
      scanner.advance();
    }
    return true;
  }
  function isIdentifierPart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || ($0 <= code && code <= $9) || (code == $_) || (code == $$);
  }
  function isDigit(code) {
    return $0 <= code && code <= $9;
  }
  function isExponentStart(code) {
    return code == $e || code == $E;
  }
  function isExponentSign(code) {
    return code == $MINUS || code == $PLUS;
  }
  function isQuote(code) {
    return code === $SQ || code === $DQ || code === $BT;
  }
  function unescape(code) {
    switch (code) {
      case $n:
        return $LF;
      case $f:
        return $FF;
      case $r:
        return $CR;
      case $t:
        return $TAB;
      case $v:
        return $VTAB;
      default:
        return code;
    }
  }
  var OPERATORS = SetWrapper.createFromList(['+', '-', '*', '/', '%', '^', '=', '==', '!=', '===', '!==', '<', '>', '<=', '>=', '&&', '||', '&', '|', '!', '?', '#', '?.']);
  var KEYWORDS = SetWrapper.createFromList(['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else']);
  var _implicitReceiver = new ImplicitReceiver();
  var INTERPOLATION_REGEXP = /\{\{([\s\S]*?)\}\}/g;
  var ParseException = (function(_super) {
    __extends(ParseException, _super);
    function ParseException(message, input, errLocation, ctxLocation) {
      _super.call(this, "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation);
    }
    return ParseException;
  }(BaseException$1));
  var SplitInterpolation = (function() {
    function SplitInterpolation(strings, expressions) {
      this.strings = strings;
      this.expressions = expressions;
    }
    return SplitInterpolation;
  }());
  var TemplateBindingParseResult = (function() {
    function TemplateBindingParseResult(templateBindings, warnings) {
      this.templateBindings = templateBindings;
      this.warnings = warnings;
    }
    return TemplateBindingParseResult;
  }());
  var Parser = (function() {
    function Parser(_lexer) {
      this._lexer = _lexer;
    }
    Parser.prototype.parseAction = function(input, location) {
      this._checkNoInterpolation(input, location);
      var tokens = this._lexer.tokenize(this._stripComments(input));
      var ast = new _ParseAST(input, location, tokens, true).parseChain();
      return new ASTWithSource(ast, input, location);
    };
    Parser.prototype.parseBinding = function(input, location) {
      var ast = this._parseBindingAst(input, location);
      return new ASTWithSource(ast, input, location);
    };
    Parser.prototype.parseSimpleBinding = function(input, location) {
      var ast = this._parseBindingAst(input, location);
      if (!SimpleExpressionChecker.check(ast)) {
        throw new ParseException('Host binding expression can only contain field access and constants', input, location);
      }
      return new ASTWithSource(ast, input, location);
    };
    Parser.prototype._parseBindingAst = function(input, location) {
      var quote = this._parseQuote(input, location);
      if (isPresent(quote)) {
        return quote;
      }
      this._checkNoInterpolation(input, location);
      var tokens = this._lexer.tokenize(this._stripComments(input));
      return new _ParseAST(input, location, tokens, false).parseChain();
    };
    Parser.prototype._parseQuote = function(input, location) {
      if (isBlank(input))
        return null;
      var prefixSeparatorIndex = input.indexOf(':');
      if (prefixSeparatorIndex == -1)
        return null;
      var prefix = input.substring(0, prefixSeparatorIndex).trim();
      if (!isIdentifier(prefix))
        return null;
      var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
      return new Quote(prefix, uninterpretedExpression, location);
    };
    Parser.prototype.parseTemplateBindings = function(input, location) {
      var tokens = this._lexer.tokenize(input);
      return new _ParseAST(input, location, tokens, false).parseTemplateBindings();
    };
    Parser.prototype.parseInterpolation = function(input, location) {
      var split = this.splitInterpolation(input, location);
      if (split == null)
        return null;
      var expressions = [];
      for (var i = 0; i < split.expressions.length; ++i) {
        var tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));
        var ast = new _ParseAST(input, location, tokens, false).parseChain();
        expressions.push(ast);
      }
      return new ASTWithSource(new Interpolation(split.strings, expressions), input, location);
    };
    Parser.prototype.splitInterpolation = function(input, location) {
      var parts = StringWrapper.split(input, INTERPOLATION_REGEXP);
      if (parts.length <= 1) {
        return null;
      }
      var strings = [];
      var expressions = [];
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (i % 2 === 0) {
          strings.push(part);
        } else if (part.trim().length > 0) {
          expressions.push(part);
        } else {
          throw new ParseException('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i) + " in", location);
        }
      }
      return new SplitInterpolation(strings, expressions);
    };
    Parser.prototype.wrapLiteralPrimitive = function(input, location) {
      return new ASTWithSource(new LiteralPrimitive(input), input, location);
    };
    Parser.prototype._stripComments = function(input) {
      var i = this._commentStart(input);
      return isPresent(i) ? input.substring(0, i).trim() : input;
    };
    Parser.prototype._commentStart = function(input) {
      var outerQuote = null;
      for (var i = 0; i < input.length - 1; i++) {
        var char = StringWrapper.charCodeAt(input, i);
        var nextChar = StringWrapper.charCodeAt(input, i + 1);
        if (char === $SLASH && nextChar == $SLASH && isBlank(outerQuote))
          return i;
        if (outerQuote === char) {
          outerQuote = null;
        } else if (isBlank(outerQuote) && isQuote(char)) {
          outerQuote = char;
        }
      }
      return null;
    };
    Parser.prototype._checkNoInterpolation = function(input, location) {
      var parts = StringWrapper.split(input, INTERPOLATION_REGEXP);
      if (parts.length > 1) {
        throw new ParseException('Got interpolation ({{}}) where expression was expected', input, "at column " + this._findInterpolationErrorColumn(parts, 1) + " in", location);
      }
    };
    Parser.prototype._findInterpolationErrorColumn = function(parts, partInErrIdx) {
      var errLocation = '';
      for (var j = 0; j < partInErrIdx; j++) {
        errLocation += j % 2 === 0 ? parts[j] : "{{" + parts[j] + "}}";
      }
      return errLocation.length;
    };
    return Parser;
  }());
  Parser.decorators = [{type: _angular_core.Injectable}];
  Parser.ctorParameters = [{type: Lexer}];
  var _ParseAST = (function() {
    function _ParseAST(input, location, tokens, parseAction) {
      this.input = input;
      this.location = location;
      this.tokens = tokens;
      this.parseAction = parseAction;
      this.index = 0;
    }
    _ParseAST.prototype.peek = function(offset) {
      var i = this.index + offset;
      return i < this.tokens.length ? this.tokens[i] : EOF;
    };
    Object.defineProperty(_ParseAST.prototype, "next", {
      get: function() {
        return this.peek(0);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(_ParseAST.prototype, "inputIndex", {
      get: function() {
        return (this.index < this.tokens.length) ? this.next.index : this.input.length;
      },
      enumerable: true,
      configurable: true
    });
    _ParseAST.prototype.advance = function() {
      this.index++;
    };
    _ParseAST.prototype.optionalCharacter = function(code) {
      if (this.next.isCharacter(code)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    };
    _ParseAST.prototype.peekKeywordLet = function() {
      return this.next.isKeywordLet();
    };
    _ParseAST.prototype.peekDeprecatedKeywordVar = function() {
      return this.next.isKeywordDeprecatedVar();
    };
    _ParseAST.prototype.peekDeprecatedOperatorHash = function() {
      return this.next.isOperator('#');
    };
    _ParseAST.prototype.expectCharacter = function(code) {
      if (this.optionalCharacter(code))
        return;
      this.error("Missing expected " + StringWrapper.fromCharCode(code));
    };
    _ParseAST.prototype.optionalOperator = function(op) {
      if (this.next.isOperator(op)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    };
    _ParseAST.prototype.expectOperator = function(operator) {
      if (this.optionalOperator(operator))
        return;
      this.error("Missing expected operator " + operator);
    };
    _ParseAST.prototype.expectIdentifierOrKeyword = function() {
      var n = this.next;
      if (!n.isIdentifier() && !n.isKeyword()) {
        this.error("Unexpected token " + n + ", expected identifier or keyword");
      }
      this.advance();
      return n.toString();
    };
    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function() {
      var n = this.next;
      if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
        this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
      }
      this.advance();
      return n.toString();
    };
    _ParseAST.prototype.parseChain = function() {
      var exprs = [];
      while (this.index < this.tokens.length) {
        var expr = this.parsePipe();
        exprs.push(expr);
        if (this.optionalCharacter($SEMICOLON)) {
          if (!this.parseAction) {
            this.error("Binding expression cannot contain chained expression");
          }
          while (this.optionalCharacter($SEMICOLON)) {}
        } else if (this.index < this.tokens.length) {
          this.error("Unexpected token '" + this.next + "'");
        }
      }
      if (exprs.length == 0)
        return new EmptyExpr();
      if (exprs.length == 1)
        return exprs[0];
      return new Chain(exprs);
    };
    _ParseAST.prototype.parsePipe = function() {
      var result = this.parseExpression();
      if (this.optionalOperator("|")) {
        if (this.parseAction) {
          this.error("Cannot have a pipe in an action expression");
        }
        do {
          var name = this.expectIdentifierOrKeyword();
          var args = [];
          while (this.optionalCharacter($COLON)) {
            args.push(this.parseExpression());
          }
          result = new BindingPipe(result, name, args);
        } while (this.optionalOperator("|"));
      }
      return result;
    };
    _ParseAST.prototype.parseExpression = function() {
      return this.parseConditional();
    };
    _ParseAST.prototype.parseConditional = function() {
      var start = this.inputIndex;
      var result = this.parseLogicalOr();
      if (this.optionalOperator('?')) {
        var yes = this.parsePipe();
        if (!this.optionalCharacter($COLON)) {
          var end = this.inputIndex;
          var expression = this.input.substring(start, end);
          this.error("Conditional expression " + expression + " requires all 3 expressions");
        }
        var no = this.parsePipe();
        return new Conditional(result, yes, no);
      } else {
        return result;
      }
    };
    _ParseAST.prototype.parseLogicalOr = function() {
      var result = this.parseLogicalAnd();
      while (this.optionalOperator('||')) {
        result = new Binary('||', result, this.parseLogicalAnd());
      }
      return result;
    };
    _ParseAST.prototype.parseLogicalAnd = function() {
      var result = this.parseEquality();
      while (this.optionalOperator('&&')) {
        result = new Binary('&&', result, this.parseEquality());
      }
      return result;
    };
    _ParseAST.prototype.parseEquality = function() {
      var result = this.parseRelational();
      while (true) {
        if (this.optionalOperator('==')) {
          result = new Binary('==', result, this.parseRelational());
        } else if (this.optionalOperator('===')) {
          result = new Binary('===', result, this.parseRelational());
        } else if (this.optionalOperator('!=')) {
          result = new Binary('!=', result, this.parseRelational());
        } else if (this.optionalOperator('!==')) {
          result = new Binary('!==', result, this.parseRelational());
        } else {
          return result;
        }
      }
    };
    _ParseAST.prototype.parseRelational = function() {
      var result = this.parseAdditive();
      while (true) {
        if (this.optionalOperator('<')) {
          result = new Binary('<', result, this.parseAdditive());
        } else if (this.optionalOperator('>')) {
          result = new Binary('>', result, this.parseAdditive());
        } else if (this.optionalOperator('<=')) {
          result = new Binary('<=', result, this.parseAdditive());
        } else if (this.optionalOperator('>=')) {
          result = new Binary('>=', result, this.parseAdditive());
        } else {
          return result;
        }
      }
    };
    _ParseAST.prototype.parseAdditive = function() {
      var result = this.parseMultiplicative();
      while (true) {
        if (this.optionalOperator('+')) {
          result = new Binary('+', result, this.parseMultiplicative());
        } else if (this.optionalOperator('-')) {
          result = new Binary('-', result, this.parseMultiplicative());
        } else {
          return result;
        }
      }
    };
    _ParseAST.prototype.parseMultiplicative = function() {
      var result = this.parsePrefix();
      while (true) {
        if (this.optionalOperator('*')) {
          result = new Binary('*', result, this.parsePrefix());
        } else if (this.optionalOperator('%')) {
          result = new Binary('%', result, this.parsePrefix());
        } else if (this.optionalOperator('/')) {
          result = new Binary('/', result, this.parsePrefix());
        } else {
          return result;
        }
      }
    };
    _ParseAST.prototype.parsePrefix = function() {
      if (this.optionalOperator('+')) {
        return this.parsePrefix();
      } else if (this.optionalOperator('-')) {
        return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());
      } else if (this.optionalOperator('!')) {
        return new PrefixNot(this.parsePrefix());
      } else {
        return this.parseCallChain();
      }
    };
    _ParseAST.prototype.parseCallChain = function() {
      var result = this.parsePrimary();
      while (true) {
        if (this.optionalCharacter($PERIOD)) {
          result = this.parseAccessMemberOrMethodCall(result, false);
        } else if (this.optionalOperator('?.')) {
          result = this.parseAccessMemberOrMethodCall(result, true);
        } else if (this.optionalCharacter($LBRACKET)) {
          var key = this.parsePipe();
          this.expectCharacter($RBRACKET);
          if (this.optionalOperator("=")) {
            var value = this.parseConditional();
            result = new KeyedWrite(result, key, value);
          } else {
            result = new KeyedRead(result, key);
          }
        } else if (this.optionalCharacter($LPAREN)) {
          var args = this.parseCallArguments();
          this.expectCharacter($RPAREN);
          result = new FunctionCall(result, args);
        } else {
          return result;
        }
      }
    };
    _ParseAST.prototype.parsePrimary = function() {
      if (this.optionalCharacter($LPAREN)) {
        var result = this.parsePipe();
        this.expectCharacter($RPAREN);
        return result;
      } else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
        this.advance();
        return new LiteralPrimitive(null);
      } else if (this.next.isKeywordTrue()) {
        this.advance();
        return new LiteralPrimitive(true);
      } else if (this.next.isKeywordFalse()) {
        this.advance();
        return new LiteralPrimitive(false);
      } else if (this.optionalCharacter($LBRACKET)) {
        var elements = this.parseExpressionList($RBRACKET);
        this.expectCharacter($RBRACKET);
        return new LiteralArray(elements);
      } else if (this.next.isCharacter($LBRACE)) {
        return this.parseLiteralMap();
      } else if (this.next.isIdentifier()) {
        return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);
      } else if (this.next.isNumber()) {
        var value = this.next.toNumber();
        this.advance();
        return new LiteralPrimitive(value);
      } else if (this.next.isString()) {
        var literalValue = this.next.toString();
        this.advance();
        return new LiteralPrimitive(literalValue);
      } else if (this.index >= this.tokens.length) {
        this.error("Unexpected end of expression: " + this.input);
      } else {
        this.error("Unexpected token " + this.next);
      }
      throw new BaseException$1("Fell through all cases in parsePrimary");
    };
    _ParseAST.prototype.parseExpressionList = function(terminator) {
      var result = [];
      if (!this.next.isCharacter(terminator)) {
        do {
          result.push(this.parsePipe());
        } while (this.optionalCharacter($COMMA));
      }
      return result;
    };
    _ParseAST.prototype.parseLiteralMap = function() {
      var keys = [];
      var values = [];
      this.expectCharacter($LBRACE);
      if (!this.optionalCharacter($RBRACE)) {
        do {
          var key = this.expectIdentifierOrKeywordOrString();
          keys.push(key);
          this.expectCharacter($COLON);
          values.push(this.parsePipe());
        } while (this.optionalCharacter($COMMA));
        this.expectCharacter($RBRACE);
      }
      return new LiteralMap(keys, values);
    };
    _ParseAST.prototype.parseAccessMemberOrMethodCall = function(receiver, isSafe) {
      if (isSafe === void 0) {
        isSafe = false;
      }
      var id = this.expectIdentifierOrKeyword();
      if (this.optionalCharacter($LPAREN)) {
        var args = this.parseCallArguments();
        this.expectCharacter($RPAREN);
        return isSafe ? new SafeMethodCall(receiver, id, args) : new MethodCall(receiver, id, args);
      } else {
        if (isSafe) {
          if (this.optionalOperator("=")) {
            this.error("The '?.' operator cannot be used in the assignment");
          } else {
            return new SafePropertyRead(receiver, id);
          }
        } else {
          if (this.optionalOperator("=")) {
            if (!this.parseAction) {
              this.error("Bindings cannot contain assignments");
            }
            var value = this.parseConditional();
            return new PropertyWrite(receiver, id, value);
          } else {
            return new PropertyRead(receiver, id);
          }
        }
      }
      return null;
    };
    _ParseAST.prototype.parseCallArguments = function() {
      if (this.next.isCharacter($RPAREN))
        return [];
      var positionals = [];
      do {
        positionals.push(this.parsePipe());
      } while (this.optionalCharacter($COMMA));
      return positionals;
    };
    _ParseAST.prototype.parseBlockContent = function() {
      if (!this.parseAction) {
        this.error("Binding expression cannot contain chained expression");
      }
      var exprs = [];
      while (this.index < this.tokens.length && !this.next.isCharacter($RBRACE)) {
        var expr = this.parseExpression();
        exprs.push(expr);
        if (this.optionalCharacter($SEMICOLON)) {
          while (this.optionalCharacter($SEMICOLON)) {}
        }
      }
      if (exprs.length == 0)
        return new EmptyExpr();
      if (exprs.length == 1)
        return exprs[0];
      return new Chain(exprs);
    };
    _ParseAST.prototype.expectTemplateBindingKey = function() {
      var result = '';
      var operatorFound = false;
      do {
        result += this.expectIdentifierOrKeywordOrString();
        operatorFound = this.optionalOperator('-');
        if (operatorFound) {
          result += '-';
        }
      } while (operatorFound);
      return result.toString();
    };
    _ParseAST.prototype.parseTemplateBindings = function() {
      var bindings = [];
      var prefix = null;
      var warnings = [];
      while (this.index < this.tokens.length) {
        var keyIsVar = this.peekKeywordLet();
        if (!keyIsVar && this.peekDeprecatedKeywordVar()) {
          keyIsVar = true;
          warnings.push("\"var\" inside of expressions is deprecated. Use \"let\" instead!");
        }
        if (!keyIsVar && this.peekDeprecatedOperatorHash()) {
          keyIsVar = true;
          warnings.push("\"#\" inside of expressions is deprecated. Use \"let\" instead!");
        }
        if (keyIsVar) {
          this.advance();
        }
        var key = this.expectTemplateBindingKey();
        if (!keyIsVar) {
          if (prefix == null) {
            prefix = key;
          } else {
            key = prefix + key[0].toUpperCase() + key.substring(1);
          }
        }
        this.optionalCharacter($COLON);
        var name = null;
        var expression = null;
        if (keyIsVar) {
          if (this.optionalOperator("=")) {
            name = this.expectTemplateBindingKey();
          } else {
            name = '\$implicit';
          }
        } else if (this.next !== EOF && !this.peekKeywordLet() && !this.peekDeprecatedKeywordVar() && !this.peekDeprecatedOperatorHash()) {
          var start = this.inputIndex;
          var ast = this.parsePipe();
          var source = this.input.substring(start, this.inputIndex);
          expression = new ASTWithSource(ast, source, this.location);
        }
        bindings.push(new TemplateBinding(key, keyIsVar, name, expression));
        if (!this.optionalCharacter($SEMICOLON)) {
          this.optionalCharacter($COMMA);
        }
      }
      return new TemplateBindingParseResult(bindings, warnings);
    };
    _ParseAST.prototype.error = function(message, index) {
      if (index === void 0) {
        index = null;
      }
      if (isBlank(index))
        index = this.index;
      var location = (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" : "at the end of the expression";
      throw new ParseException(message, this.input, location, this.location);
    };
    return _ParseAST;
  }());
  var SimpleExpressionChecker = (function() {
    function SimpleExpressionChecker() {
      this.simple = true;
    }
    SimpleExpressionChecker.check = function(ast) {
      var s = new SimpleExpressionChecker();
      ast.visit(s);
      return s.simple;
    };
    SimpleExpressionChecker.prototype.visitImplicitReceiver = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitInterpolation = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitPropertyRead = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitPropertyWrite = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitSafePropertyRead = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitMethodCall = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitSafeMethodCall = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitFunctionCall = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitLiteralArray = function(ast, context) {
      this.visitAll(ast.expressions);
    };
    SimpleExpressionChecker.prototype.visitLiteralMap = function(ast, context) {
      this.visitAll(ast.values);
    };
    SimpleExpressionChecker.prototype.visitBinary = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitPrefixNot = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitConditional = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitPipe = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitKeyedRead = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitKeyedWrite = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitAll = function(asts) {
      var res = ListWrapper.createFixedSize(asts.length);
      for (var i = 0; i < asts.length; ++i) {
        res[i] = asts[i].visit(this);
      }
      return res;
    };
    SimpleExpressionChecker.prototype.visitChain = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitQuote = function(ast, context) {
      this.simple = false;
    };
    return SimpleExpressionChecker;
  }());
  var HtmlTextAst = (function() {
    function HtmlTextAst(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    HtmlTextAst.prototype.visit = function(visitor, context) {
      return visitor.visitText(this, context);
    };
    return HtmlTextAst;
  }());
  var HtmlExpansionAst = (function() {
    function HtmlExpansionAst(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {
      this.switchValue = switchValue;
      this.type = type;
      this.cases = cases;
      this.sourceSpan = sourceSpan;
      this.switchValueSourceSpan = switchValueSourceSpan;
    }
    HtmlExpansionAst.prototype.visit = function(visitor, context) {
      return visitor.visitExpansion(this, context);
    };
    return HtmlExpansionAst;
  }());
  var HtmlExpansionCaseAst = (function() {
    function HtmlExpansionCaseAst(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
      this.value = value;
      this.expression = expression;
      this.sourceSpan = sourceSpan;
      this.valueSourceSpan = valueSourceSpan;
      this.expSourceSpan = expSourceSpan;
    }
    HtmlExpansionCaseAst.prototype.visit = function(visitor, context) {
      return visitor.visitExpansionCase(this, context);
    };
    return HtmlExpansionCaseAst;
  }());
  var HtmlAttrAst = (function() {
    function HtmlAttrAst(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    HtmlAttrAst.prototype.visit = function(visitor, context) {
      return visitor.visitAttr(this, context);
    };
    return HtmlAttrAst;
  }());
  var HtmlElementAst = (function() {
    function HtmlElementAst(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {
      this.name = name;
      this.attrs = attrs;
      this.children = children;
      this.sourceSpan = sourceSpan;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
    }
    HtmlElementAst.prototype.visit = function(visitor, context) {
      return visitor.visitElement(this, context);
    };
    return HtmlElementAst;
  }());
  var HtmlCommentAst = (function() {
    function HtmlCommentAst(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    HtmlCommentAst.prototype.visit = function(visitor, context) {
      return visitor.visitComment(this, context);
    };
    return HtmlCommentAst;
  }());
  function htmlVisitAll(visitor, asts, context) {
    if (context === void 0) {
      context = null;
    }
    var result = [];
    asts.forEach(function(ast) {
      var astResult = ast.visit(visitor, context);
      if (isPresent(astResult)) {
        result.push(astResult);
      }
    });
    return result;
  }
  var ParseLocation = (function() {
    function ParseLocation(file, offset, line, col) {
      this.file = file;
      this.offset = offset;
      this.line = line;
      this.col = col;
    }
    ParseLocation.prototype.toString = function() {
      return this.file.url + "@" + this.line + ":" + this.col;
    };
    return ParseLocation;
  }());
  var ParseSourceFile = (function() {
    function ParseSourceFile(content, url) {
      this.content = content;
      this.url = url;
    }
    return ParseSourceFile;
  }());
  var ParseSourceSpan = (function() {
    function ParseSourceSpan(start, end) {
      this.start = start;
      this.end = end;
    }
    ParseSourceSpan.prototype.toString = function() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    };
    return ParseSourceSpan;
  }());
  var ParseErrorLevel;
  (function(ParseErrorLevel) {
    ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
    ParseErrorLevel[ParseErrorLevel["FATAL"] = 1] = "FATAL";
  })(ParseErrorLevel || (ParseErrorLevel = {}));
  var ParseError = (function() {
    function ParseError(span, msg, level) {
      if (level === void 0) {
        level = ParseErrorLevel.FATAL;
      }
      this.span = span;
      this.msg = msg;
      this.level = level;
    }
    ParseError.prototype.toString = function() {
      var source = this.span.start.file.content;
      var ctxStart = this.span.start.offset;
      if (ctxStart > source.length - 1) {
        ctxStart = source.length - 1;
      }
      var ctxEnd = ctxStart;
      var ctxLen = 0;
      var ctxLines = 0;
      while (ctxLen < 100 && ctxStart > 0) {
        ctxStart--;
        ctxLen++;
        if (source[ctxStart] == "\n") {
          if (++ctxLines == 3) {
            break;
          }
        }
      }
      ctxLen = 0;
      ctxLines = 0;
      while (ctxLen < 100 && ctxEnd < source.length - 1) {
        ctxEnd++;
        ctxLen++;
        if (source[ctxEnd] == "\n") {
          if (++ctxLines == 3) {
            break;
          }
        }
      }
      var context = source.substring(ctxStart, this.span.start.offset) + '[ERROR ->]' + source.substring(this.span.start.offset, ctxEnd + 1);
      return this.msg + " (\"" + context + "\"): " + this.span.start;
    };
    return ParseError;
  }());
  var NAMED_ENTITIES = {
    'Aacute': '\u00C1',
    'aacute': '\u00E1',
    'Acirc': '\u00C2',
    'acirc': '\u00E2',
    'acute': '\u00B4',
    'AElig': '\u00C6',
    'aelig': '\u00E6',
    'Agrave': '\u00C0',
    'agrave': '\u00E0',
    'alefsym': '\u2135',
    'Alpha': '\u0391',
    'alpha': '\u03B1',
    'amp': '&',
    'and': '\u2227',
    'ang': '\u2220',
    'apos': '\u0027',
    'Aring': '\u00C5',
    'aring': '\u00E5',
    'asymp': '\u2248',
    'Atilde': '\u00C3',
    'atilde': '\u00E3',
    'Auml': '\u00C4',
    'auml': '\u00E4',
    'bdquo': '\u201E',
    'Beta': '\u0392',
    'beta': '\u03B2',
    'brvbar': '\u00A6',
    'bull': '\u2022',
    'cap': '\u2229',
    'Ccedil': '\u00C7',
    'ccedil': '\u00E7',
    'cedil': '\u00B8',
    'cent': '\u00A2',
    'Chi': '\u03A7',
    'chi': '\u03C7',
    'circ': '\u02C6',
    'clubs': '\u2663',
    'cong': '\u2245',
    'copy': '\u00A9',
    'crarr': '\u21B5',
    'cup': '\u222A',
    'curren': '\u00A4',
    'dagger': '\u2020',
    'Dagger': '\u2021',
    'darr': '\u2193',
    'dArr': '\u21D3',
    'deg': '\u00B0',
    'Delta': '\u0394',
    'delta': '\u03B4',
    'diams': '\u2666',
    'divide': '\u00F7',
    'Eacute': '\u00C9',
    'eacute': '\u00E9',
    'Ecirc': '\u00CA',
    'ecirc': '\u00EA',
    'Egrave': '\u00C8',
    'egrave': '\u00E8',
    'empty': '\u2205',
    'emsp': '\u2003',
    'ensp': '\u2002',
    'Epsilon': '\u0395',
    'epsilon': '\u03B5',
    'equiv': '\u2261',
    'Eta': '\u0397',
    'eta': '\u03B7',
    'ETH': '\u00D0',
    'eth': '\u00F0',
    'Euml': '\u00CB',
    'euml': '\u00EB',
    'euro': '\u20AC',
    'exist': '\u2203',
    'fnof': '\u0192',
    'forall': '\u2200',
    'frac12': '\u00BD',
    'frac14': '\u00BC',
    'frac34': '\u00BE',
    'frasl': '\u2044',
    'Gamma': '\u0393',
    'gamma': '\u03B3',
    'ge': '\u2265',
    'gt': '>',
    'harr': '\u2194',
    'hArr': '\u21D4',
    'hearts': '\u2665',
    'hellip': '\u2026',
    'Iacute': '\u00CD',
    'iacute': '\u00ED',
    'Icirc': '\u00CE',
    'icirc': '\u00EE',
    'iexcl': '\u00A1',
    'Igrave': '\u00CC',
    'igrave': '\u00EC',
    'image': '\u2111',
    'infin': '\u221E',
    'int': '\u222B',
    'Iota': '\u0399',
    'iota': '\u03B9',
    'iquest': '\u00BF',
    'isin': '\u2208',
    'Iuml': '\u00CF',
    'iuml': '\u00EF',
    'Kappa': '\u039A',
    'kappa': '\u03BA',
    'Lambda': '\u039B',
    'lambda': '\u03BB',
    'lang': '\u27E8',
    'laquo': '\u00AB',
    'larr': '\u2190',
    'lArr': '\u21D0',
    'lceil': '\u2308',
    'ldquo': '\u201C',
    'le': '\u2264',
    'lfloor': '\u230A',
    'lowast': '\u2217',
    'loz': '\u25CA',
    'lrm': '\u200E',
    'lsaquo': '\u2039',
    'lsquo': '\u2018',
    'lt': '<',
    'macr': '\u00AF',
    'mdash': '\u2014',
    'micro': '\u00B5',
    'middot': '\u00B7',
    'minus': '\u2212',
    'Mu': '\u039C',
    'mu': '\u03BC',
    'nabla': '\u2207',
    'nbsp': '\u00A0',
    'ndash': '\u2013',
    'ne': '\u2260',
    'ni': '\u220B',
    'not': '\u00AC',
    'notin': '\u2209',
    'nsub': '\u2284',
    'Ntilde': '\u00D1',
    'ntilde': '\u00F1',
    'Nu': '\u039D',
    'nu': '\u03BD',
    'Oacute': '\u00D3',
    'oacute': '\u00F3',
    'Ocirc': '\u00D4',
    'ocirc': '\u00F4',
    'OElig': '\u0152',
    'oelig': '\u0153',
    'Ograve': '\u00D2',
    'ograve': '\u00F2',
    'oline': '\u203E',
    'Omega': '\u03A9',
    'omega': '\u03C9',
    'Omicron': '\u039F',
    'omicron': '\u03BF',
    'oplus': '\u2295',
    'or': '\u2228',
    'ordf': '\u00AA',
    'ordm': '\u00BA',
    'Oslash': '\u00D8',
    'oslash': '\u00F8',
    'Otilde': '\u00D5',
    'otilde': '\u00F5',
    'otimes': '\u2297',
    'Ouml': '\u00D6',
    'ouml': '\u00F6',
    'para': '\u00B6',
    'permil': '\u2030',
    'perp': '\u22A5',
    'Phi': '\u03A6',
    'phi': '\u03C6',
    'Pi': '\u03A0',
    'pi': '\u03C0',
    'piv': '\u03D6',
    'plusmn': '\u00B1',
    'pound': '\u00A3',
    'prime': '\u2032',
    'Prime': '\u2033',
    'prod': '\u220F',
    'prop': '\u221D',
    'Psi': '\u03A8',
    'psi': '\u03C8',
    'quot': '\u0022',
    'radic': '\u221A',
    'rang': '\u27E9',
    'raquo': '\u00BB',
    'rarr': '\u2192',
    'rArr': '\u21D2',
    'rceil': '\u2309',
    'rdquo': '\u201D',
    'real': '\u211C',
    'reg': '\u00AE',
    'rfloor': '\u230B',
    'Rho': '\u03A1',
    'rho': '\u03C1',
    'rlm': '\u200F',
    'rsaquo': '\u203A',
    'rsquo': '\u2019',
    'sbquo': '\u201A',
    'Scaron': '\u0160',
    'scaron': '\u0161',
    'sdot': '\u22C5',
    'sect': '\u00A7',
    'shy': '\u00AD',
    'Sigma': '\u03A3',
    'sigma': '\u03C3',
    'sigmaf': '\u03C2',
    'sim': '\u223C',
    'spades': '\u2660',
    'sub': '\u2282',
    'sube': '\u2286',
    'sum': '\u2211',
    'sup': '\u2283',
    'sup1': '\u00B9',
    'sup2': '\u00B2',
    'sup3': '\u00B3',
    'supe': '\u2287',
    'szlig': '\u00DF',
    'Tau': '\u03A4',
    'tau': '\u03C4',
    'there4': '\u2234',
    'Theta': '\u0398',
    'theta': '\u03B8',
    'thetasym': '\u03D1',
    'thinsp': '\u2009',
    'THORN': '\u00DE',
    'thorn': '\u00FE',
    'tilde': '\u02DC',
    'times': '\u00D7',
    'trade': '\u2122',
    'Uacute': '\u00DA',
    'uacute': '\u00FA',
    'uarr': '\u2191',
    'uArr': '\u21D1',
    'Ucirc': '\u00DB',
    'ucirc': '\u00FB',
    'Ugrave': '\u00D9',
    'ugrave': '\u00F9',
    'uml': '\u00A8',
    'upsih': '\u03D2',
    'Upsilon': '\u03A5',
    'upsilon': '\u03C5',
    'Uuml': '\u00DC',
    'uuml': '\u00FC',
    'weierp': '\u2118',
    'Xi': '\u039E',
    'xi': '\u03BE',
    'Yacute': '\u00DD',
    'yacute': '\u00FD',
    'yen': '\u00A5',
    'yuml': '\u00FF',
    'Yuml': '\u0178',
    'Zeta': '\u0396',
    'zeta': '\u03B6',
    'zwj': '\u200D',
    'zwnj': '\u200C'
  };
  var HtmlTagContentType;
  (function(HtmlTagContentType) {
    HtmlTagContentType[HtmlTagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
    HtmlTagContentType[HtmlTagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
    HtmlTagContentType[HtmlTagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
  })(HtmlTagContentType || (HtmlTagContentType = {}));
  var HtmlTagDefinition = (function() {
    function HtmlTagDefinition(_a) {
      var _this = this;
      var _b = _a === void 0 ? {} : _a,
          closedByChildren = _b.closedByChildren,
          requiredParents = _b.requiredParents,
          implicitNamespacePrefix = _b.implicitNamespacePrefix,
          contentType = _b.contentType,
          closedByParent = _b.closedByParent,
          isVoid = _b.isVoid,
          ignoreFirstLf = _b.ignoreFirstLf;
      this.closedByChildren = {};
      this.closedByParent = false;
      if (isPresent(closedByChildren) && closedByChildren.length > 0) {
        closedByChildren.forEach(function(tagName) {
          return _this.closedByChildren[tagName] = true;
        });
      }
      this.isVoid = normalizeBool(isVoid);
      this.closedByParent = normalizeBool(closedByParent) || this.isVoid;
      if (isPresent(requiredParents) && requiredParents.length > 0) {
        this.requiredParents = {};
        this.parentToAdd = requiredParents[0];
        requiredParents.forEach(function(tagName) {
          return _this.requiredParents[tagName] = true;
        });
      }
      this.implicitNamespacePrefix = implicitNamespacePrefix;
      this.contentType = isPresent(contentType) ? contentType : HtmlTagContentType.PARSABLE_DATA;
      this.ignoreFirstLf = normalizeBool(ignoreFirstLf);
    }
    HtmlTagDefinition.prototype.requireExtraParent = function(currentParent) {
      if (isBlank(this.requiredParents)) {
        return false;
      }
      if (isBlank(currentParent)) {
        return true;
      }
      var lcParent = currentParent.toLowerCase();
      return this.requiredParents[lcParent] != true && lcParent != 'template';
    };
    HtmlTagDefinition.prototype.isClosedByChild = function(name) {
      return this.isVoid || normalizeBool(this.closedByChildren[name.toLowerCase()]);
    };
    return HtmlTagDefinition;
  }());
  var TAG_DEFINITIONS = {
    'base': new HtmlTagDefinition({isVoid: true}),
    'meta': new HtmlTagDefinition({isVoid: true}),
    'area': new HtmlTagDefinition({isVoid: true}),
    'embed': new HtmlTagDefinition({isVoid: true}),
    'link': new HtmlTagDefinition({isVoid: true}),
    'img': new HtmlTagDefinition({isVoid: true}),
    'input': new HtmlTagDefinition({isVoid: true}),
    'param': new HtmlTagDefinition({isVoid: true}),
    'hr': new HtmlTagDefinition({isVoid: true}),
    'br': new HtmlTagDefinition({isVoid: true}),
    'source': new HtmlTagDefinition({isVoid: true}),
    'track': new HtmlTagDefinition({isVoid: true}),
    'wbr': new HtmlTagDefinition({isVoid: true}),
    'p': new HtmlTagDefinition({
      closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],
      closedByParent: true
    }),
    'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),
    'tbody': new HtmlTagDefinition({
      closedByChildren: ['tbody', 'tfoot'],
      closedByParent: true
    }),
    'tfoot': new HtmlTagDefinition({
      closedByChildren: ['tbody'],
      closedByParent: true
    }),
    'tr': new HtmlTagDefinition({
      closedByChildren: ['tr'],
      requiredParents: ['tbody', 'tfoot', 'thead'],
      closedByParent: true
    }),
    'td': new HtmlTagDefinition({
      closedByChildren: ['td', 'th'],
      closedByParent: true
    }),
    'th': new HtmlTagDefinition({
      closedByChildren: ['td', 'th'],
      closedByParent: true
    }),
    'col': new HtmlTagDefinition({
      requiredParents: ['colgroup'],
      isVoid: true
    }),
    'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),
    'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),
    'li': new HtmlTagDefinition({
      closedByChildren: ['li'],
      closedByParent: true
    }),
    'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),
    'dd': new HtmlTagDefinition({
      closedByChildren: ['dt', 'dd'],
      closedByParent: true
    }),
    'rb': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
      closedByParent: true
    }),
    'rt': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
      closedByParent: true
    }),
    'rtc': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rtc', 'rp'],
      closedByParent: true
    }),
    'rp': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
      closedByParent: true
    }),
    'optgroup': new HtmlTagDefinition({
      closedByChildren: ['optgroup'],
      closedByParent: true
    }),
    'option': new HtmlTagDefinition({
      closedByChildren: ['option', 'optgroup'],
      closedByParent: true
    }),
    'pre': new HtmlTagDefinition({ignoreFirstLf: true}),
    'listing': new HtmlTagDefinition({ignoreFirstLf: true}),
    'style': new HtmlTagDefinition({contentType: HtmlTagContentType.RAW_TEXT}),
    'script': new HtmlTagDefinition({contentType: HtmlTagContentType.RAW_TEXT}),
    'title': new HtmlTagDefinition({contentType: HtmlTagContentType.ESCAPABLE_RAW_TEXT}),
    'textarea': new HtmlTagDefinition({
      contentType: HtmlTagContentType.ESCAPABLE_RAW_TEXT,
      ignoreFirstLf: true
    })
  };
  var DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
  function getHtmlTagDefinition(tagName) {
    var result = TAG_DEFINITIONS[tagName.toLowerCase()];
    return isPresent(result) ? result : DEFAULT_TAG_DEFINITION;
  }
  var NS_PREFIX_RE = /^@([^:]+):(.+)/g;
  function splitNsName(elementName) {
    if (elementName[0] != '@') {
      return [null, elementName];
    }
    var match = RegExpWrapper.firstMatch(NS_PREFIX_RE, elementName);
    return [match[1], match[2]];
  }
  function getNsPrefix(elementName) {
    return splitNsName(elementName)[0];
  }
  function mergeNsAndName(prefix, localName) {
    return isPresent(prefix) ? "@" + prefix + ":" + localName : localName;
  }
  var HtmlTokenType;
  (function(HtmlTokenType) {
    HtmlTokenType[HtmlTokenType["TAG_OPEN_START"] = 0] = "TAG_OPEN_START";
    HtmlTokenType[HtmlTokenType["TAG_OPEN_END"] = 1] = "TAG_OPEN_END";
    HtmlTokenType[HtmlTokenType["TAG_OPEN_END_VOID"] = 2] = "TAG_OPEN_END_VOID";
    HtmlTokenType[HtmlTokenType["TAG_CLOSE"] = 3] = "TAG_CLOSE";
    HtmlTokenType[HtmlTokenType["TEXT"] = 4] = "TEXT";
    HtmlTokenType[HtmlTokenType["ESCAPABLE_RAW_TEXT"] = 5] = "ESCAPABLE_RAW_TEXT";
    HtmlTokenType[HtmlTokenType["RAW_TEXT"] = 6] = "RAW_TEXT";
    HtmlTokenType[HtmlTokenType["COMMENT_START"] = 7] = "COMMENT_START";
    HtmlTokenType[HtmlTokenType["COMMENT_END"] = 8] = "COMMENT_END";
    HtmlTokenType[HtmlTokenType["CDATA_START"] = 9] = "CDATA_START";
    HtmlTokenType[HtmlTokenType["CDATA_END"] = 10] = "CDATA_END";
    HtmlTokenType[HtmlTokenType["ATTR_NAME"] = 11] = "ATTR_NAME";
    HtmlTokenType[HtmlTokenType["ATTR_VALUE"] = 12] = "ATTR_VALUE";
    HtmlTokenType[HtmlTokenType["DOC_TYPE"] = 13] = "DOC_TYPE";
    HtmlTokenType[HtmlTokenType["EXPANSION_FORM_START"] = 14] = "EXPANSION_FORM_START";
    HtmlTokenType[HtmlTokenType["EXPANSION_CASE_VALUE"] = 15] = "EXPANSION_CASE_VALUE";
    HtmlTokenType[HtmlTokenType["EXPANSION_CASE_EXP_START"] = 16] = "EXPANSION_CASE_EXP_START";
    HtmlTokenType[HtmlTokenType["EXPANSION_CASE_EXP_END"] = 17] = "EXPANSION_CASE_EXP_END";
    HtmlTokenType[HtmlTokenType["EXPANSION_FORM_END"] = 18] = "EXPANSION_FORM_END";
    HtmlTokenType[HtmlTokenType["EOF"] = 19] = "EOF";
  })(HtmlTokenType || (HtmlTokenType = {}));
  var HtmlToken = (function() {
    function HtmlToken(type, parts, sourceSpan) {
      this.type = type;
      this.parts = parts;
      this.sourceSpan = sourceSpan;
    }
    return HtmlToken;
  }());
  var HtmlTokenError = (function(_super) {
    __extends(HtmlTokenError, _super);
    function HtmlTokenError(errorMsg, tokenType, span) {
      _super.call(this, span, errorMsg);
      this.tokenType = tokenType;
    }
    return HtmlTokenError;
  }(ParseError));
  var HtmlTokenizeResult = (function() {
    function HtmlTokenizeResult(tokens, errors) {
      this.tokens = tokens;
      this.errors = errors;
    }
    return HtmlTokenizeResult;
  }());
  function tokenizeHtml(sourceContent, sourceUrl, tokenizeExpansionForms) {
    if (tokenizeExpansionForms === void 0) {
      tokenizeExpansionForms = false;
    }
    return new _HtmlTokenizer(new ParseSourceFile(sourceContent, sourceUrl), tokenizeExpansionForms).tokenize();
  }
  var $EOF$1 = 0;
  var $TAB$1 = 9;
  var $LF$1 = 10;
  var $CR$1 = 13;
  var $SPACE$1 = 32;
  var $BANG$1 = 33;
  var $DQ$1 = 34;
  var $HASH$1 = 35;
  var $AMPERSAND$1 = 38;
  var $SQ$1 = 39;
  var $MINUS$1 = 45;
  var $SLASH$1 = 47;
  var $0$1 = 48;
  var $SEMICOLON$1 = 59;
  var $9$1 = 57;
  var $COLON$1 = 58;
  var $LT$1 = 60;
  var $EQ$1 = 61;
  var $GT$1 = 62;
  var $LBRACKET$1 = 91;
  var $RBRACKET$1 = 93;
  var $LBRACE$1 = 123;
  var $RBRACE$1 = 125;
  var $COMMA$1 = 44;
  var $A$1 = 65;
  var $F = 70;
  var $X = 88;
  var $Z$1 = 90;
  var $a$1 = 97;
  var $f$1 = 102;
  var $z$1 = 122;
  var $x = 120;
  var $NBSP$1 = 160;
  var CR_OR_CRLF_REGEXP = /\r\n?/g;
  function unexpectedCharacterErrorMsg(charCode) {
    var char = charCode === $EOF$1 ? 'EOF' : StringWrapper.fromCharCode(charCode);
    return "Unexpected character \"" + char + "\"";
  }
  function unknownEntityErrorMsg(entitySrc) {
    return "Unknown entity \"" + entitySrc + "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax";
  }
  var ControlFlowError = (function() {
    function ControlFlowError(error) {
      this.error = error;
    }
    return ControlFlowError;
  }());
  var _HtmlTokenizer = (function() {
    function _HtmlTokenizer(file, tokenizeExpansionForms) {
      this.file = file;
      this.tokenizeExpansionForms = tokenizeExpansionForms;
      this.peek = -1;
      this.nextPeek = -1;
      this.index = -1;
      this.line = 0;
      this.column = -1;
      this.expansionCaseStack = [];
      this.tokens = [];
      this.errors = [];
      this.input = file.content;
      this.length = file.content.length;
      this._advance();
    }
    _HtmlTokenizer.prototype._processCarriageReturns = function(content) {
      return StringWrapper.replaceAll(content, CR_OR_CRLF_REGEXP, '\n');
    };
    _HtmlTokenizer.prototype.tokenize = function() {
      while (this.peek !== $EOF$1) {
        var start = this._getLocation();
        try {
          if (this._attemptCharCode($LT$1)) {
            if (this._attemptCharCode($BANG$1)) {
              if (this._attemptCharCode($LBRACKET$1)) {
                this._consumeCdata(start);
              } else if (this._attemptCharCode($MINUS$1)) {
                this._consumeComment(start);
              } else {
                this._consumeDocType(start);
              }
            } else if (this._attemptCharCode($SLASH$1)) {
              this._consumeTagClose(start);
            } else {
              this._consumeTagOpen(start);
            }
          } else if (isSpecialFormStart(this.peek, this.nextPeek) && this.tokenizeExpansionForms) {
            this._consumeExpansionFormStart();
          } else if (this.peek === $EQ$1 && this.tokenizeExpansionForms) {
            this._consumeExpansionCaseStart();
          } else if (this.peek === $RBRACE$1 && this.isInExpansionCase() && this.tokenizeExpansionForms) {
            this._consumeExpansionCaseEnd();
          } else if (this.peek === $RBRACE$1 && this.isInExpansionForm() && this.tokenizeExpansionForms) {
            this._consumeExpansionFormEnd();
          } else {
            this._consumeText();
          }
        } catch (e) {
          if (e instanceof ControlFlowError) {
            this.errors.push(e.error);
          } else {
            throw e;
          }
        }
      }
      this._beginToken(HtmlTokenType.EOF);
      this._endToken([]);
      return new HtmlTokenizeResult(mergeTextTokens(this.tokens), this.errors);
    };
    _HtmlTokenizer.prototype._getLocation = function() {
      return new ParseLocation(this.file, this.index, this.line, this.column);
    };
    _HtmlTokenizer.prototype._getSpan = function(start, end) {
      if (isBlank(start)) {
        start = this._getLocation();
      }
      if (isBlank(end)) {
        end = this._getLocation();
      }
      return new ParseSourceSpan(start, end);
    };
    _HtmlTokenizer.prototype._beginToken = function(type, start) {
      if (start === void 0) {
        start = null;
      }
      if (isBlank(start)) {
        start = this._getLocation();
      }
      this.currentTokenStart = start;
      this.currentTokenType = type;
    };
    _HtmlTokenizer.prototype._endToken = function(parts, end) {
      if (end === void 0) {
        end = null;
      }
      if (isBlank(end)) {
        end = this._getLocation();
      }
      var token = new HtmlToken(this.currentTokenType, parts, new ParseSourceSpan(this.currentTokenStart, end));
      this.tokens.push(token);
      this.currentTokenStart = null;
      this.currentTokenType = null;
      return token;
    };
    _HtmlTokenizer.prototype._createError = function(msg, span) {
      var error = new HtmlTokenError(msg, this.currentTokenType, span);
      this.currentTokenStart = null;
      this.currentTokenType = null;
      return new ControlFlowError(error);
    };
    _HtmlTokenizer.prototype._advance = function() {
      if (this.index >= this.length) {
        throw this._createError(unexpectedCharacterErrorMsg($EOF$1), this._getSpan());
      }
      if (this.peek === $LF$1) {
        this.line++;
        this.column = 0;
      } else if (this.peek !== $LF$1 && this.peek !== $CR$1) {
        this.column++;
      }
      this.index++;
      this.peek = this.index >= this.length ? $EOF$1 : StringWrapper.charCodeAt(this.input, this.index);
      this.nextPeek = this.index + 1 >= this.length ? $EOF$1 : StringWrapper.charCodeAt(this.input, this.index + 1);
    };
    _HtmlTokenizer.prototype._attemptCharCode = function(charCode) {
      if (this.peek === charCode) {
        this._advance();
        return true;
      }
      return false;
    };
    _HtmlTokenizer.prototype._attemptCharCodeCaseInsensitive = function(charCode) {
      if (compareCharCodeCaseInsensitive(this.peek, charCode)) {
        this._advance();
        return true;
      }
      return false;
    };
    _HtmlTokenizer.prototype._requireCharCode = function(charCode) {
      var location = this._getLocation();
      if (!this._attemptCharCode(charCode)) {
        throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getSpan(location, location));
      }
    };
    _HtmlTokenizer.prototype._attemptStr = function(chars) {
      for (var i = 0; i < chars.length; i++) {
        if (!this._attemptCharCode(StringWrapper.charCodeAt(chars, i))) {
          return false;
        }
      }
      return true;
    };
    _HtmlTokenizer.prototype._attemptStrCaseInsensitive = function(chars) {
      for (var i = 0; i < chars.length; i++) {
        if (!this._attemptCharCodeCaseInsensitive(StringWrapper.charCodeAt(chars, i))) {
          return false;
        }
      }
      return true;
    };
    _HtmlTokenizer.prototype._requireStr = function(chars) {
      var location = this._getLocation();
      if (!this._attemptStr(chars)) {
        throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getSpan(location));
      }
    };
    _HtmlTokenizer.prototype._attemptCharCodeUntilFn = function(predicate) {
      while (!predicate(this.peek)) {
        this._advance();
      }
    };
    _HtmlTokenizer.prototype._requireCharCodeUntilFn = function(predicate, len) {
      var start = this._getLocation();
      this._attemptCharCodeUntilFn(predicate);
      if (this.index - start.offset < len) {
        throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getSpan(start, start));
      }
    };
    _HtmlTokenizer.prototype._attemptUntilChar = function(char) {
      while (this.peek !== char) {
        this._advance();
      }
    };
    _HtmlTokenizer.prototype._readChar = function(decodeEntities) {
      if (decodeEntities && this.peek === $AMPERSAND$1) {
        return this._decodeEntity();
      } else {
        var index = this.index;
        this._advance();
        return this.input[index];
      }
    };
    _HtmlTokenizer.prototype._decodeEntity = function() {
      var start = this._getLocation();
      this._advance();
      if (this._attemptCharCode($HASH$1)) {
        var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
        var numberStart = this._getLocation().offset;
        this._attemptCharCodeUntilFn(isDigitEntityEnd);
        if (this.peek != $SEMICOLON$1) {
          throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getSpan());
        }
        this._advance();
        var strNum = this.input.substring(numberStart, this.index - 1);
        try {
          var charCode = NumberWrapper.parseInt(strNum, isHex ? 16 : 10);
          return StringWrapper.fromCharCode(charCode);
        } catch (e) {
          var entity = this.input.substring(start.offset + 1, this.index - 1);
          throw this._createError(unknownEntityErrorMsg(entity), this._getSpan(start));
        }
      } else {
        var startPosition = this._savePosition();
        this._attemptCharCodeUntilFn(isNamedEntityEnd);
        if (this.peek != $SEMICOLON$1) {
          this._restorePosition(startPosition);
          return '&';
        }
        this._advance();
        var name_1 = this.input.substring(start.offset + 1, this.index - 1);
        var char = NAMED_ENTITIES[name_1];
        if (isBlank(char)) {
          throw this._createError(unknownEntityErrorMsg(name_1), this._getSpan(start));
        }
        return char;
      }
    };
    _HtmlTokenizer.prototype._consumeRawText = function(decodeEntities, firstCharOfEnd, attemptEndRest) {
      var tagCloseStart;
      var textStart = this._getLocation();
      this._beginToken(decodeEntities ? HtmlTokenType.ESCAPABLE_RAW_TEXT : HtmlTokenType.RAW_TEXT, textStart);
      var parts = [];
      while (true) {
        tagCloseStart = this._getLocation();
        if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {
          break;
        }
        if (this.index > tagCloseStart.offset) {
          parts.push(this.input.substring(tagCloseStart.offset, this.index));
        }
        while (this.peek !== firstCharOfEnd) {
          parts.push(this._readChar(decodeEntities));
        }
      }
      return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);
    };
    _HtmlTokenizer.prototype._consumeComment = function(start) {
      var _this = this;
      this._beginToken(HtmlTokenType.COMMENT_START, start);
      this._requireCharCode($MINUS$1);
      this._endToken([]);
      var textToken = this._consumeRawText(false, $MINUS$1, function() {
        return _this._attemptStr('->');
      });
      this._beginToken(HtmlTokenType.COMMENT_END, textToken.sourceSpan.end);
      this._endToken([]);
    };
    _HtmlTokenizer.prototype._consumeCdata = function(start) {
      var _this = this;
      this._beginToken(HtmlTokenType.CDATA_START, start);
      this._requireStr('CDATA[');
      this._endToken([]);
      var textToken = this._consumeRawText(false, $RBRACKET$1, function() {
        return _this._attemptStr(']>');
      });
      this._beginToken(HtmlTokenType.CDATA_END, textToken.sourceSpan.end);
      this._endToken([]);
    };
    _HtmlTokenizer.prototype._consumeDocType = function(start) {
      this._beginToken(HtmlTokenType.DOC_TYPE, start);
      this._attemptUntilChar($GT$1);
      this._advance();
      this._endToken([this.input.substring(start.offset + 2, this.index - 1)]);
    };
    _HtmlTokenizer.prototype._consumePrefixAndName = function() {
      var nameOrPrefixStart = this.index;
      var prefix = null;
      while (this.peek !== $COLON$1 && !isPrefixEnd(this.peek)) {
        this._advance();
      }
      var nameStart;
      if (this.peek === $COLON$1) {
        this._advance();
        prefix = this.input.substring(nameOrPrefixStart, this.index - 1);
        nameStart = this.index;
      } else {
        nameStart = nameOrPrefixStart;
      }
      this._requireCharCodeUntilFn(isNameEnd, this.index === nameStart ? 1 : 0);
      var name = this.input.substring(nameStart, this.index);
      return [prefix, name];
    };
    _HtmlTokenizer.prototype._consumeTagOpen = function(start) {
      var savedPos = this._savePosition();
      var lowercaseTagName;
      try {
        if (!isAsciiLetter(this.peek)) {
          throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getSpan());
        }
        var nameStart = this.index;
        this._consumeTagOpenStart(start);
        lowercaseTagName = this.input.substring(nameStart, this.index).toLowerCase();
        this._attemptCharCodeUntilFn(isNotWhitespace);
        while (this.peek !== $SLASH$1 && this.peek !== $GT$1) {
          this._consumeAttributeName();
          this._attemptCharCodeUntilFn(isNotWhitespace);
          if (this._attemptCharCode($EQ$1)) {
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._consumeAttributeValue();
          }
          this._attemptCharCodeUntilFn(isNotWhitespace);
        }
        this._consumeTagOpenEnd();
      } catch (e) {
        if (e instanceof ControlFlowError) {
          this._restorePosition(savedPos);
          this._beginToken(HtmlTokenType.TEXT, start);
          this._endToken(['<']);
          return;
        }
        throw e;
      }
      var contentTokenType = getHtmlTagDefinition(lowercaseTagName).contentType;
      if (contentTokenType === HtmlTagContentType.RAW_TEXT) {
        this._consumeRawTextWithTagClose(lowercaseTagName, false);
      } else if (contentTokenType === HtmlTagContentType.ESCAPABLE_RAW_TEXT) {
        this._consumeRawTextWithTagClose(lowercaseTagName, true);
      }
    };
    _HtmlTokenizer.prototype._consumeRawTextWithTagClose = function(lowercaseTagName, decodeEntities) {
      var _this = this;
      var textToken = this._consumeRawText(decodeEntities, $LT$1, function() {
        if (!_this._attemptCharCode($SLASH$1))
          return false;
        _this._attemptCharCodeUntilFn(isNotWhitespace);
        if (!_this._attemptStrCaseInsensitive(lowercaseTagName))
          return false;
        _this._attemptCharCodeUntilFn(isNotWhitespace);
        if (!_this._attemptCharCode($GT$1))
          return false;
        return true;
      });
      this._beginToken(HtmlTokenType.TAG_CLOSE, textToken.sourceSpan.end);
      this._endToken([null, lowercaseTagName]);
    };
    _HtmlTokenizer.prototype._consumeTagOpenStart = function(start) {
      this._beginToken(HtmlTokenType.TAG_OPEN_START, start);
      var parts = this._consumePrefixAndName();
      this._endToken(parts);
    };
    _HtmlTokenizer.prototype._consumeAttributeName = function() {
      this._beginToken(HtmlTokenType.ATTR_NAME);
      var prefixAndName = this._consumePrefixAndName();
      this._endToken(prefixAndName);
    };
    _HtmlTokenizer.prototype._consumeAttributeValue = function() {
      this._beginToken(HtmlTokenType.ATTR_VALUE);
      var value;
      if (this.peek === $SQ$1 || this.peek === $DQ$1) {
        var quoteChar = this.peek;
        this._advance();
        var parts = [];
        while (this.peek !== quoteChar) {
          parts.push(this._readChar(true));
        }
        value = parts.join('');
        this._advance();
      } else {
        var valueStart = this.index;
        this._requireCharCodeUntilFn(isNameEnd, 1);
        value = this.input.substring(valueStart, this.index);
      }
      this._endToken([this._processCarriageReturns(value)]);
    };
    _HtmlTokenizer.prototype._consumeTagOpenEnd = function() {
      var tokenType = this._attemptCharCode($SLASH$1) ? HtmlTokenType.TAG_OPEN_END_VOID : HtmlTokenType.TAG_OPEN_END;
      this._beginToken(tokenType);
      this._requireCharCode($GT$1);
      this._endToken([]);
    };
    _HtmlTokenizer.prototype._consumeTagClose = function(start) {
      this._beginToken(HtmlTokenType.TAG_CLOSE, start);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      var prefixAndName;
      prefixAndName = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._requireCharCode($GT$1);
      this._endToken(prefixAndName);
    };
    _HtmlTokenizer.prototype._consumeExpansionFormStart = function() {
      this._beginToken(HtmlTokenType.EXPANSION_FORM_START, this._getLocation());
      this._requireCharCode($LBRACE$1);
      this._endToken([]);
      this._beginToken(HtmlTokenType.RAW_TEXT, this._getLocation());
      var condition = this._readUntil($COMMA$1);
      this._endToken([condition], this._getLocation());
      this._requireCharCode($COMMA$1);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._beginToken(HtmlTokenType.RAW_TEXT, this._getLocation());
      var type = this._readUntil($COMMA$1);
      this._endToken([type], this._getLocation());
      this._requireCharCode($COMMA$1);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this.expansionCaseStack.push(HtmlTokenType.EXPANSION_FORM_START);
    };
    _HtmlTokenizer.prototype._consumeExpansionCaseStart = function() {
      this._requireCharCode($EQ$1);
      this._beginToken(HtmlTokenType.EXPANSION_CASE_VALUE, this._getLocation());
      var value = this._readUntil($LBRACE$1).trim();
      this._endToken([value], this._getLocation());
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._beginToken(HtmlTokenType.EXPANSION_CASE_EXP_START, this._getLocation());
      this._requireCharCode($LBRACE$1);
      this._endToken([], this._getLocation());
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this.expansionCaseStack.push(HtmlTokenType.EXPANSION_CASE_EXP_START);
    };
    _HtmlTokenizer.prototype._consumeExpansionCaseEnd = function() {
      this._beginToken(HtmlTokenType.EXPANSION_CASE_EXP_END, this._getLocation());
      this._requireCharCode($RBRACE$1);
      this._endToken([], this._getLocation());
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this.expansionCaseStack.pop();
    };
    _HtmlTokenizer.prototype._consumeExpansionFormEnd = function() {
      this._beginToken(HtmlTokenType.EXPANSION_FORM_END, this._getLocation());
      this._requireCharCode($RBRACE$1);
      this._endToken([]);
      this.expansionCaseStack.pop();
    };
    _HtmlTokenizer.prototype._consumeText = function() {
      var start = this._getLocation();
      this._beginToken(HtmlTokenType.TEXT, start);
      var parts = [];
      var interpolation = false;
      if (this.peek === $LBRACE$1 && this.nextPeek === $LBRACE$1) {
        parts.push(this._readChar(true));
        parts.push(this._readChar(true));
        interpolation = true;
      } else {
        parts.push(this._readChar(true));
      }
      while (!this.isTextEnd(interpolation)) {
        if (this.peek === $LBRACE$1 && this.nextPeek === $LBRACE$1) {
          parts.push(this._readChar(true));
          parts.push(this._readChar(true));
          interpolation = true;
        } else if (this.peek === $RBRACE$1 && this.nextPeek === $RBRACE$1 && interpolation) {
          parts.push(this._readChar(true));
          parts.push(this._readChar(true));
          interpolation = false;
        } else {
          parts.push(this._readChar(true));
        }
      }
      this._endToken([this._processCarriageReturns(parts.join(''))]);
    };
    _HtmlTokenizer.prototype.isTextEnd = function(interpolation) {
      if (this.peek === $LT$1 || this.peek === $EOF$1)
        return true;
      if (this.tokenizeExpansionForms) {
        if (isSpecialFormStart(this.peek, this.nextPeek))
          return true;
        if (this.peek === $RBRACE$1 && !interpolation && (this.isInExpansionCase() || this.isInExpansionForm()))
          return true;
      }
      return false;
    };
    _HtmlTokenizer.prototype._savePosition = function() {
      return [this.peek, this.index, this.column, this.line, this.tokens.length];
    };
    _HtmlTokenizer.prototype._readUntil = function(char) {
      var start = this.index;
      this._attemptUntilChar(char);
      return this.input.substring(start, this.index);
    };
    _HtmlTokenizer.prototype._restorePosition = function(position) {
      this.peek = position[0];
      this.index = position[1];
      this.column = position[2];
      this.line = position[3];
      var nbTokens = position[4];
      if (nbTokens < this.tokens.length) {
        this.tokens = ListWrapper.slice(this.tokens, 0, nbTokens);
      }
    };
    _HtmlTokenizer.prototype.isInExpansionCase = function() {
      return this.expansionCaseStack.length > 0 && this.expansionCaseStack[this.expansionCaseStack.length - 1] === HtmlTokenType.EXPANSION_CASE_EXP_START;
    };
    _HtmlTokenizer.prototype.isInExpansionForm = function() {
      return this.expansionCaseStack.length > 0 && this.expansionCaseStack[this.expansionCaseStack.length - 1] === HtmlTokenType.EXPANSION_FORM_START;
    };
    return _HtmlTokenizer;
  }());
  function isNotWhitespace(code) {
    return !isWhitespace$1(code) || code === $EOF$1;
  }
  function isWhitespace$1(code) {
    return (code >= $TAB$1 && code <= $SPACE$1) || (code === $NBSP$1);
  }
  function isNameEnd(code) {
    return isWhitespace$1(code) || code === $GT$1 || code === $SLASH$1 || code === $SQ$1 || code === $DQ$1 || code === $EQ$1;
  }
  function isPrefixEnd(code) {
    return (code < $a$1 || $z$1 < code) && (code < $A$1 || $Z$1 < code) && (code < $0$1 || code > $9$1);
  }
  function isDigitEntityEnd(code) {
    return code == $SEMICOLON$1 || code == $EOF$1 || !isAsciiHexDigit(code);
  }
  function isNamedEntityEnd(code) {
    return code == $SEMICOLON$1 || code == $EOF$1 || !isAsciiLetter(code);
  }
  function isSpecialFormStart(peek, nextPeek) {
    return peek === $LBRACE$1 && nextPeek != $LBRACE$1;
  }
  function isAsciiLetter(code) {
    return code >= $a$1 && code <= $z$1 || code >= $A$1 && code <= $Z$1;
  }
  function isAsciiHexDigit(code) {
    return code >= $a$1 && code <= $f$1 || code >= $A$1 && code <= $F || code >= $0$1 && code <= $9$1;
  }
  function compareCharCodeCaseInsensitive(code1, code2) {
    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
  }
  function toUpperCaseCharCode(code) {
    return code >= $a$1 && code <= $z$1 ? code - $a$1 + $A$1 : code;
  }
  function mergeTextTokens(srcTokens) {
    var dstTokens = [];
    var lastDstToken;
    for (var i = 0; i < srcTokens.length; i++) {
      var token = srcTokens[i];
      if (isPresent(lastDstToken) && lastDstToken.type == HtmlTokenType.TEXT && token.type == HtmlTokenType.TEXT) {
        lastDstToken.parts[0] += token.parts[0];
        lastDstToken.sourceSpan.end = token.sourceSpan.end;
      } else {
        lastDstToken = token;
        dstTokens.push(lastDstToken);
      }
    }
    return dstTokens;
  }
  var HtmlTreeError = (function(_super) {
    __extends(HtmlTreeError, _super);
    function HtmlTreeError(elementName, span, msg) {
      _super.call(this, span, msg);
      this.elementName = elementName;
    }
    HtmlTreeError.create = function(elementName, span, msg) {
      return new HtmlTreeError(elementName, span, msg);
    };
    return HtmlTreeError;
  }(ParseError));
  var HtmlParseTreeResult = (function() {
    function HtmlParseTreeResult(rootNodes, errors) {
      this.rootNodes = rootNodes;
      this.errors = errors;
    }
    return HtmlParseTreeResult;
  }());
  var HtmlParser = (function() {
    function HtmlParser() {}
    HtmlParser.prototype.parse = function(sourceContent, sourceUrl, parseExpansionForms) {
      if (parseExpansionForms === void 0) {
        parseExpansionForms = false;
      }
      var tokensAndErrors = tokenizeHtml(sourceContent, sourceUrl, parseExpansionForms);
      var treeAndErrors = new TreeBuilder(tokensAndErrors.tokens).build();
      return new HtmlParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));
    };
    return HtmlParser;
  }());
  HtmlParser.decorators = [{type: _angular_core.Injectable}];
  var TreeBuilder = (function() {
    function TreeBuilder(tokens) {
      this.tokens = tokens;
      this.index = -1;
      this.rootNodes = [];
      this.errors = [];
      this.elementStack = [];
      this._advance();
    }
    TreeBuilder.prototype.build = function() {
      while (this.peek.type !== HtmlTokenType.EOF) {
        if (this.peek.type === HtmlTokenType.TAG_OPEN_START) {
          this._consumeStartTag(this._advance());
        } else if (this.peek.type === HtmlTokenType.TAG_CLOSE) {
          this._consumeEndTag(this._advance());
        } else if (this.peek.type === HtmlTokenType.CDATA_START) {
          this._closeVoidElement();
          this._consumeCdata(this._advance());
        } else if (this.peek.type === HtmlTokenType.COMMENT_START) {
          this._closeVoidElement();
          this._consumeComment(this._advance());
        } else if (this.peek.type === HtmlTokenType.TEXT || this.peek.type === HtmlTokenType.RAW_TEXT || this.peek.type === HtmlTokenType.ESCAPABLE_RAW_TEXT) {
          this._closeVoidElement();
          this._consumeText(this._advance());
        } else if (this.peek.type === HtmlTokenType.EXPANSION_FORM_START) {
          this._consumeExpansion(this._advance());
        } else {
          this._advance();
        }
      }
      return new HtmlParseTreeResult(this.rootNodes, this.errors);
    };
    TreeBuilder.prototype._advance = function() {
      var prev = this.peek;
      if (this.index < this.tokens.length - 1) {
        this.index++;
      }
      this.peek = this.tokens[this.index];
      return prev;
    };
    TreeBuilder.prototype._advanceIf = function(type) {
      if (this.peek.type === type) {
        return this._advance();
      }
      return null;
    };
    TreeBuilder.prototype._consumeCdata = function(startToken) {
      this._consumeText(this._advance());
      this._advanceIf(HtmlTokenType.CDATA_END);
    };
    TreeBuilder.prototype._consumeComment = function(token) {
      var text = this._advanceIf(HtmlTokenType.RAW_TEXT);
      this._advanceIf(HtmlTokenType.COMMENT_END);
      var value = isPresent(text) ? text.parts[0].trim() : null;
      this._addToParent(new HtmlCommentAst(value, token.sourceSpan));
    };
    TreeBuilder.prototype._consumeExpansion = function(token) {
      var switchValue = this._advance();
      var type = this._advance();
      var cases = [];
      while (this.peek.type === HtmlTokenType.EXPANSION_CASE_VALUE) {
        var expCase = this._parseExpansionCase();
        if (isBlank(expCase))
          return;
        cases.push(expCase);
      }
      if (this.peek.type !== HtmlTokenType.EXPANSION_FORM_END) {
        this.errors.push(HtmlTreeError.create(null, this.peek.sourceSpan, "Invalid expansion form. Missing '}'."));
        return;
      }
      this._advance();
      var mainSourceSpan = new ParseSourceSpan(token.sourceSpan.start, this.peek.sourceSpan.end);
      this._addToParent(new HtmlExpansionAst(switchValue.parts[0], type.parts[0], cases, mainSourceSpan, switchValue.sourceSpan));
    };
    TreeBuilder.prototype._parseExpansionCase = function() {
      var value = this._advance();
      if (this.peek.type !== HtmlTokenType.EXPANSION_CASE_EXP_START) {
        this.errors.push(HtmlTreeError.create(null, this.peek.sourceSpan, "Invalid expansion form. Missing '{'.,"));
        return null;
      }
      var start = this._advance();
      var exp = this._collectExpansionExpTokens(start);
      if (isBlank(exp))
        return null;
      var end = this._advance();
      exp.push(new HtmlToken(HtmlTokenType.EOF, [], end.sourceSpan));
      var parsedExp = new TreeBuilder(exp).build();
      if (parsedExp.errors.length > 0) {
        this.errors = this.errors.concat(parsedExp.errors);
        return null;
      }
      var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
      var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
      return new HtmlExpansionCaseAst(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
    };
    TreeBuilder.prototype._collectExpansionExpTokens = function(start) {
      var exp = [];
      var expansionFormStack = [HtmlTokenType.EXPANSION_CASE_EXP_START];
      while (true) {
        if (this.peek.type === HtmlTokenType.EXPANSION_FORM_START || this.peek.type === HtmlTokenType.EXPANSION_CASE_EXP_START) {
          expansionFormStack.push(this.peek.type);
        }
        if (this.peek.type === HtmlTokenType.EXPANSION_CASE_EXP_END) {
          if (lastOnStack(expansionFormStack, HtmlTokenType.EXPANSION_CASE_EXP_START)) {
            expansionFormStack.pop();
            if (expansionFormStack.length == 0)
              return exp;
          } else {
            this.errors.push(HtmlTreeError.create(null, start.sourceSpan, "Invalid expansion form. Missing '}'."));
            return null;
          }
        }
        if (this.peek.type === HtmlTokenType.EXPANSION_FORM_END) {
          if (lastOnStack(expansionFormStack, HtmlTokenType.EXPANSION_FORM_START)) {
            expansionFormStack.pop();
          } else {
            this.errors.push(HtmlTreeError.create(null, start.sourceSpan, "Invalid expansion form. Missing '}'."));
            return null;
          }
        }
        if (this.peek.type === HtmlTokenType.EOF) {
          this.errors.push(HtmlTreeError.create(null, start.sourceSpan, "Invalid expansion form. Missing '}'."));
          return null;
        }
        exp.push(this._advance());
      }
    };
    TreeBuilder.prototype._consumeText = function(token) {
      var text = token.parts[0];
      if (text.length > 0 && text[0] == '\n') {
        var parent_1 = this._getParentElement();
        if (isPresent(parent_1) && parent_1.children.length == 0 && getHtmlTagDefinition(parent_1.name).ignoreFirstLf) {
          text = text.substring(1);
        }
      }
      if (text.length > 0) {
        this._addToParent(new HtmlTextAst(text, token.sourceSpan));
      }
    };
    TreeBuilder.prototype._closeVoidElement = function() {
      if (this.elementStack.length > 0) {
        var el = ListWrapper.last(this.elementStack);
        if (getHtmlTagDefinition(el.name).isVoid) {
          this.elementStack.pop();
        }
      }
    };
    TreeBuilder.prototype._consumeStartTag = function(startTagToken) {
      var prefix = startTagToken.parts[0];
      var name = startTagToken.parts[1];
      var attrs = [];
      while (this.peek.type === HtmlTokenType.ATTR_NAME) {
        attrs.push(this._consumeAttr(this._advance()));
      }
      var fullName = getElementFullName(prefix, name, this._getParentElement());
      var selfClosing = false;
      if (this.peek.type === HtmlTokenType.TAG_OPEN_END_VOID) {
        this._advance();
        selfClosing = true;
        if (getNsPrefix(fullName) == null && !getHtmlTagDefinition(fullName).isVoid) {
          this.errors.push(HtmlTreeError.create(fullName, startTagToken.sourceSpan, "Only void and foreign elements can be self closed \"" + startTagToken.parts[1] + "\""));
        }
      } else if (this.peek.type === HtmlTokenType.TAG_OPEN_END) {
        this._advance();
        selfClosing = false;
      }
      var end = this.peek.sourceSpan.start;
      var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);
      var el = new HtmlElementAst(fullName, attrs, [], span, span, null);
      this._pushElement(el);
      if (selfClosing) {
        this._popElement(fullName);
        el.endSourceSpan = span;
      }
    };
    TreeBuilder.prototype._pushElement = function(el) {
      if (this.elementStack.length > 0) {
        var parentEl = ListWrapper.last(this.elementStack);
        if (getHtmlTagDefinition(parentEl.name).isClosedByChild(el.name)) {
          this.elementStack.pop();
        }
      }
      var tagDef = getHtmlTagDefinition(el.name);
      var parentEl = this._getParentElement();
      if (tagDef.requireExtraParent(isPresent(parentEl) ? parentEl.name : null)) {
        var newParent = new HtmlElementAst(tagDef.parentToAdd, [], [el], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
        this._addToParent(newParent);
        this.elementStack.push(newParent);
        this.elementStack.push(el);
      } else {
        this._addToParent(el);
        this.elementStack.push(el);
      }
    };
    TreeBuilder.prototype._consumeEndTag = function(endTagToken) {
      var fullName = getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
      this._getParentElement().endSourceSpan = endTagToken.sourceSpan;
      if (getHtmlTagDefinition(fullName).isVoid) {
        this.errors.push(HtmlTreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"" + endTagToken.parts[1] + "\""));
      } else if (!this._popElement(fullName)) {
        this.errors.push(HtmlTreeError.create(fullName, endTagToken.sourceSpan, "Unexpected closing tag \"" + endTagToken.parts[1] + "\""));
      }
    };
    TreeBuilder.prototype._popElement = function(fullName) {
      for (var stackIndex = this.elementStack.length - 1; stackIndex >= 0; stackIndex--) {
        var el = this.elementStack[stackIndex];
        if (el.name == fullName) {
          ListWrapper.splice(this.elementStack, stackIndex, this.elementStack.length - stackIndex);
          return true;
        }
        if (!getHtmlTagDefinition(el.name).closedByParent) {
          return false;
        }
      }
      return false;
    };
    TreeBuilder.prototype._consumeAttr = function(attrName) {
      var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
      var end = attrName.sourceSpan.end;
      var value = '';
      if (this.peek.type === HtmlTokenType.ATTR_VALUE) {
        var valueToken = this._advance();
        value = valueToken.parts[0];
        end = valueToken.sourceSpan.end;
      }
      return new HtmlAttrAst(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end));
    };
    TreeBuilder.prototype._getParentElement = function() {
      return this.elementStack.length > 0 ? ListWrapper.last(this.elementStack) : null;
    };
    TreeBuilder.prototype._addToParent = function(node) {
      var parent = this._getParentElement();
      if (isPresent(parent)) {
        parent.children.push(node);
      } else {
        this.rootNodes.push(node);
      }
    };
    return TreeBuilder;
  }());
  function getElementFullName(prefix, localName, parentElement) {
    if (isBlank(prefix)) {
      prefix = getHtmlTagDefinition(localName).implicitNamespacePrefix;
      if (isBlank(prefix) && isPresent(parentElement)) {
        prefix = getNsPrefix(parentElement.name);
      }
    }
    return mergeNsAndName(prefix, localName);
  }
  function lastOnStack(stack, element) {
    return stack.length > 0 && stack[stack.length - 1] === element;
  }
  var _EMPTY_ATTR_VALUE = '';
  var _SELECTOR_REGEXP = RegExpWrapper.create('(\\:not\\()|' + '([-\\w]+)|' + '(?:\\.([-\\w]+))|' + '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' + '(\\))|' + '(\\s*,\\s*)');
  var CssSelector = (function() {
    function CssSelector() {
      this.element = null;
      this.classNames = [];
      this.attrs = [];
      this.notSelectors = [];
    }
    CssSelector.parse = function(selector) {
      var results = [];
      var _addResult = function(res, cssSel) {
        if (cssSel.notSelectors.length > 0 && isBlank(cssSel.element) && ListWrapper.isEmpty(cssSel.classNames) && ListWrapper.isEmpty(cssSel.attrs)) {
          cssSel.element = "*";
        }
        res.push(cssSel);
      };
      var cssSelector = new CssSelector();
      var matcher = RegExpWrapper.matcher(_SELECTOR_REGEXP, selector);
      var match;
      var current = cssSelector;
      var inNot = false;
      while (isPresent(match = RegExpMatcherWrapper.next(matcher))) {
        if (isPresent(match[1])) {
          if (inNot) {
            throw new BaseException$1('Nesting :not is not allowed in a selector');
          }
          inNot = true;
          current = new CssSelector();
          cssSelector.notSelectors.push(current);
        }
        if (isPresent(match[2])) {
          current.setElement(match[2]);
        }
        if (isPresent(match[3])) {
          current.addClassName(match[3]);
        }
        if (isPresent(match[4])) {
          current.addAttribute(match[4], match[5]);
        }
        if (isPresent(match[6])) {
          inNot = false;
          current = cssSelector;
        }
        if (isPresent(match[7])) {
          if (inNot) {
            throw new BaseException$1('Multiple selectors in :not are not supported');
          }
          _addResult(results, cssSelector);
          cssSelector = current = new CssSelector();
        }
      }
      _addResult(results, cssSelector);
      return results;
    };
    CssSelector.prototype.isElementSelector = function() {
      return isPresent(this.element) && ListWrapper.isEmpty(this.classNames) && ListWrapper.isEmpty(this.attrs) && this.notSelectors.length === 0;
    };
    CssSelector.prototype.setElement = function(element) {
      if (element === void 0) {
        element = null;
      }
      this.element = element;
    };
    CssSelector.prototype.getMatchingElementTemplate = function() {
      var tagName = isPresent(this.element) ? this.element : 'div';
      var classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
      var attrs = '';
      for (var i = 0; i < this.attrs.length; i += 2) {
        var attrName = this.attrs[i];
        var attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
        attrs += " " + attrName + attrValue;
      }
      return "<" + tagName + classAttr + attrs + "></" + tagName + ">";
    };
    CssSelector.prototype.addAttribute = function(name, value) {
      if (value === void 0) {
        value = _EMPTY_ATTR_VALUE;
      }
      this.attrs.push(name);
      if (isPresent(value)) {
        value = value.toLowerCase();
      } else {
        value = _EMPTY_ATTR_VALUE;
      }
      this.attrs.push(value);
    };
    CssSelector.prototype.addClassName = function(name) {
      this.classNames.push(name.toLowerCase());
    };
    CssSelector.prototype.toString = function() {
      var res = '';
      if (isPresent(this.element)) {
        res += this.element;
      }
      if (isPresent(this.classNames)) {
        for (var i = 0; i < this.classNames.length; i++) {
          res += '.' + this.classNames[i];
        }
      }
      if (isPresent(this.attrs)) {
        for (var i = 0; i < this.attrs.length; ) {
          var attrName = this.attrs[i++];
          var attrValue = this.attrs[i++];
          res += '[' + attrName;
          if (attrValue.length > 0) {
            res += '=' + attrValue;
          }
          res += ']';
        }
      }
      this.notSelectors.forEach(function(notSelector) {
        return res += ":not(" + notSelector + ")";
      });
      return res;
    };
    return CssSelector;
  }());
  var SelectorMatcher = (function() {
    function SelectorMatcher() {
      this._elementMap = new Map$1();
      this._elementPartialMap = new Map$1();
      this._classMap = new Map$1();
      this._classPartialMap = new Map$1();
      this._attrValueMap = new Map$1();
      this._attrValuePartialMap = new Map$1();
      this._listContexts = [];
    }
    SelectorMatcher.createNotMatcher = function(notSelectors) {
      var notMatcher = new SelectorMatcher();
      notMatcher.addSelectables(notSelectors, null);
      return notMatcher;
    };
    SelectorMatcher.prototype.addSelectables = function(cssSelectors, callbackCtxt) {
      var listContext = null;
      if (cssSelectors.length > 1) {
        listContext = new SelectorListContext(cssSelectors);
        this._listContexts.push(listContext);
      }
      for (var i = 0; i < cssSelectors.length; i++) {
        this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
      }
    };
    SelectorMatcher.prototype._addSelectable = function(cssSelector, callbackCtxt, listContext) {
      var matcher = this;
      var element = cssSelector.element;
      var classNames = cssSelector.classNames;
      var attrs = cssSelector.attrs;
      var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
      if (isPresent(element)) {
        var isTerminal = attrs.length === 0 && classNames.length === 0;
        if (isTerminal) {
          this._addTerminal(matcher._elementMap, element, selectable);
        } else {
          matcher = this._addPartial(matcher._elementPartialMap, element);
        }
      }
      if (isPresent(classNames)) {
        for (var index = 0; index < classNames.length; index++) {
          var isTerminal = attrs.length === 0 && index === classNames.length - 1;
          var className = classNames[index];
          if (isTerminal) {
            this._addTerminal(matcher._classMap, className, selectable);
          } else {
            matcher = this._addPartial(matcher._classPartialMap, className);
          }
        }
      }
      if (isPresent(attrs)) {
        for (var index = 0; index < attrs.length; ) {
          var isTerminal = index === attrs.length - 2;
          var attrName = attrs[index++];
          var attrValue = attrs[index++];
          if (isTerminal) {
            var terminalMap = matcher._attrValueMap;
            var terminalValuesMap = terminalMap.get(attrName);
            if (isBlank(terminalValuesMap)) {
              terminalValuesMap = new Map$1();
              terminalMap.set(attrName, terminalValuesMap);
            }
            this._addTerminal(terminalValuesMap, attrValue, selectable);
          } else {
            var parttialMap = matcher._attrValuePartialMap;
            var partialValuesMap = parttialMap.get(attrName);
            if (isBlank(partialValuesMap)) {
              partialValuesMap = new Map$1();
              parttialMap.set(attrName, partialValuesMap);
            }
            matcher = this._addPartial(partialValuesMap, attrValue);
          }
        }
      }
    };
    SelectorMatcher.prototype._addTerminal = function(map, name, selectable) {
      var terminalList = map.get(name);
      if (isBlank(terminalList)) {
        terminalList = [];
        map.set(name, terminalList);
      }
      terminalList.push(selectable);
    };
    SelectorMatcher.prototype._addPartial = function(map, name) {
      var matcher = map.get(name);
      if (isBlank(matcher)) {
        matcher = new SelectorMatcher();
        map.set(name, matcher);
      }
      return matcher;
    };
    SelectorMatcher.prototype.match = function(cssSelector, matchedCallback) {
      var result = false;
      var element = cssSelector.element;
      var classNames = cssSelector.classNames;
      var attrs = cssSelector.attrs;
      for (var i = 0; i < this._listContexts.length; i++) {
        this._listContexts[i].alreadyMatched = false;
      }
      result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
      result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;
      if (isPresent(classNames)) {
        for (var index = 0; index < classNames.length; index++) {
          var className = classNames[index];
          result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
          result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
        }
      }
      if (isPresent(attrs)) {
        for (var index = 0; index < attrs.length; ) {
          var attrName = attrs[index++];
          var attrValue = attrs[index++];
          var terminalValuesMap = this._attrValueMap.get(attrName);
          if (!StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
            result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
          }
          result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) || result;
          var partialValuesMap = this._attrValuePartialMap.get(attrName);
          if (!StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
            result = this._matchPartial(partialValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
          }
          result = this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;
        }
      }
      return result;
    };
    SelectorMatcher.prototype._matchTerminal = function(map, name, cssSelector, matchedCallback) {
      if (isBlank(map) || isBlank(name)) {
        return false;
      }
      var selectables = map.get(name);
      var starSelectables = map.get("*");
      if (isPresent(starSelectables)) {
        selectables = selectables.concat(starSelectables);
      }
      if (isBlank(selectables)) {
        return false;
      }
      var selectable;
      var result = false;
      for (var index = 0; index < selectables.length; index++) {
        selectable = selectables[index];
        result = selectable.finalize(cssSelector, matchedCallback) || result;
      }
      return result;
    };
    SelectorMatcher.prototype._matchPartial = function(map, name, cssSelector, matchedCallback) {
      if (isBlank(map) || isBlank(name)) {
        return false;
      }
      var nestedSelector = map.get(name);
      if (isBlank(nestedSelector)) {
        return false;
      }
      return nestedSelector.match(cssSelector, matchedCallback);
    };
    return SelectorMatcher;
  }());
  var SelectorListContext = (function() {
    function SelectorListContext(selectors) {
      this.selectors = selectors;
      this.alreadyMatched = false;
    }
    return SelectorListContext;
  }());
  var SelectorContext = (function() {
    function SelectorContext(selector, cbContext, listContext) {
      this.selector = selector;
      this.cbContext = cbContext;
      this.listContext = listContext;
      this.notSelectors = selector.notSelectors;
    }
    SelectorContext.prototype.finalize = function(cssSelector, callback) {
      var result = true;
      if (this.notSelectors.length > 0 && (isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
        var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
        result = !notMatcher.match(cssSelector, null);
      }
      if (result && isPresent(callback) && (isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
        if (isPresent(this.listContext)) {
          this.listContext.alreadyMatched = true;
        }
        callback(this.selector, this.cbContext);
      }
      return result;
    };
    return SelectorContext;
  }());
  var NG_CONTENT_SELECT_ATTR = 'select';
  var NG_CONTENT_ELEMENT = 'ng-content';
  var LINK_ELEMENT = 'link';
  var LINK_STYLE_REL_ATTR = 'rel';
  var LINK_STYLE_HREF_ATTR = 'href';
  var LINK_STYLE_REL_VALUE = 'stylesheet';
  var STYLE_ELEMENT = 'style';
  var SCRIPT_ELEMENT = 'script';
  var NG_NON_BINDABLE_ATTR = 'ngNonBindable';
  var NG_PROJECT_AS = 'ngProjectAs';
  function preparseElement(ast) {
    var selectAttr = null;
    var hrefAttr = null;
    var relAttr = null;
    var nonBindable = false;
    var projectAs = null;
    ast.attrs.forEach(function(attr) {
      var lcAttrName = attr.name.toLowerCase();
      if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
        selectAttr = attr.value;
      } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
        hrefAttr = attr.value;
      } else if (lcAttrName == LINK_STYLE_REL_ATTR) {
        relAttr = attr.value;
      } else if (attr.name == NG_NON_BINDABLE_ATTR) {
        nonBindable = true;
      } else if (attr.name == NG_PROJECT_AS) {
        if (attr.value.length > 0) {
          projectAs = attr.value;
        }
      }
    });
    selectAttr = normalizeNgContentSelect(selectAttr);
    var nodeName = ast.name.toLowerCase();
    var type = PreparsedElementType.OTHER;
    if (splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {
      type = PreparsedElementType.NG_CONTENT;
    } else if (nodeName == STYLE_ELEMENT) {
      type = PreparsedElementType.STYLE;
    } else if (nodeName == SCRIPT_ELEMENT) {
      type = PreparsedElementType.SCRIPT;
    } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
      type = PreparsedElementType.STYLESHEET;
    }
    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
  }
  var PreparsedElementType;
  (function(PreparsedElementType) {
    PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
    PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
    PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
    PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
    PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
  })(PreparsedElementType || (PreparsedElementType = {}));
  var PreparsedElement = (function() {
    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
      this.type = type;
      this.selectAttr = selectAttr;
      this.hrefAttr = hrefAttr;
      this.nonBindable = nonBindable;
      this.projectAs = projectAs;
    }
    return PreparsedElement;
  }());
  function normalizeNgContentSelect(selectAttr) {
    if (isBlank(selectAttr) || selectAttr.length === 0) {
      return '*';
    }
    return selectAttr;
  }
  var StyleWithImports = (function() {
    function StyleWithImports(style, styleUrls) {
      this.style = style;
      this.styleUrls = styleUrls;
    }
    return StyleWithImports;
  }());
  function isStyleUrlResolvable(url) {
    if (isBlank(url) || url.length === 0 || url[0] == '/')
      return false;
    var schemeMatch = RegExpWrapper.firstMatch(_urlWithSchemaRe, url);
    return isBlank(schemeMatch) || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
  }
  function extractStyleUrls(resolver, baseUrl, cssText) {
    var foundUrls = [];
    var modifiedCssText = StringWrapper.replaceAllMapped(cssText, _cssImportRe, function(m) {
      var url = isPresent(m[1]) ? m[1] : m[2];
      if (!isStyleUrlResolvable(url)) {
        return m[0];
      }
      foundUrls.push(resolver.resolve(baseUrl, url));
      return '';
    });
    return new StyleWithImports(modifiedCssText, foundUrls);
  }
  var _cssImportRe = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
  var _urlWithSchemaRe = /^([a-zA-Z\-\+\.]+):/g;
  var MODULE_SUFFIX = IS_DART ? '.dart' : '';
  var CAMEL_CASE_REGEXP = /([A-Z])/g;
  function camelCaseToDashCase(input) {
    return StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function(m) {
      return '-' + m[1].toLowerCase();
    });
  }
  function splitAtColon(input, defaultValues) {
    var parts = StringWrapper.split(input.trim(), /\s*:\s*/g);
    if (parts.length > 1) {
      return parts;
    } else {
      return defaultValues;
    }
  }
  function sanitizeIdentifier(name) {
    return StringWrapper.replaceAll(name, /\W/g, '_');
  }
  function visitValue(value, visitor, context) {
    if (isArray(value)) {
      return visitor.visitArray(value, context);
    } else if (isStrictStringMap(value)) {
      return visitor.visitStringMap(value, context);
    } else if (isBlank(value) || isPrimitive(value)) {
      return visitor.visitPrimitive(value, context);
    } else {
      return visitor.visitOther(value, context);
    }
  }
  var ValueTransformer = (function() {
    function ValueTransformer() {}
    ValueTransformer.prototype.visitArray = function(arr, context) {
      var _this = this;
      return arr.map(function(value) {
        return visitValue(value, _this, context);
      });
    };
    ValueTransformer.prototype.visitStringMap = function(map, context) {
      var _this = this;
      var result = {};
      StringMapWrapper.forEach(map, function(value, key) {
        result[key] = visitValue(value, _this, context);
      });
      return result;
    };
    ValueTransformer.prototype.visitPrimitive = function(value, context) {
      return value;
    };
    ValueTransformer.prototype.visitOther = function(value, context) {
      return value;
    };
    return ValueTransformer;
  }());
  function assetUrl(pkg, path, type) {
    if (path === void 0) {
      path = null;
    }
    if (type === void 0) {
      type = 'src';
    }
    if (IS_DART) {
      if (path == null) {
        return "asset:angular2/" + pkg + "/" + pkg + ".dart";
      } else {
        return "asset:angular2/lib/" + pkg + "/src/" + path + ".dart";
      }
    } else {
      if (path == null) {
        return "asset:@angular/lib/" + pkg + "/index";
      } else {
        return "asset:@angular/lib/" + pkg + "/src/" + path;
      }
    }
  }
  var _ASSET_SCHEME = 'asset:';
  function createOfflineCompileUrlResolver() {
    return new UrlResolver(_ASSET_SCHEME);
  }
  var DEFAULT_PACKAGE_URL_PROVIDER = {
    provide: _angular_core.PACKAGE_ROOT_URL,
    useValue: "/"
  };
  var UrlResolver = (function() {
    function UrlResolver(_packagePrefix) {
      if (_packagePrefix === void 0) {
        _packagePrefix = null;
      }
      this._packagePrefix = _packagePrefix;
    }
    UrlResolver.prototype.resolve = function(baseUrl, url) {
      var resolvedUrl = url;
      if (isPresent(baseUrl) && baseUrl.length > 0) {
        resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
      }
      var resolvedParts = _split(resolvedUrl);
      var prefix = this._packagePrefix;
      if (isPresent(prefix) && isPresent(resolvedParts) && resolvedParts[_ComponentIndex.Scheme] == "package") {
        var path = resolvedParts[_ComponentIndex.Path];
        if (this._packagePrefix === _ASSET_SCHEME) {
          var pathSegements = path.split(/\//);
          resolvedUrl = "asset:" + pathSegements[0] + "/lib/" + pathSegements.slice(1).join('/');
        } else {
          prefix = StringWrapper.stripRight(prefix, '/');
          path = StringWrapper.stripLeft(path, '/');
          return prefix + "/" + path;
        }
      }
      return resolvedUrl;
    };
    return UrlResolver;
  }());
  UrlResolver.decorators = [{type: _angular_core.Injectable}];
  UrlResolver.ctorParameters = [{
    type: undefined,
    decorators: [{
      type: _angular_core.Inject,
      args: [_angular_core.PACKAGE_ROOT_URL]
    }]
  }];
  function getUrlScheme(url) {
    var match = _split(url);
    return (match && match[_ComponentIndex.Scheme]) || "";
  }
  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (isPresent(opt_scheme)) {
      out.push(opt_scheme + ':');
    }
    if (isPresent(opt_domain)) {
      out.push('//');
      if (isPresent(opt_userInfo)) {
        out.push(opt_userInfo + '@');
      }
      out.push(opt_domain);
      if (isPresent(opt_port)) {
        out.push(':' + opt_port);
      }
    }
    if (isPresent(opt_path)) {
      out.push(opt_path);
    }
    if (isPresent(opt_queryData)) {
      out.push('?' + opt_queryData);
    }
    if (isPresent(opt_fragment)) {
      out.push('#' + opt_fragment);
    }
    return out.join('');
  }
  var _splitRe = RegExpWrapper.create('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var _ComponentIndex;
  (function(_ComponentIndex) {
    _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
    _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
    _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
    _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
    _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
    _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
    _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
  })(_ComponentIndex || (_ComponentIndex = {}));
  function _split(uri) {
    return RegExpWrapper.firstMatch(_splitRe, uri);
  }
  function _removeDotSegments(path) {
    if (path == '/')
      return '/';
    var leadingSlash = path[0] == '/' ? '/' : '';
    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length > 0) {
            out.pop();
          } else {
            up++;
          }
          break;
        default:
          out.push(segment);
      }
    }
    if (leadingSlash == '') {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function _joinAndCanonicalizePath(parts) {
    var path = parts[_ComponentIndex.Path];
    path = isBlank(path) ? '' : _removeDotSegments(path);
    parts[_ComponentIndex.Path] = path;
    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
  }
  function _resolveUrl(base, url) {
    var parts = _split(encodeURI(url));
    var baseParts = _split(base);
    if (isPresent(parts[_ComponentIndex.Scheme])) {
      return _joinAndCanonicalizePath(parts);
    } else {
      parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
    }
    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
      if (isBlank(parts[i])) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[_ComponentIndex.Path][0] == '/') {
      return _joinAndCanonicalizePath(parts);
    }
    var path = baseParts[_ComponentIndex.Path];
    if (isBlank(path))
      path = '/';
    var index = path.lastIndexOf('/');
    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
    parts[_ComponentIndex.Path] = path;
    return _joinAndCanonicalizePath(parts);
  }
  var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))$/g;
  var CompileMetadataWithIdentifier = (function() {
    function CompileMetadataWithIdentifier() {}
    Object.defineProperty(CompileMetadataWithIdentifier.prototype, "identifier", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return CompileMetadataWithIdentifier;
  }());
  var CompileMetadataWithType = (function(_super) {
    __extends(CompileMetadataWithType, _super);
    function CompileMetadataWithType() {
      _super.apply(this, arguments);
    }
    Object.defineProperty(CompileMetadataWithType.prototype, "type", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileMetadataWithType.prototype, "identifier", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return CompileMetadataWithType;
  }(CompileMetadataWithIdentifier));
  function metadataFromJson(data) {
    return _COMPILE_METADATA_FROM_JSON[data['class']](data);
  }
  var CompileIdentifierMetadata = (function() {
    function CompileIdentifierMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          runtime = _b.runtime,
          name = _b.name,
          moduleUrl = _b.moduleUrl,
          prefix = _b.prefix,
          value = _b.value;
      this.runtime = runtime;
      this.name = name;
      this.prefix = prefix;
      this.moduleUrl = moduleUrl;
      this.value = value;
    }
    CompileIdentifierMetadata.fromJson = function(data) {
      var value = isArray(data['value']) ? _arrayFromJson(data['value'], metadataFromJson) : _objFromJson(data['value'], metadataFromJson);
      return new CompileIdentifierMetadata({
        name: data['name'],
        prefix: data['prefix'],
        moduleUrl: data['moduleUrl'],
        value: value
      });
    };
    CompileIdentifierMetadata.prototype.toJson = function() {
      var value = isArray(this.value) ? _arrayToJson(this.value) : _objToJson(this.value);
      return {
        'class': 'Identifier',
        'name': this.name,
        'moduleUrl': this.moduleUrl,
        'prefix': this.prefix,
        'value': value
      };
    };
    Object.defineProperty(CompileIdentifierMetadata.prototype, "identifier", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    return CompileIdentifierMetadata;
  }());
  var CompileDiDependencyMetadata = (function() {
    function CompileDiDependencyMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          isAttribute = _b.isAttribute,
          isSelf = _b.isSelf,
          isHost = _b.isHost,
          isSkipSelf = _b.isSkipSelf,
          isOptional = _b.isOptional,
          isValue = _b.isValue,
          query = _b.query,
          viewQuery = _b.viewQuery,
          token = _b.token,
          value = _b.value;
      this.isAttribute = normalizeBool(isAttribute);
      this.isSelf = normalizeBool(isSelf);
      this.isHost = normalizeBool(isHost);
      this.isSkipSelf = normalizeBool(isSkipSelf);
      this.isOptional = normalizeBool(isOptional);
      this.isValue = normalizeBool(isValue);
      this.query = query;
      this.viewQuery = viewQuery;
      this.token = token;
      this.value = value;
    }
    CompileDiDependencyMetadata.fromJson = function(data) {
      return new CompileDiDependencyMetadata({
        token: _objFromJson(data['token'], CompileTokenMetadata.fromJson),
        query: _objFromJson(data['query'], CompileQueryMetadata.fromJson),
        viewQuery: _objFromJson(data['viewQuery'], CompileQueryMetadata.fromJson),
        value: data['value'],
        isAttribute: data['isAttribute'],
        isSelf: data['isSelf'],
        isHost: data['isHost'],
        isSkipSelf: data['isSkipSelf'],
        isOptional: data['isOptional'],
        isValue: data['isValue']
      });
    };
    CompileDiDependencyMetadata.prototype.toJson = function() {
      return {
        'token': _objToJson(this.token),
        'query': _objToJson(this.query),
        'viewQuery': _objToJson(this.viewQuery),
        'value': this.value,
        'isAttribute': this.isAttribute,
        'isSelf': this.isSelf,
        'isHost': this.isHost,
        'isSkipSelf': this.isSkipSelf,
        'isOptional': this.isOptional,
        'isValue': this.isValue
      };
    };
    return CompileDiDependencyMetadata;
  }());
  var CompileProviderMetadata = (function() {
    function CompileProviderMetadata(_a) {
      var token = _a.token,
          useClass = _a.useClass,
          useValue = _a.useValue,
          useExisting = _a.useExisting,
          useFactory = _a.useFactory,
          deps = _a.deps,
          multi = _a.multi;
      this.token = token;
      this.useClass = useClass;
      this.useValue = useValue;
      this.useExisting = useExisting;
      this.useFactory = useFactory;
      this.deps = normalizeBlank(deps);
      this.multi = normalizeBool(multi);
    }
    CompileProviderMetadata.fromJson = function(data) {
      return new CompileProviderMetadata({
        token: _objFromJson(data['token'], CompileTokenMetadata.fromJson),
        useClass: _objFromJson(data['useClass'], CompileTypeMetadata.fromJson),
        useExisting: _objFromJson(data['useExisting'], CompileTokenMetadata.fromJson),
        useValue: _objFromJson(data['useValue'], CompileIdentifierMetadata.fromJson),
        useFactory: _objFromJson(data['useFactory'], CompileFactoryMetadata.fromJson),
        multi: data['multi'],
        deps: _arrayFromJson(data['deps'], CompileDiDependencyMetadata.fromJson)
      });
    };
    CompileProviderMetadata.prototype.toJson = function() {
      return {
        'class': 'Provider',
        'token': _objToJson(this.token),
        'useClass': _objToJson(this.useClass),
        'useExisting': _objToJson(this.useExisting),
        'useValue': _objToJson(this.useValue),
        'useFactory': _objToJson(this.useFactory),
        'multi': this.multi,
        'deps': _arrayToJson(this.deps)
      };
    };
    return CompileProviderMetadata;
  }());
  var CompileFactoryMetadata = (function() {
    function CompileFactoryMetadata(_a) {
      var runtime = _a.runtime,
          name = _a.name,
          moduleUrl = _a.moduleUrl,
          prefix = _a.prefix,
          diDeps = _a.diDeps,
          value = _a.value;
      this.runtime = runtime;
      this.name = name;
      this.prefix = prefix;
      this.moduleUrl = moduleUrl;
      this.diDeps = _normalizeArray(diDeps);
      this.value = value;
    }
    Object.defineProperty(CompileFactoryMetadata.prototype, "identifier", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    CompileFactoryMetadata.fromJson = function(data) {
      return new CompileFactoryMetadata({
        name: data['name'],
        prefix: data['prefix'],
        moduleUrl: data['moduleUrl'],
        value: data['value'],
        diDeps: _arrayFromJson(data['diDeps'], CompileDiDependencyMetadata.fromJson)
      });
    };
    CompileFactoryMetadata.prototype.toJson = function() {
      return {
        'class': 'Factory',
        'name': this.name,
        'prefix': this.prefix,
        'moduleUrl': this.moduleUrl,
        'value': this.value,
        'diDeps': _arrayToJson(this.diDeps)
      };
    };
    return CompileFactoryMetadata;
  }());
  var CompileTokenMetadata = (function() {
    function CompileTokenMetadata(_a) {
      var value = _a.value,
          identifier = _a.identifier,
          identifierIsInstance = _a.identifierIsInstance;
      this.value = value;
      this.identifier = identifier;
      this.identifierIsInstance = normalizeBool(identifierIsInstance);
    }
    CompileTokenMetadata.fromJson = function(data) {
      return new CompileTokenMetadata({
        value: data['value'],
        identifier: _objFromJson(data['identifier'], CompileIdentifierMetadata.fromJson),
        identifierIsInstance: data['identifierIsInstance']
      });
    };
    CompileTokenMetadata.prototype.toJson = function() {
      return {
        'value': this.value,
        'identifier': _objToJson(this.identifier),
        'identifierIsInstance': this.identifierIsInstance
      };
    };
    Object.defineProperty(CompileTokenMetadata.prototype, "runtimeCacheKey", {
      get: function() {
        if (isPresent(this.identifier)) {
          return this.identifier.runtime;
        } else {
          return this.value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileTokenMetadata.prototype, "assetCacheKey", {
      get: function() {
        if (isPresent(this.identifier)) {
          return isPresent(this.identifier.moduleUrl) && isPresent(getUrlScheme(this.identifier.moduleUrl)) ? this.identifier.name + "|" + this.identifier.moduleUrl + "|" + this.identifierIsInstance : null;
        } else {
          return this.value;
        }
      },
      enumerable: true,
      configurable: true
    });
    CompileTokenMetadata.prototype.equalsTo = function(token2) {
      var rk = this.runtimeCacheKey;
      var ak = this.assetCacheKey;
      return (isPresent(rk) && rk == token2.runtimeCacheKey) || (isPresent(ak) && ak == token2.assetCacheKey);
    };
    Object.defineProperty(CompileTokenMetadata.prototype, "name", {
      get: function() {
        return isPresent(this.value) ? sanitizeIdentifier(this.value) : this.identifier.name;
      },
      enumerable: true,
      configurable: true
    });
    return CompileTokenMetadata;
  }());
  var CompileTokenMap = (function() {
    function CompileTokenMap() {
      this._valueMap = new Map();
      this._values = [];
    }
    CompileTokenMap.prototype.add = function(token, value) {
      var existing = this.get(token);
      if (isPresent(existing)) {
        throw new BaseException$1("Can only add to a TokenMap! Token: " + token.name);
      }
      this._values.push(value);
      var rk = token.runtimeCacheKey;
      if (isPresent(rk)) {
        this._valueMap.set(rk, value);
      }
      var ak = token.assetCacheKey;
      if (isPresent(ak)) {
        this._valueMap.set(ak, value);
      }
    };
    CompileTokenMap.prototype.get = function(token) {
      var rk = token.runtimeCacheKey;
      var ak = token.assetCacheKey;
      var result;
      if (isPresent(rk)) {
        result = this._valueMap.get(rk);
      }
      if (isBlank(result) && isPresent(ak)) {
        result = this._valueMap.get(ak);
      }
      return result;
    };
    CompileTokenMap.prototype.values = function() {
      return this._values;
    };
    Object.defineProperty(CompileTokenMap.prototype, "size", {
      get: function() {
        return this._values.length;
      },
      enumerable: true,
      configurable: true
    });
    return CompileTokenMap;
  }());
  var CompileTypeMetadata = (function() {
    function CompileTypeMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          runtime = _b.runtime,
          name = _b.name,
          moduleUrl = _b.moduleUrl,
          prefix = _b.prefix,
          isHost = _b.isHost,
          value = _b.value,
          diDeps = _b.diDeps;
      this.runtime = runtime;
      this.name = name;
      this.moduleUrl = moduleUrl;
      this.prefix = prefix;
      this.isHost = normalizeBool(isHost);
      this.value = value;
      this.diDeps = _normalizeArray(diDeps);
    }
    CompileTypeMetadata.fromJson = function(data) {
      return new CompileTypeMetadata({
        name: data['name'],
        moduleUrl: data['moduleUrl'],
        prefix: data['prefix'],
        isHost: data['isHost'],
        value: data['value'],
        diDeps: _arrayFromJson(data['diDeps'], CompileDiDependencyMetadata.fromJson)
      });
    };
    Object.defineProperty(CompileTypeMetadata.prototype, "identifier", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileTypeMetadata.prototype, "type", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    CompileTypeMetadata.prototype.toJson = function() {
      return {
        'class': 'Type',
        'name': this.name,
        'moduleUrl': this.moduleUrl,
        'prefix': this.prefix,
        'isHost': this.isHost,
        'value': this.value,
        'diDeps': _arrayToJson(this.diDeps)
      };
    };
    return CompileTypeMetadata;
  }());
  var CompileQueryMetadata = (function() {
    function CompileQueryMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          selectors = _b.selectors,
          descendants = _b.descendants,
          first = _b.first,
          propertyName = _b.propertyName,
          read = _b.read;
      this.selectors = selectors;
      this.descendants = normalizeBool(descendants);
      this.first = normalizeBool(first);
      this.propertyName = propertyName;
      this.read = read;
    }
    CompileQueryMetadata.fromJson = function(data) {
      return new CompileQueryMetadata({
        selectors: _arrayFromJson(data['selectors'], CompileTokenMetadata.fromJson),
        descendants: data['descendants'],
        first: data['first'],
        propertyName: data['propertyName'],
        read: _objFromJson(data['read'], CompileTokenMetadata.fromJson)
      });
    };
    CompileQueryMetadata.prototype.toJson = function() {
      return {
        'selectors': _arrayToJson(this.selectors),
        'descendants': this.descendants,
        'first': this.first,
        'propertyName': this.propertyName,
        'read': _objToJson(this.read)
      };
    };
    return CompileQueryMetadata;
  }());
  var CompileTemplateMetadata = (function() {
    function CompileTemplateMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          encapsulation = _b.encapsulation,
          template = _b.template,
          templateUrl = _b.templateUrl,
          styles = _b.styles,
          styleUrls = _b.styleUrls,
          ngContentSelectors = _b.ngContentSelectors;
      this.encapsulation = isPresent(encapsulation) ? encapsulation : _angular_core.ViewEncapsulation.Emulated;
      this.template = template;
      this.templateUrl = templateUrl;
      this.styles = isPresent(styles) ? styles : [];
      this.styleUrls = isPresent(styleUrls) ? styleUrls : [];
      this.ngContentSelectors = isPresent(ngContentSelectors) ? ngContentSelectors : [];
    }
    CompileTemplateMetadata.fromJson = function(data) {
      return new CompileTemplateMetadata({
        encapsulation: isPresent(data['encapsulation']) ? VIEW_ENCAPSULATION_VALUES[data['encapsulation']] : data['encapsulation'],
        template: data['template'],
        templateUrl: data['templateUrl'],
        styles: data['styles'],
        styleUrls: data['styleUrls'],
        ngContentSelectors: data['ngContentSelectors']
      });
    };
    CompileTemplateMetadata.prototype.toJson = function() {
      return {
        'encapsulation': isPresent(this.encapsulation) ? serializeEnum(this.encapsulation) : this.encapsulation,
        'template': this.template,
        'templateUrl': this.templateUrl,
        'styles': this.styles,
        'styleUrls': this.styleUrls,
        'ngContentSelectors': this.ngContentSelectors
      };
    };
    return CompileTemplateMetadata;
  }());
  var CompileDirectiveMetadata = (function() {
    function CompileDirectiveMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          type = _b.type,
          isComponent = _b.isComponent,
          selector = _b.selector,
          exportAs = _b.exportAs,
          changeDetection = _b.changeDetection,
          inputs = _b.inputs,
          outputs = _b.outputs,
          hostListeners = _b.hostListeners,
          hostProperties = _b.hostProperties,
          hostAttributes = _b.hostAttributes,
          lifecycleHooks = _b.lifecycleHooks,
          providers = _b.providers,
          viewProviders = _b.viewProviders,
          queries = _b.queries,
          viewQueries = _b.viewQueries,
          template = _b.template;
      this.type = type;
      this.isComponent = isComponent;
      this.selector = selector;
      this.exportAs = exportAs;
      this.changeDetection = changeDetection;
      this.inputs = inputs;
      this.outputs = outputs;
      this.hostListeners = hostListeners;
      this.hostProperties = hostProperties;
      this.hostAttributes = hostAttributes;
      this.lifecycleHooks = _normalizeArray(lifecycleHooks);
      this.providers = _normalizeArray(providers);
      this.viewProviders = _normalizeArray(viewProviders);
      this.queries = _normalizeArray(queries);
      this.viewQueries = _normalizeArray(viewQueries);
      this.template = template;
    }
    CompileDirectiveMetadata.create = function(_a) {
      var _b = _a === void 0 ? {} : _a,
          type = _b.type,
          isComponent = _b.isComponent,
          selector = _b.selector,
          exportAs = _b.exportAs,
          changeDetection = _b.changeDetection,
          inputs = _b.inputs,
          outputs = _b.outputs,
          host = _b.host,
          lifecycleHooks = _b.lifecycleHooks,
          providers = _b.providers,
          viewProviders = _b.viewProviders,
          queries = _b.queries,
          viewQueries = _b.viewQueries,
          template = _b.template;
      var hostListeners = {};
      var hostProperties = {};
      var hostAttributes = {};
      if (isPresent(host)) {
        StringMapWrapper.forEach(host, function(value, key) {
          var matches = RegExpWrapper.firstMatch(HOST_REG_EXP, key);
          if (isBlank(matches)) {
            hostAttributes[key] = value;
          } else if (isPresent(matches[1])) {
            hostProperties[matches[1]] = value;
          } else if (isPresent(matches[2])) {
            hostListeners[matches[2]] = value;
          }
        });
      }
      var inputsMap = {};
      if (isPresent(inputs)) {
        inputs.forEach(function(bindConfig) {
          var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
          inputsMap[parts[0]] = parts[1];
        });
      }
      var outputsMap = {};
      if (isPresent(outputs)) {
        outputs.forEach(function(bindConfig) {
          var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
          outputsMap[parts[0]] = parts[1];
        });
      }
      return new CompileDirectiveMetadata({
        type: type,
        isComponent: normalizeBool(isComponent),
        selector: selector,
        exportAs: exportAs,
        changeDetection: changeDetection,
        inputs: inputsMap,
        outputs: outputsMap,
        hostListeners: hostListeners,
        hostProperties: hostProperties,
        hostAttributes: hostAttributes,
        lifecycleHooks: isPresent(lifecycleHooks) ? lifecycleHooks : [],
        providers: providers,
        viewProviders: viewProviders,
        queries: queries,
        viewQueries: viewQueries,
        template: template
      });
    };
    Object.defineProperty(CompileDirectiveMetadata.prototype, "identifier", {
      get: function() {
        return this.type;
      },
      enumerable: true,
      configurable: true
    });
    CompileDirectiveMetadata.fromJson = function(data) {
      return new CompileDirectiveMetadata({
        isComponent: data['isComponent'],
        selector: data['selector'],
        exportAs: data['exportAs'],
        type: isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
        changeDetection: isPresent(data['changeDetection']) ? CHANGE_DETECTION_STRATEGY_VALUES[data['changeDetection']] : data['changeDetection'],
        inputs: data['inputs'],
        outputs: data['outputs'],
        hostListeners: data['hostListeners'],
        hostProperties: data['hostProperties'],
        hostAttributes: data['hostAttributes'],
        lifecycleHooks: data['lifecycleHooks'].map(function(hookValue) {
          return LIFECYCLE_HOOKS_VALUES[hookValue];
        }),
        template: isPresent(data['template']) ? CompileTemplateMetadata.fromJson(data['template']) : data['template'],
        providers: _arrayFromJson(data['providers'], metadataFromJson),
        viewProviders: _arrayFromJson(data['viewProviders'], metadataFromJson),
        queries: _arrayFromJson(data['queries'], CompileQueryMetadata.fromJson),
        viewQueries: _arrayFromJson(data['viewQueries'], CompileQueryMetadata.fromJson)
      });
    };
    CompileDirectiveMetadata.prototype.toJson = function() {
      return {
        'class': 'Directive',
        'isComponent': this.isComponent,
        'selector': this.selector,
        'exportAs': this.exportAs,
        'type': isPresent(this.type) ? this.type.toJson() : this.type,
        'changeDetection': isPresent(this.changeDetection) ? serializeEnum(this.changeDetection) : this.changeDetection,
        'inputs': this.inputs,
        'outputs': this.outputs,
        'hostListeners': this.hostListeners,
        'hostProperties': this.hostProperties,
        'hostAttributes': this.hostAttributes,
        'lifecycleHooks': this.lifecycleHooks.map(function(hook) {
          return serializeEnum(hook);
        }),
        'template': isPresent(this.template) ? this.template.toJson() : this.template,
        'providers': _arrayToJson(this.providers),
        'viewProviders': _arrayToJson(this.viewProviders),
        'queries': _arrayToJson(this.queries),
        'viewQueries': _arrayToJson(this.viewQueries)
      };
    };
    return CompileDirectiveMetadata;
  }());
  function createHostComponentMeta(componentType, componentSelector) {
    var template = CssSelector.parse(componentSelector)[0].getMatchingElementTemplate();
    return CompileDirectiveMetadata.create({
      type: new CompileTypeMetadata({
        runtime: Object,
        name: componentType.name + "_Host",
        moduleUrl: componentType.moduleUrl,
        isHost: true
      }),
      template: new CompileTemplateMetadata({
        template: template,
        templateUrl: '',
        styles: [],
        styleUrls: [],
        ngContentSelectors: []
      }),
      changeDetection: _angular_core.ChangeDetectionStrategy.Default,
      inputs: [],
      outputs: [],
      host: {},
      lifecycleHooks: [],
      isComponent: true,
      selector: '*',
      providers: [],
      viewProviders: [],
      queries: [],
      viewQueries: []
    });
  }
  var CompilePipeMetadata = (function() {
    function CompilePipeMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          type = _b.type,
          name = _b.name,
          pure = _b.pure,
          lifecycleHooks = _b.lifecycleHooks;
      this.type = type;
      this.name = name;
      this.pure = normalizeBool(pure);
      this.lifecycleHooks = _normalizeArray(lifecycleHooks);
    }
    Object.defineProperty(CompilePipeMetadata.prototype, "identifier", {
      get: function() {
        return this.type;
      },
      enumerable: true,
      configurable: true
    });
    CompilePipeMetadata.fromJson = function(data) {
      return new CompilePipeMetadata({
        type: isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
        name: data['name'],
        pure: data['pure']
      });
    };
    CompilePipeMetadata.prototype.toJson = function() {
      return {
        'class': 'Pipe',
        'type': isPresent(this.type) ? this.type.toJson() : null,
        'name': this.name,
        'pure': this.pure
      };
    };
    return CompilePipeMetadata;
  }());
  var _COMPILE_METADATA_FROM_JSON = {
    'Directive': CompileDirectiveMetadata.fromJson,
    'Pipe': CompilePipeMetadata.fromJson,
    'Type': CompileTypeMetadata.fromJson,
    'Provider': CompileProviderMetadata.fromJson,
    'Identifier': CompileIdentifierMetadata.fromJson,
    'Factory': CompileFactoryMetadata.fromJson
  };
  function _arrayFromJson(obj, fn) {
    return isBlank(obj) ? null : obj.map(function(o) {
      return _objFromJson(o, fn);
    });
  }
  function _arrayToJson(obj) {
    return isBlank(obj) ? null : obj.map(_objToJson);
  }
  function _objFromJson(obj, fn) {
    if (isArray(obj))
      return _arrayFromJson(obj, fn);
    if (isString(obj) || isBlank(obj) || isBoolean(obj) || isNumber(obj))
      return obj;
    return fn(obj);
  }
  function _objToJson(obj) {
    if (isArray(obj))
      return _arrayToJson(obj);
    if (isString(obj) || isBlank(obj) || isBoolean(obj) || isNumber(obj))
      return obj;
    return obj.toJson();
  }
  function _normalizeArray(obj) {
    return isPresent(obj) ? obj : [];
  }
  var APP_VIEW_MODULE_URL = assetUrl('core', 'linker/view');
  var VIEW_UTILS_MODULE_URL = assetUrl('core', 'linker/view_utils');
  var CD_MODULE_URL = assetUrl('core', 'change_detection/change_detection');
  var impViewUtils = ViewUtils;
  var impAppView = AppView;
  var impDebugAppView = DebugAppView;
  var impDebugContext = DebugContext;
  var impAppElement = AppElement;
  var impElementRef = _angular_core.ElementRef;
  var impViewContainerRef = _angular_core.ViewContainerRef;
  var impChangeDetectorRef = _angular_core.ChangeDetectorRef;
  var impRenderComponentType = _angular_core.RenderComponentType;
  var impQueryList = _angular_core.QueryList;
  var impTemplateRef = _angular_core.TemplateRef;
  var impTemplateRef_ = TemplateRef_;
  var impValueUnwrapper = ValueUnwrapper;
  var impInjector = _angular_core.Injector;
  var impViewEncapsulation = _angular_core.ViewEncapsulation;
  var impViewType = ViewType;
  var impChangeDetectionStrategy = _angular_core.ChangeDetectionStrategy;
  var impStaticNodeDebugInfo = StaticNodeDebugInfo;
  var impRenderer = _angular_core.Renderer;
  var impSimpleChange = _angular_core.SimpleChange;
  var impUninitialized = uninitialized;
  var impChangeDetectorState = ChangeDetectorState;
  var impFlattenNestedViewRenderNodes = flattenNestedViewRenderNodes;
  var impDevModeEqual = devModeEqual;
  var impInterpolate = interpolate;
  var impCheckBinding = checkBinding;
  var impCastByValue = castByValue;
  var impEMPTY_ARRAY = EMPTY_ARRAY;
  var impEMPTY_MAP = EMPTY_MAP;
  var Identifiers = (function() {
    function Identifiers() {}
    return Identifiers;
  }());
  Identifiers.ViewUtils = new CompileIdentifierMetadata({
    name: 'ViewUtils',
    moduleUrl: assetUrl('core', 'linker/view_utils'),
    runtime: impViewUtils
  });
  Identifiers.AppView = new CompileIdentifierMetadata({
    name: 'AppView',
    moduleUrl: APP_VIEW_MODULE_URL,
    runtime: impAppView
  });
  Identifiers.DebugAppView = new CompileIdentifierMetadata({
    name: 'DebugAppView',
    moduleUrl: APP_VIEW_MODULE_URL,
    runtime: impDebugAppView
  });
  Identifiers.AppElement = new CompileIdentifierMetadata({
    name: 'AppElement',
    moduleUrl: assetUrl('core', 'linker/element'),
    runtime: impAppElement
  });
  Identifiers.ElementRef = new CompileIdentifierMetadata({
    name: 'ElementRef',
    moduleUrl: assetUrl('core', 'linker/element_ref'),
    runtime: impElementRef
  });
  Identifiers.ViewContainerRef = new CompileIdentifierMetadata({
    name: 'ViewContainerRef',
    moduleUrl: assetUrl('core', 'linker/view_container_ref'),
    runtime: impViewContainerRef
  });
  Identifiers.ChangeDetectorRef = new CompileIdentifierMetadata({
    name: 'ChangeDetectorRef',
    moduleUrl: assetUrl('core', 'change_detection/change_detector_ref'),
    runtime: impChangeDetectorRef
  });
  Identifiers.RenderComponentType = new CompileIdentifierMetadata({
    name: 'RenderComponentType',
    moduleUrl: assetUrl('core', 'render/api'),
    runtime: impRenderComponentType
  });
  Identifiers.QueryList = new CompileIdentifierMetadata({
    name: 'QueryList',
    moduleUrl: assetUrl('core', 'linker/query_list'),
    runtime: impQueryList
  });
  Identifiers.TemplateRef = new CompileIdentifierMetadata({
    name: 'TemplateRef',
    moduleUrl: assetUrl('core', 'linker/template_ref'),
    runtime: impTemplateRef
  });
  Identifiers.TemplateRef_ = new CompileIdentifierMetadata({
    name: 'TemplateRef_',
    moduleUrl: assetUrl('core', 'linker/template_ref'),
    runtime: impTemplateRef_
  });
  Identifiers.ValueUnwrapper = new CompileIdentifierMetadata({
    name: 'ValueUnwrapper',
    moduleUrl: CD_MODULE_URL,
    runtime: impValueUnwrapper
  });
  Identifiers.Injector = new CompileIdentifierMetadata({
    name: 'Injector',
    moduleUrl: assetUrl('core', 'di/injector'),
    runtime: impInjector
  });
  Identifiers.ViewEncapsulation = new CompileIdentifierMetadata({
    name: 'ViewEncapsulation',
    moduleUrl: assetUrl('core', 'metadata/view'),
    runtime: impViewEncapsulation
  });
  Identifiers.ViewType = new CompileIdentifierMetadata({
    name: 'ViewType',
    moduleUrl: assetUrl('core', 'linker/view_type'),
    runtime: impViewType
  });
  Identifiers.ChangeDetectionStrategy = new CompileIdentifierMetadata({
    name: 'ChangeDetectionStrategy',
    moduleUrl: CD_MODULE_URL,
    runtime: impChangeDetectionStrategy
  });
  Identifiers.StaticNodeDebugInfo = new CompileIdentifierMetadata({
    name: 'StaticNodeDebugInfo',
    moduleUrl: assetUrl('core', 'linker/debug_context'),
    runtime: impStaticNodeDebugInfo
  });
  Identifiers.DebugContext = new CompileIdentifierMetadata({
    name: 'DebugContext',
    moduleUrl: assetUrl('core', 'linker/debug_context'),
    runtime: impDebugContext
  });
  Identifiers.Renderer = new CompileIdentifierMetadata({
    name: 'Renderer',
    moduleUrl: assetUrl('core', 'render/api'),
    runtime: impRenderer
  });
  Identifiers.SimpleChange = new CompileIdentifierMetadata({
    name: 'SimpleChange',
    moduleUrl: CD_MODULE_URL,
    runtime: impSimpleChange
  });
  Identifiers.uninitialized = new CompileIdentifierMetadata({
    name: 'uninitialized',
    moduleUrl: CD_MODULE_URL,
    runtime: impUninitialized
  });
  Identifiers.ChangeDetectorState = new CompileIdentifierMetadata({
    name: 'ChangeDetectorState',
    moduleUrl: CD_MODULE_URL,
    runtime: impChangeDetectorState
  });
  Identifiers.checkBinding = new CompileIdentifierMetadata({
    name: 'checkBinding',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: impCheckBinding
  });
  Identifiers.flattenNestedViewRenderNodes = new CompileIdentifierMetadata({
    name: 'flattenNestedViewRenderNodes',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: impFlattenNestedViewRenderNodes
  });
  Identifiers.devModeEqual = new CompileIdentifierMetadata({
    name: 'devModeEqual',
    moduleUrl: CD_MODULE_URL,
    runtime: impDevModeEqual
  });
  Identifiers.interpolate = new CompileIdentifierMetadata({
    name: 'interpolate',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: impInterpolate
  });
  Identifiers.castByValue = new CompileIdentifierMetadata({
    name: 'castByValue',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: impCastByValue
  });
  Identifiers.EMPTY_ARRAY = new CompileIdentifierMetadata({
    name: 'EMPTY_ARRAY',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: impEMPTY_ARRAY
  });
  Identifiers.EMPTY_MAP = new CompileIdentifierMetadata({
    name: 'EMPTY_MAP',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: impEMPTY_MAP
  });
  Identifiers.pureProxies = [null, new CompileIdentifierMetadata({
    name: 'pureProxy1',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: pureProxy1
  }), new CompileIdentifierMetadata({
    name: 'pureProxy2',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: pureProxy2
  }), new CompileIdentifierMetadata({
    name: 'pureProxy3',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: pureProxy3
  }), new CompileIdentifierMetadata({
    name: 'pureProxy4',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: pureProxy4
  }), new CompileIdentifierMetadata({
    name: 'pureProxy5',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: pureProxy5
  }), new CompileIdentifierMetadata({
    name: 'pureProxy6',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: pureProxy6
  }), new CompileIdentifierMetadata({
    name: 'pureProxy7',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: pureProxy7
  }), new CompileIdentifierMetadata({
    name: 'pureProxy8',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: pureProxy8
  }), new CompileIdentifierMetadata({
    name: 'pureProxy9',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: pureProxy9
  }), new CompileIdentifierMetadata({
    name: 'pureProxy10',
    moduleUrl: VIEW_UTILS_MODULE_URL,
    runtime: pureProxy10
  })];
  Identifiers.SecurityContext = new CompileIdentifierMetadata({
    name: 'SecurityContext',
    moduleUrl: assetUrl('core', 'security'),
    runtime: SecurityContext
  });
  function identifierToken(identifier) {
    return new CompileTokenMetadata({identifier: identifier});
  }
  var ProviderError = (function(_super) {
    __extends(ProviderError, _super);
    function ProviderError(message, span) {
      _super.call(this, span, message);
    }
    return ProviderError;
  }(ParseError));
  var ProviderViewContext = (function() {
    function ProviderViewContext(component, sourceSpan) {
      var _this = this;
      this.component = component;
      this.sourceSpan = sourceSpan;
      this.errors = [];
      this.viewQueries = _getViewQueries(component);
      this.viewProviders = new CompileTokenMap();
      _normalizeProviders(component.viewProviders, sourceSpan, this.errors).forEach(function(provider) {
        if (isBlank(_this.viewProviders.get(provider.token))) {
          _this.viewProviders.add(provider.token, true);
        }
      });
    }
    return ProviderViewContext;
  }());
  var ProviderElementContext = (function() {
    function ProviderElementContext(_viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, _sourceSpan) {
      var _this = this;
      this._viewContext = _viewContext;
      this._parent = _parent;
      this._isViewRoot = _isViewRoot;
      this._directiveAsts = _directiveAsts;
      this._sourceSpan = _sourceSpan;
      this._transformedProviders = new CompileTokenMap();
      this._seenProviders = new CompileTokenMap();
      this._hasViewContainer = false;
      this._attrs = {};
      attrs.forEach(function(attrAst) {
        return _this._attrs[attrAst.name] = attrAst.value;
      });
      var directivesMeta = _directiveAsts.map(function(directiveAst) {
        return directiveAst.directive;
      });
      this._allProviders = _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, _viewContext.errors);
      this._contentQueries = _getContentQueries(directivesMeta);
      var queriedTokens = new CompileTokenMap();
      this._allProviders.values().forEach(function(provider) {
        _this._addQueryReadsTo(provider.token, queriedTokens);
      });
      refs.forEach(function(refAst) {
        _this._addQueryReadsTo(new CompileTokenMetadata({value: refAst.name}), queriedTokens);
      });
      if (isPresent(queriedTokens.get(identifierToken(Identifiers.ViewContainerRef)))) {
        this._hasViewContainer = true;
      }
      this._allProviders.values().forEach(function(provider) {
        var eager = provider.eager || isPresent(queriedTokens.get(provider.token));
        if (eager) {
          _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);
        }
      });
    }
    ProviderElementContext.prototype.afterElement = function() {
      var _this = this;
      this._allProviders.values().forEach(function(provider) {
        _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);
      });
    };
    Object.defineProperty(ProviderElementContext.prototype, "transformProviders", {
      get: function() {
        return this._transformedProviders.values();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ProviderElementContext.prototype, "transformedDirectiveAsts", {
      get: function() {
        var sortedProviderTypes = this._transformedProviders.values().map(function(provider) {
          return provider.token.identifier;
        });
        var sortedDirectives = ListWrapper.clone(this._directiveAsts);
        ListWrapper.sort(sortedDirectives, function(dir1, dir2) {
          return sortedProviderTypes.indexOf(dir1.directive.type) - sortedProviderTypes.indexOf(dir2.directive.type);
        });
        return sortedDirectives;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ProviderElementContext.prototype, "transformedHasViewContainer", {
      get: function() {
        return this._hasViewContainer;
      },
      enumerable: true,
      configurable: true
    });
    ProviderElementContext.prototype._addQueryReadsTo = function(token, queryReadTokens) {
      this._getQueriesFor(token).forEach(function(query) {
        var queryReadToken = isPresent(query.read) ? query.read : token;
        if (isBlank(queryReadTokens.get(queryReadToken))) {
          queryReadTokens.add(queryReadToken, true);
        }
      });
    };
    ProviderElementContext.prototype._getQueriesFor = function(token) {
      var result = [];
      var currentEl = this;
      var distance = 0;
      var queries;
      while (currentEl !== null) {
        queries = currentEl._contentQueries.get(token);
        if (isPresent(queries)) {
          ListWrapper.addAll(result, queries.filter(function(query) {
            return query.descendants || distance <= 1;
          }));
        }
        if (currentEl._directiveAsts.length > 0) {
          distance++;
        }
        currentEl = currentEl._parent;
      }
      queries = this._viewContext.viewQueries.get(token);
      if (isPresent(queries)) {
        ListWrapper.addAll(result, queries);
      }
      return result;
    };
    ProviderElementContext.prototype._getOrCreateLocalProvider = function(requestingProviderType, token, eager) {
      var _this = this;
      var resolvedProvider = this._allProviders.get(token);
      if (isBlank(resolvedProvider) || ((requestingProviderType === exports.ProviderAstType.Directive || requestingProviderType === exports.ProviderAstType.PublicService) && resolvedProvider.providerType === exports.ProviderAstType.PrivateService) || ((requestingProviderType === exports.ProviderAstType.PrivateService || requestingProviderType === exports.ProviderAstType.PublicService) && resolvedProvider.providerType === exports.ProviderAstType.Builtin)) {
        return null;
      }
      var transformedProviderAst = this._transformedProviders.get(token);
      if (isPresent(transformedProviderAst)) {
        return transformedProviderAst;
      }
      if (isPresent(this._seenProviders.get(token))) {
        this._viewContext.errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + token.name, this._sourceSpan));
        return null;
      }
      this._seenProviders.add(token, true);
      var transformedProviders = resolvedProvider.providers.map(function(provider) {
        var transformedUseValue = provider.useValue;
        var transformedUseExisting = provider.useExisting;
        var transformedDeps;
        if (isPresent(provider.useExisting)) {
          var existingDiDep = _this._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({token: provider.useExisting}), eager);
          if (isPresent(existingDiDep.token)) {
            transformedUseExisting = existingDiDep.token;
          } else {
            transformedUseExisting = null;
            transformedUseValue = existingDiDep.value;
          }
        } else if (isPresent(provider.useFactory)) {
          var deps = isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
          transformedDeps = deps.map(function(dep) {
            return _this._getDependency(resolvedProvider.providerType, dep, eager);
          });
        } else if (isPresent(provider.useClass)) {
          var deps = isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
          transformedDeps = deps.map(function(dep) {
            return _this._getDependency(resolvedProvider.providerType, dep, eager);
          });
        }
        return _transformProvider(provider, {
          useExisting: transformedUseExisting,
          useValue: transformedUseValue,
          deps: transformedDeps
        });
      });
      transformedProviderAst = _transformProviderAst(resolvedProvider, {
        eager: eager,
        providers: transformedProviders
      });
      this._transformedProviders.add(token, transformedProviderAst);
      return transformedProviderAst;
    };
    ProviderElementContext.prototype._getLocalDependency = function(requestingProviderType, dep, eager) {
      if (eager === void 0) {
        eager = null;
      }
      if (dep.isAttribute) {
        var attrValue = this._attrs[dep.token.value];
        return new CompileDiDependencyMetadata({
          isValue: true,
          value: normalizeBlank(attrValue)
        });
      }
      if (isPresent(dep.query) || isPresent(dep.viewQuery)) {
        return dep;
      }
      if (isPresent(dep.token)) {
        if ((requestingProviderType === exports.ProviderAstType.Directive || requestingProviderType === exports.ProviderAstType.Component)) {
          if (dep.token.equalsTo(identifierToken(Identifiers.Renderer)) || dep.token.equalsTo(identifierToken(Identifiers.ElementRef)) || dep.token.equalsTo(identifierToken(Identifiers.ChangeDetectorRef)) || dep.token.equalsTo(identifierToken(Identifiers.TemplateRef))) {
            return dep;
          }
          if (dep.token.equalsTo(identifierToken(Identifiers.ViewContainerRef))) {
            this._hasViewContainer = true;
          }
        }
        if (dep.token.equalsTo(identifierToken(Identifiers.Injector))) {
          return dep;
        }
        if (isPresent(this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager))) {
          return dep;
        }
      }
      return null;
    };
    ProviderElementContext.prototype._getDependency = function(requestingProviderType, dep, eager) {
      if (eager === void 0) {
        eager = null;
      }
      var currElement = this;
      var currEager = eager;
      var result = null;
      if (!dep.isSkipSelf) {
        result = this._getLocalDependency(requestingProviderType, dep, eager);
      }
      if (dep.isSelf) {
        if (isBlank(result) && dep.isOptional) {
          result = new CompileDiDependencyMetadata({
            isValue: true,
            value: null
          });
        }
      } else {
        while (isBlank(result) && isPresent(currElement._parent)) {
          var prevElement = currElement;
          currElement = currElement._parent;
          if (prevElement._isViewRoot) {
            currEager = false;
          }
          result = currElement._getLocalDependency(exports.ProviderAstType.PublicService, dep, currEager);
        }
        if (isBlank(result)) {
          if (!dep.isHost || this._viewContext.component.type.isHost || identifierToken(this._viewContext.component.type).equalsTo(dep.token) || isPresent(this._viewContext.viewProviders.get(dep.token))) {
            result = dep;
          } else {
            result = dep.isOptional ? result = new CompileDiDependencyMetadata({
              isValue: true,
              value: null
            }) : null;
          }
        }
      }
      if (isBlank(result)) {
        this._viewContext.errors.push(new ProviderError("No provider for " + dep.token.name, this._sourceSpan));
      }
      return result;
    };
    return ProviderElementContext;
  }());
  function _transformProvider(provider, _a) {
    var useExisting = _a.useExisting,
        useValue = _a.useValue,
        deps = _a.deps;
    return new CompileProviderMetadata({
      token: provider.token,
      useClass: provider.useClass,
      useExisting: useExisting,
      useFactory: provider.useFactory,
      useValue: useValue,
      deps: deps,
      multi: provider.multi
    });
  }
  function _transformProviderAst(provider, _a) {
    var eager = _a.eager,
        providers = _a.providers;
    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.sourceSpan);
  }
  function _normalizeProviders(providers, sourceSpan, targetErrors, targetProviders) {
    if (targetProviders === void 0) {
      targetProviders = null;
    }
    if (isBlank(targetProviders)) {
      targetProviders = [];
    }
    if (isPresent(providers)) {
      providers.forEach(function(provider) {
        if (isArray(provider)) {
          _normalizeProviders(provider, sourceSpan, targetErrors, targetProviders);
        } else {
          var normalizeProvider;
          if (provider instanceof CompileProviderMetadata) {
            normalizeProvider = provider;
          } else if (provider instanceof CompileTypeMetadata) {
            normalizeProvider = new CompileProviderMetadata({
              token: new CompileTokenMetadata({identifier: provider}),
              useClass: provider
            });
          } else {
            targetErrors.push(new ProviderError("Unknown provider type " + provider, sourceSpan));
          }
          if (isPresent(normalizeProvider)) {
            targetProviders.push(normalizeProvider);
          }
        }
      });
    }
    return targetProviders;
  }
  function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
    var providersByToken = new CompileTokenMap();
    directives.forEach(function(directive) {
      var dirProvider = new CompileProviderMetadata({
        token: new CompileTokenMetadata({identifier: directive.type}),
        useClass: directive.type
      });
      _resolveProviders([dirProvider], directive.isComponent ? exports.ProviderAstType.Component : exports.ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);
    });
    var directivesWithComponentFirst = directives.filter(function(dir) {
      return dir.isComponent;
    }).concat(directives.filter(function(dir) {
      return !dir.isComponent;
    }));
    directivesWithComponentFirst.forEach(function(directive) {
      _resolveProviders(_normalizeProviders(directive.providers, sourceSpan, targetErrors), exports.ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);
      _resolveProviders(_normalizeProviders(directive.viewProviders, sourceSpan, targetErrors), exports.ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);
    });
    return providersByToken;
  }
  function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {
    providers.forEach(function(provider) {
      var resolvedProvider = targetProvidersByToken.get(provider.token);
      if (isPresent(resolvedProvider) && resolvedProvider.multiProvider !== provider.multi) {
        targetErrors.push(new ProviderError("Mixing multi and non multi provider is not possible for token " + resolvedProvider.token.name, sourceSpan));
      }
      if (isBlank(resolvedProvider)) {
        resolvedProvider = new ProviderAst(provider.token, provider.multi, eager, [provider], providerType, sourceSpan);
        targetProvidersByToken.add(provider.token, resolvedProvider);
      } else {
        if (!provider.multi) {
          ListWrapper.clear(resolvedProvider.providers);
        }
        resolvedProvider.providers.push(provider);
      }
    });
  }
  function _getViewQueries(component) {
    var viewQueries = new CompileTokenMap();
    if (isPresent(component.viewQueries)) {
      component.viewQueries.forEach(function(query) {
        return _addQueryToTokenMap(viewQueries, query);
      });
    }
    component.type.diDeps.forEach(function(dep) {
      if (isPresent(dep.viewQuery)) {
        _addQueryToTokenMap(viewQueries, dep.viewQuery);
      }
    });
    return viewQueries;
  }
  function _getContentQueries(directives) {
    var contentQueries = new CompileTokenMap();
    directives.forEach(function(directive) {
      if (isPresent(directive.queries)) {
        directive.queries.forEach(function(query) {
          return _addQueryToTokenMap(contentQueries, query);
        });
      }
      directive.type.diDeps.forEach(function(dep) {
        if (isPresent(dep.query)) {
          _addQueryToTokenMap(contentQueries, dep.query);
        }
      });
    });
    return contentQueries;
  }
  function _addQueryToTokenMap(map, query) {
    query.selectors.forEach(function(token) {
      var entry = map.get(token);
      if (isBlank(entry)) {
        entry = [];
        map.add(token, entry);
      }
      entry.push(query);
    });
  }
  var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(var-)|(let-)|(ref-|#)|(on-)|(bindon-))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/g;
  var TEMPLATE_ELEMENT = 'template';
  var TEMPLATE_ATTR = 'template';
  var TEMPLATE_ATTR_PREFIX = '*';
  var CLASS_ATTR = 'class';
  var PROPERTY_PARTS_SEPARATOR = '.';
  var ATTRIBUTE_PREFIX = 'attr';
  var CLASS_PREFIX = 'class';
  var STYLE_PREFIX = 'style';
  var TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];
  var TEMPLATE_TRANSFORMS = new _angular_core.OpaqueToken('TemplateTransforms');
  var TemplateParseError = (function(_super) {
    __extends(TemplateParseError, _super);
    function TemplateParseError(message, span, level) {
      _super.call(this, span, message, level);
    }
    return TemplateParseError;
  }(ParseError));
  var TemplateParseResult = (function() {
    function TemplateParseResult(templateAst, errors) {
      this.templateAst = templateAst;
      this.errors = errors;
    }
    return TemplateParseResult;
  }());
  var TemplateParser = (function() {
    function TemplateParser(_exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
      this._exprParser = _exprParser;
      this._schemaRegistry = _schemaRegistry;
      this._htmlParser = _htmlParser;
      this._console = _console;
      this.transforms = transforms;
    }
    TemplateParser.prototype.parse = function(component, template, directives, pipes, templateUrl) {
      var result = this.tryParse(component, template, directives, pipes, templateUrl);
      var warnings = result.errors.filter(function(error) {
        return error.level === ParseErrorLevel.WARNING;
      });
      var errors = result.errors.filter(function(error) {
        return error.level === ParseErrorLevel.FATAL;
      });
      if (warnings.length > 0) {
        this._console.warn("Template parse warnings:\n" + warnings.join('\n'));
      }
      if (errors.length > 0) {
        var errorString = errors.join('\n');
        throw new BaseException$1("Template parse errors:\n" + errorString);
      }
      return result.templateAst;
    };
    TemplateParser.prototype.tryParse = function(component, template, directives, pipes, templateUrl) {
      var htmlAstWithErrors = this._htmlParser.parse(template, templateUrl);
      var errors = htmlAstWithErrors.errors;
      var result;
      if (htmlAstWithErrors.rootNodes.length > 0) {
        var uniqDirectives = removeDuplicates(directives);
        var uniqPipes = removeDuplicates(pipes);
        var providerViewContext = new ProviderViewContext(component, htmlAstWithErrors.rootNodes[0].sourceSpan);
        var parseVisitor = new TemplateParseVisitor(providerViewContext, uniqDirectives, uniqPipes, this._exprParser, this._schemaRegistry);
        result = htmlVisitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
        errors = errors.concat(parseVisitor.errors).concat(providerViewContext.errors);
      } else {
        result = [];
      }
      if (errors.length > 0) {
        return new TemplateParseResult(result, errors);
      }
      if (isPresent(this.transforms)) {
        this.transforms.forEach(function(transform) {
          result = templateVisitAll(transform, result);
        });
      }
      return new TemplateParseResult(result, errors);
    };
    return TemplateParser;
  }());
  TemplateParser.decorators = [{type: _angular_core.Injectable}];
  TemplateParser.ctorParameters = [{type: Parser}, {type: ElementSchemaRegistry}, {type: HtmlParser}, {type: Console}, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {
      type: _angular_core.Inject,
      args: [TEMPLATE_TRANSFORMS]
    }]
  }];
  var TemplateParseVisitor = (function() {
    function TemplateParseVisitor(providerViewContext, directives, pipes, _exprParser, _schemaRegistry) {
      var _this = this;
      this.providerViewContext = providerViewContext;
      this._exprParser = _exprParser;
      this._schemaRegistry = _schemaRegistry;
      this.errors = [];
      this.directivesIndex = new Map();
      this.ngContentCount = 0;
      this.selectorMatcher = new SelectorMatcher();
      ListWrapper.forEachWithIndex(directives, function(directive, index) {
        var selector = CssSelector.parse(directive.selector);
        _this.selectorMatcher.addSelectables(selector, directive);
        _this.directivesIndex.set(directive, index);
      });
      this.pipesByName = new Map();
      pipes.forEach(function(pipe) {
        return _this.pipesByName.set(pipe.name, pipe);
      });
    }
    TemplateParseVisitor.prototype._reportError = function(message, sourceSpan, level) {
      if (level === void 0) {
        level = ParseErrorLevel.FATAL;
      }
      this.errors.push(new TemplateParseError(message, sourceSpan, level));
    };
    TemplateParseVisitor.prototype._parseInterpolation = function(value, sourceSpan) {
      var sourceInfo = sourceSpan.start.toString();
      try {
        var ast = this._exprParser.parseInterpolation(value, sourceInfo);
        this._checkPipes(ast, sourceSpan);
        if (isPresent(ast) && ast.ast.expressions.length > MAX_INTERPOLATION_VALUES) {
          throw new BaseException$1("Only support at most " + MAX_INTERPOLATION_VALUES + " interpolation values!");
        }
        return ast;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
      }
    };
    TemplateParseVisitor.prototype._parseAction = function(value, sourceSpan) {
      var sourceInfo = sourceSpan.start.toString();
      try {
        var ast = this._exprParser.parseAction(value, sourceInfo);
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
      }
    };
    TemplateParseVisitor.prototype._parseBinding = function(value, sourceSpan) {
      var sourceInfo = sourceSpan.start.toString();
      try {
        var ast = this._exprParser.parseBinding(value, sourceInfo);
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
      }
    };
    TemplateParseVisitor.prototype._parseTemplateBindings = function(value, sourceSpan) {
      var _this = this;
      var sourceInfo = sourceSpan.start.toString();
      try {
        var bindingsResult = this._exprParser.parseTemplateBindings(value, sourceInfo);
        bindingsResult.templateBindings.forEach(function(binding) {
          if (isPresent(binding.expression)) {
            _this._checkPipes(binding.expression, sourceSpan);
          }
        });
        bindingsResult.warnings.forEach(function(warning) {
          _this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
        });
        return bindingsResult.templateBindings;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return [];
      }
    };
    TemplateParseVisitor.prototype._checkPipes = function(ast, sourceSpan) {
      var _this = this;
      if (isPresent(ast)) {
        var collector = new PipeCollector();
        ast.visit(collector);
        collector.pipes.forEach(function(pipeName) {
          if (!_this.pipesByName.has(pipeName)) {
            _this._reportError("The pipe '" + pipeName + "' could not be found", sourceSpan);
          }
        });
      }
    };
    TemplateParseVisitor.prototype.visitExpansion = function(ast, context) {
      return null;
    };
    TemplateParseVisitor.prototype.visitExpansionCase = function(ast, context) {
      return null;
    };
    TemplateParseVisitor.prototype.visitText = function(ast, parent) {
      var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
      var expr = this._parseInterpolation(ast.value, ast.sourceSpan);
      if (isPresent(expr)) {
        return new BoundTextAst(expr, ngContentIndex, ast.sourceSpan);
      } else {
        return new TextAst(ast.value, ngContentIndex, ast.sourceSpan);
      }
    };
    TemplateParseVisitor.prototype.visitAttr = function(ast, contex) {
      return new AttrAst(ast.name, ast.value, ast.sourceSpan);
    };
    TemplateParseVisitor.prototype.visitComment = function(ast, context) {
      return null;
    };
    TemplateParseVisitor.prototype.visitElement = function(element, parent) {
      var _this = this;
      var nodeName = element.name;
      var preparsedElement = preparseElement(element);
      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE) {
        return null;
      }
      if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {
        return null;
      }
      var matchableAttrs = [];
      var elementOrDirectiveProps = [];
      var elementOrDirectiveRefs = [];
      var elementVars = [];
      var events = [];
      var templateElementOrDirectiveProps = [];
      var templateMatchableAttrs = [];
      var templateElementVars = [];
      var hasInlineTemplates = false;
      var attrs = [];
      var lcElName = splitNsName(nodeName.toLowerCase())[1];
      var isTemplateElement = lcElName == TEMPLATE_ELEMENT;
      element.attrs.forEach(function(attr) {
        var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);
        var hasTemplateBinding = _this._parseInlineTemplateBinding(attr, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);
        if (!hasBinding && !hasTemplateBinding) {
          attrs.push(_this.visitAttr(attr, null));
          matchableAttrs.push([attr.name, attr.value]);
        }
        if (hasTemplateBinding) {
          hasInlineTemplates = true;
        }
      });
      var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
      var directiveMetas = this._parseDirectives(this.selectorMatcher, elementCssSelector);
      var references = [];
      var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references);
      var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directiveAsts);
      var isViewRoot = parent.isTemplateElement || hasInlineTemplates;
      var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, element.sourceSpan);
      var children = htmlVisitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
      providerContext.afterElement();
      var projectionSelector = isPresent(preparsedElement.projectAs) ? CssSelector.parse(preparsedElement.projectAs)[0] : elementCssSelector;
      var ngContentIndex = parent.findNgContentIndex(projectionSelector);
      var parsedElement;
      if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
        if (isPresent(element.children) && element.children.length > 0) {
          this._reportError("<ng-content> element cannot have content. <ng-content> must be immediately followed by </ng-content>", element.sourceSpan);
        }
        parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
      } else if (isTemplateElement) {
        this._assertAllEventsPublishedByDirectives(directiveAsts, events);
        this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);
        parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
      } else {
        this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);
        var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
        parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan);
      }
      if (hasInlineTemplates) {
        var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
        var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateCssSelector);
        var templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, []);
        var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectiveAsts);
        this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);
        var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], element.sourceSpan);
        templateProviderContext.afterElement();
        parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, [parsedElement], ngContentIndex, element.sourceSpan);
      }
      return parsedElement;
    };
    TemplateParseVisitor.prototype._parseInlineTemplateBinding = function(attr, targetMatchableAttrs, targetProps, targetVars) {
      var templateBindingsSource = null;
      if (attr.name == TEMPLATE_ATTR) {
        templateBindingsSource = attr.value;
      } else if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {
        var key = attr.name.substring(TEMPLATE_ATTR_PREFIX.length);
        templateBindingsSource = (attr.value.length == 0) ? key : key + ' ' + attr.value;
      }
      if (isPresent(templateBindingsSource)) {
        var bindings = this._parseTemplateBindings(templateBindingsSource, attr.sourceSpan);
        for (var i = 0; i < bindings.length; i++) {
          var binding = bindings[i];
          if (binding.keyIsVar) {
            targetVars.push(new VariableAst(binding.key, binding.name, attr.sourceSpan));
          } else if (isPresent(binding.expression)) {
            this._parsePropertyAst(binding.key, binding.expression, attr.sourceSpan, targetMatchableAttrs, targetProps);
          } else {
            targetMatchableAttrs.push([binding.key, '']);
            this._parseLiteralAttr(binding.key, null, attr.sourceSpan, targetProps);
          }
        }
        return true;
      }
      return false;
    };
    TemplateParseVisitor.prototype._parseAttr = function(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {
      var attrName = this._normalizeAttributeName(attr.name);
      var attrValue = attr.value;
      var bindParts = RegExpWrapper.firstMatch(BIND_NAME_REGEXP, attrName);
      var hasBinding = false;
      if (isPresent(bindParts)) {
        hasBinding = true;
        if (isPresent(bindParts[1])) {
          this._parseProperty(bindParts[7], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
        } else if (isPresent(bindParts[2])) {
          var identifier = bindParts[7];
          if (isTemplateElement) {
            this._reportError("\"var-\" on <template> elements is deprecated. Use \"let-\" instead!", attr.sourceSpan, ParseErrorLevel.WARNING);
            this._parseVariable(identifier, attrValue, attr.sourceSpan, targetVars);
          } else {
            this._reportError("\"var-\" on non <template> elements is deprecated. Use \"ref-\" instead!", attr.sourceSpan, ParseErrorLevel.WARNING);
            this._parseReference(identifier, attrValue, attr.sourceSpan, targetRefs);
          }
        } else if (isPresent(bindParts[3])) {
          if (isTemplateElement) {
            var identifier = bindParts[7];
            this._parseVariable(identifier, attrValue, attr.sourceSpan, targetVars);
          } else {
            this._reportError("\"let-\" is only supported on template elements.", attr.sourceSpan);
          }
        } else if (isPresent(bindParts[4])) {
          var identifier = bindParts[7];
          this._parseReference(identifier, attrValue, attr.sourceSpan, targetRefs);
        } else if (isPresent(bindParts[5])) {
          this._parseEvent(bindParts[7], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
        } else if (isPresent(bindParts[6])) {
          this._parseProperty(bindParts[7], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
          this._parseAssignmentEvent(bindParts[7], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
        } else if (isPresent(bindParts[8])) {
          this._parseProperty(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
          this._parseAssignmentEvent(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
        } else if (isPresent(bindParts[9])) {
          this._parseProperty(bindParts[9], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
        } else if (isPresent(bindParts[10])) {
          this._parseEvent(bindParts[10], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
        }
      } else {
        hasBinding = this._parsePropertyInterpolation(attrName, attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
      }
      if (!hasBinding) {
        this._parseLiteralAttr(attrName, attrValue, attr.sourceSpan, targetProps);
      }
      return hasBinding;
    };
    TemplateParseVisitor.prototype._normalizeAttributeName = function(attrName) {
      return attrName.toLowerCase().startsWith('data-') ? attrName.substring(5) : attrName;
    };
    TemplateParseVisitor.prototype._parseVariable = function(identifier, value, sourceSpan, targetVars) {
      if (identifier.indexOf('-') > -1) {
        this._reportError("\"-\" is not allowed in variable names", sourceSpan);
      }
      targetVars.push(new VariableAst(identifier, value, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseReference = function(identifier, value, sourceSpan, targetRefs) {
      if (identifier.indexOf('-') > -1) {
        this._reportError("\"-\" is not allowed in reference names", sourceSpan);
      }
      targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseProperty = function(name, expression, sourceSpan, targetMatchableAttrs, targetProps) {
      this._parsePropertyAst(name, this._parseBinding(expression, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);
    };
    TemplateParseVisitor.prototype._parsePropertyInterpolation = function(name, value, sourceSpan, targetMatchableAttrs, targetProps) {
      var expr = this._parseInterpolation(value, sourceSpan);
      if (isPresent(expr)) {
        this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);
        return true;
      }
      return false;
    };
    TemplateParseVisitor.prototype._parsePropertyAst = function(name, ast, sourceSpan, targetMatchableAttrs, targetProps) {
      targetMatchableAttrs.push([name, ast.source]);
      targetProps.push(new BoundElementOrDirectiveProperty(name, ast, false, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseAssignmentEvent = function(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
      this._parseEvent(name + "Change", expression + "=$event", sourceSpan, targetMatchableAttrs, targetEvents);
    };
    TemplateParseVisitor.prototype._parseEvent = function(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
      var parts = splitAtColon(name, [null, name]);
      var target = parts[0];
      var eventName = parts[1];
      var ast = this._parseAction(expression, sourceSpan);
      targetMatchableAttrs.push([name, ast.source]);
      targetEvents.push(new BoundEventAst(eventName, target, ast, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseLiteralAttr = function(name, value, sourceSpan, targetProps) {
      targetProps.push(new BoundElementOrDirectiveProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), true, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseDirectives = function(selectorMatcher, elementCssSelector) {
      var _this = this;
      var directives = ListWrapper.createFixedSize(this.directivesIndex.size);
      selectorMatcher.match(elementCssSelector, function(selector, directive) {
        directives[_this.directivesIndex.get(directive)] = directive;
      });
      return directives.filter(function(dir) {
        return isPresent(dir);
      });
    };
    TemplateParseVisitor.prototype._createDirectiveAsts = function(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, sourceSpan, targetReferences) {
      var _this = this;
      var matchedReferences = new Set();
      var component = null;
      var directiveAsts = directives.map(function(directive) {
        if (directive.isComponent) {
          component = directive;
        }
        var hostProperties = [];
        var hostEvents = [];
        var directiveProperties = [];
        _this._createDirectiveHostPropertyAsts(elementName, directive.hostProperties, sourceSpan, hostProperties);
        _this._createDirectiveHostEventAsts(directive.hostListeners, sourceSpan, hostEvents);
        _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);
        elementOrDirectiveRefs.forEach(function(elOrDirRef) {
          if ((elOrDirRef.value.length === 0 && directive.isComponent) || (directive.exportAs == elOrDirRef.value)) {
            targetReferences.push(new ReferenceAst(elOrDirRef.name, identifierToken(directive.type), elOrDirRef.sourceSpan));
            matchedReferences.add(elOrDirRef.name);
          }
        });
        return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, sourceSpan);
      });
      elementOrDirectiveRefs.forEach(function(elOrDirRef) {
        if (elOrDirRef.value.length > 0) {
          if (!SetWrapper.has(matchedReferences, elOrDirRef.name)) {
            _this._reportError("There is no directive with \"exportAs\" set to \"" + elOrDirRef.value + "\"", elOrDirRef.sourceSpan);
          }
          ;
        } else if (isBlank(component)) {
          var refToken = null;
          if (isTemplateElement) {
            refToken = identifierToken(Identifiers.TemplateRef);
          }
          targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));
        }
      });
      return directiveAsts;
    };
    TemplateParseVisitor.prototype._createDirectiveHostPropertyAsts = function(elementName, hostProps, sourceSpan, targetPropertyAsts) {
      var _this = this;
      if (isPresent(hostProps)) {
        StringMapWrapper.forEach(hostProps, function(expression, propName) {
          var exprAst = _this._parseBinding(expression, sourceSpan);
          targetPropertyAsts.push(_this._createElementPropertyAst(elementName, propName, exprAst, sourceSpan));
        });
      }
    };
    TemplateParseVisitor.prototype._createDirectiveHostEventAsts = function(hostListeners, sourceSpan, targetEventAsts) {
      var _this = this;
      if (isPresent(hostListeners)) {
        StringMapWrapper.forEach(hostListeners, function(expression, propName) {
          _this._parseEvent(propName, expression, sourceSpan, [], targetEventAsts);
        });
      }
    };
    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function(directiveProperties, boundProps, targetBoundDirectiveProps) {
      if (isPresent(directiveProperties)) {
        var boundPropsByName = new Map();
        boundProps.forEach(function(boundProp) {
          var prevValue = boundPropsByName.get(boundProp.name);
          if (isBlank(prevValue) || prevValue.isLiteral) {
            boundPropsByName.set(boundProp.name, boundProp);
          }
        });
        StringMapWrapper.forEach(directiveProperties, function(elProp, dirProp) {
          var boundProp = boundPropsByName.get(elProp);
          if (isPresent(boundProp)) {
            targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
          }
        });
      }
    };
    TemplateParseVisitor.prototype._createElementPropertyAsts = function(elementName, props, directives) {
      var _this = this;
      var boundElementProps = [];
      var boundDirectivePropsIndex = new Map();
      directives.forEach(function(directive) {
        directive.inputs.forEach(function(prop) {
          boundDirectivePropsIndex.set(prop.templateName, prop);
        });
      });
      props.forEach(function(prop) {
        if (!prop.isLiteral && isBlank(boundDirectivePropsIndex.get(prop.name))) {
          boundElementProps.push(_this._createElementPropertyAst(elementName, prop.name, prop.expression, prop.sourceSpan));
        }
      });
      return boundElementProps;
    };
    TemplateParseVisitor.prototype._createElementPropertyAst = function(elementName, name, ast, sourceSpan) {
      var unit = null;
      var bindingType;
      var boundPropertyName;
      var parts = name.split(PROPERTY_PARTS_SEPARATOR);
      var securityContext;
      if (parts.length === 1) {
        boundPropertyName = this._schemaRegistry.getMappedPropName(parts[0]);
        securityContext = this._schemaRegistry.securityContext(elementName, boundPropertyName);
        bindingType = exports.PropertyBindingType.Property;
        if (!this._schemaRegistry.hasProperty(elementName, boundPropertyName)) {
          this._reportError("Can't bind to '" + boundPropertyName + "' since it isn't a known native property", sourceSpan);
        }
      } else {
        if (parts[0] == ATTRIBUTE_PREFIX) {
          boundPropertyName = parts[1];
          if (boundPropertyName.toLowerCase().startsWith('on')) {
            this._reportError(("Binding to event attribute '" + boundPropertyName + "' is disallowed ") + ("for security reasons, please use (" + boundPropertyName.slice(2) + ")=..."), sourceSpan);
          }
          securityContext = this._schemaRegistry.securityContext(elementName, this._schemaRegistry.getMappedPropName(boundPropertyName));
          var nsSeparatorIdx = boundPropertyName.indexOf(':');
          if (nsSeparatorIdx > -1) {
            var ns = boundPropertyName.substring(0, nsSeparatorIdx);
            var name_2 = boundPropertyName.substring(nsSeparatorIdx + 1);
            boundPropertyName = mergeNsAndName(ns, name_2);
          }
          bindingType = exports.PropertyBindingType.Attribute;
        } else if (parts[0] == CLASS_PREFIX) {
          boundPropertyName = parts[1];
          bindingType = exports.PropertyBindingType.Class;
          securityContext = SecurityContext.NONE;
        } else if (parts[0] == STYLE_PREFIX) {
          unit = parts.length > 2 ? parts[2] : null;
          boundPropertyName = parts[1];
          bindingType = exports.PropertyBindingType.Style;
          securityContext = SecurityContext.STYLE;
        } else {
          this._reportError("Invalid property name '" + name + "'", sourceSpan);
          bindingType = null;
          securityContext = null;
        }
      }
      return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContext, ast, unit, sourceSpan);
    };
    TemplateParseVisitor.prototype._findComponentDirectiveNames = function(directives) {
      var componentTypeNames = [];
      directives.forEach(function(directive) {
        var typeName = directive.directive.type.name;
        if (directive.directive.isComponent) {
          componentTypeNames.push(typeName);
        }
      });
      return componentTypeNames;
    };
    TemplateParseVisitor.prototype._assertOnlyOneComponent = function(directives, sourceSpan) {
      var componentTypeNames = this._findComponentDirectiveNames(directives);
      if (componentTypeNames.length > 1) {
        this._reportError("More than one component: " + componentTypeNames.join(','), sourceSpan);
      }
    };
    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function(directives, elementProps, sourceSpan) {
      var _this = this;
      var componentTypeNames = this._findComponentDirectiveNames(directives);
      if (componentTypeNames.length > 0) {
        this._reportError("Components on an embedded template: " + componentTypeNames.join(','), sourceSpan);
      }
      elementProps.forEach(function(prop) {
        _this._reportError("Property binding " + prop.name + " not used by any directive on an embedded template", sourceSpan);
      });
    };
    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function(directives, events) {
      var _this = this;
      var allDirectiveEvents = new Set();
      directives.forEach(function(directive) {
        StringMapWrapper.forEach(directive.directive.outputs, function(eventName, _) {
          allDirectiveEvents.add(eventName);
        });
      });
      events.forEach(function(event) {
        if (isPresent(event.target) || !SetWrapper.has(allDirectiveEvents, event.name)) {
          _this._reportError("Event binding " + event.fullName + " not emitted by any directive on an embedded template", event.sourceSpan);
        }
      });
    };
    return TemplateParseVisitor;
  }());
  var NonBindableVisitor = (function() {
    function NonBindableVisitor() {}
    NonBindableVisitor.prototype.visitElement = function(ast, parent) {
      var preparsedElement = preparseElement(ast);
      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {
        return null;
      }
      var attrNameAndValues = ast.attrs.map(function(attrAst) {
        return [attrAst.name, attrAst.value];
      });
      var selector = createElementCssSelector(ast.name, attrNameAndValues);
      var ngContentIndex = parent.findNgContentIndex(selector);
      var children = htmlVisitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
      return new ElementAst(ast.name, htmlVisitAll(this, ast.attrs), [], [], [], [], [], false, children, ngContentIndex, ast.sourceSpan);
    };
    NonBindableVisitor.prototype.visitComment = function(ast, context) {
      return null;
    };
    NonBindableVisitor.prototype.visitAttr = function(ast, context) {
      return new AttrAst(ast.name, ast.value, ast.sourceSpan);
    };
    NonBindableVisitor.prototype.visitText = function(ast, parent) {
      var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
      return new TextAst(ast.value, ngContentIndex, ast.sourceSpan);
    };
    NonBindableVisitor.prototype.visitExpansion = function(ast, context) {
      return ast;
    };
    NonBindableVisitor.prototype.visitExpansionCase = function(ast, context) {
      return ast;
    };
    return NonBindableVisitor;
  }());
  var BoundElementOrDirectiveProperty = (function() {
    function BoundElementOrDirectiveProperty(name, expression, isLiteral, sourceSpan) {
      this.name = name;
      this.expression = expression;
      this.isLiteral = isLiteral;
      this.sourceSpan = sourceSpan;
    }
    return BoundElementOrDirectiveProperty;
  }());
  var ElementOrDirectiveRef = (function() {
    function ElementOrDirectiveRef(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    return ElementOrDirectiveRef;
  }());
  function splitClasses(classAttrValue) {
    return StringWrapper.split(classAttrValue.trim(), /\s+/g);
  }
  var ElementContext = (function() {
    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
      this.isTemplateElement = isTemplateElement;
      this._ngContentIndexMatcher = _ngContentIndexMatcher;
      this._wildcardNgContentIndex = _wildcardNgContentIndex;
      this.providerContext = providerContext;
    }
    ElementContext.create = function(isTemplateElement, directives, providerContext) {
      var matcher = new SelectorMatcher();
      var wildcardNgContentIndex = null;
      var component = directives.find(function(directive) {
        return directive.directive.isComponent;
      });
      if (isPresent(component)) {
        var ngContentSelectors = component.directive.template.ngContentSelectors;
        for (var i = 0; i < ngContentSelectors.length; i++) {
          var selector = ngContentSelectors[i];
          if (StringWrapper.equals(selector, '*')) {
            wildcardNgContentIndex = i;
          } else {
            matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
          }
        }
      }
      return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
    };
    ElementContext.prototype.findNgContentIndex = function(selector) {
      var ngContentIndices = [];
      this._ngContentIndexMatcher.match(selector, function(selector, ngContentIndex) {
        ngContentIndices.push(ngContentIndex);
      });
      ListWrapper.sort(ngContentIndices);
      if (isPresent(this._wildcardNgContentIndex)) {
        ngContentIndices.push(this._wildcardNgContentIndex);
      }
      return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
    };
    return ElementContext;
  }());
  function createElementCssSelector(elementName, matchableAttrs) {
    var cssSelector = new CssSelector();
    var elNameNoNs = splitNsName(elementName)[1];
    cssSelector.setElement(elNameNoNs);
    for (var i = 0; i < matchableAttrs.length; i++) {
      var attrName = matchableAttrs[i][0];
      var attrNameNoNs = splitNsName(attrName)[1];
      var attrValue = matchableAttrs[i][1];
      cssSelector.addAttribute(attrNameNoNs, attrValue);
      if (attrName.toLowerCase() == CLASS_ATTR) {
        var classes = splitClasses(attrValue);
        classes.forEach(function(className) {
          return cssSelector.addClassName(className);
        });
      }
    }
    return cssSelector;
  }
  var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
  var NON_BINDABLE_VISITOR = new NonBindableVisitor();
  var PipeCollector = (function(_super) {
    __extends(PipeCollector, _super);
    function PipeCollector() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
      }
      _super.apply(this, args);
      this.pipes = new Set();
    }
    PipeCollector.prototype.visitPipe = function(ast, context) {
      this.pipes.add(ast.name);
      ast.exp.visit(this);
      this.visitAll(ast.args, context);
      return null;
    };
    return PipeCollector;
  }(RecursiveAstVisitor));
  function removeDuplicates(items) {
    var res = [];
    items.forEach(function(item) {
      var hasMatch = res.filter(function(r) {
        return r.type.name == item.type.name && r.type.moduleUrl == item.type.moduleUrl && r.type.runtime == item.type.runtime;
      }).length > 0;
      if (!hasMatch) {
        res.push(item);
      }
    });
    return res;
  }
  var CompilerConfig = (function() {
    function CompilerConfig(genDebugInfo, logBindingUpdate, useJit, renderTypes) {
      if (renderTypes === void 0) {
        renderTypes = null;
      }
      this.genDebugInfo = genDebugInfo;
      this.logBindingUpdate = logBindingUpdate;
      this.useJit = useJit;
      if (isBlank(renderTypes)) {
        renderTypes = new DefaultRenderTypes();
      }
      this.renderTypes = renderTypes;
    }
    return CompilerConfig;
  }());
  var RenderTypes = (function() {
    function RenderTypes() {}
    Object.defineProperty(RenderTypes.prototype, "renderer", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderText", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderElement", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderComment", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderNode", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderEvent", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return RenderTypes;
  }());
  var DefaultRenderTypes = (function() {
    function DefaultRenderTypes() {
      this.renderer = Identifiers.Renderer;
      this.renderText = null;
      this.renderElement = null;
      this.renderComment = null;
      this.renderNode = null;
      this.renderEvent = null;
    }
    return DefaultRenderTypes;
  }());
  var TypeModifier;
  (function(TypeModifier) {
    TypeModifier[TypeModifier["Const"] = 0] = "Const";
  })(TypeModifier || (TypeModifier = {}));
  var Type$1 = (function() {
    function Type$1(modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      this.modifiers = modifiers;
      if (isBlank(modifiers)) {
        this.modifiers = [];
      }
    }
    Type$1.prototype.hasModifier = function(modifier) {
      return this.modifiers.indexOf(modifier) !== -1;
    };
    return Type$1;
  }());
  var BuiltinTypeName;
  (function(BuiltinTypeName) {
    BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
    BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
    BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
    BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
    BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
    BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
  })(BuiltinTypeName || (BuiltinTypeName = {}));
  var BuiltinType = (function(_super) {
    __extends(BuiltinType, _super);
    function BuiltinType(name, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.name = name;
    }
    BuiltinType.prototype.visitType = function(visitor, context) {
      return visitor.visitBuiltintType(this, context);
    };
    return BuiltinType;
  }(Type$1));
  var ExternalType = (function(_super) {
    __extends(ExternalType, _super);
    function ExternalType(value, typeParams, modifiers) {
      if (typeParams === void 0) {
        typeParams = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.value = value;
      this.typeParams = typeParams;
    }
    ExternalType.prototype.visitType = function(visitor, context) {
      return visitor.visitExternalType(this, context);
    };
    return ExternalType;
  }(Type$1));
  var ArrayType = (function(_super) {
    __extends(ArrayType, _super);
    function ArrayType(of, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.of = of;
    }
    ArrayType.prototype.visitType = function(visitor, context) {
      return visitor.visitArrayType(this, context);
    };
    return ArrayType;
  }(Type$1));
  var MapType = (function(_super) {
    __extends(MapType, _super);
    function MapType(valueType, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.valueType = valueType;
    }
    MapType.prototype.visitType = function(visitor, context) {
      return visitor.visitMapType(this, context);
    };
    return MapType;
  }(Type$1));
  var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
  var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
  var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
  var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
  var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
  var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
  var BinaryOperator;
  (function(BinaryOperator) {
    BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
    BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
    BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
    BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
    BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
    BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
    BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
    BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
    BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
    BinaryOperator[BinaryOperator["And"] = 9] = "And";
    BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
    BinaryOperator[BinaryOperator["Lower"] = 11] = "Lower";
    BinaryOperator[BinaryOperator["LowerEquals"] = 12] = "LowerEquals";
    BinaryOperator[BinaryOperator["Bigger"] = 13] = "Bigger";
    BinaryOperator[BinaryOperator["BiggerEquals"] = 14] = "BiggerEquals";
  })(BinaryOperator || (BinaryOperator = {}));
  var Expression = (function() {
    function Expression(type) {
      this.type = type;
    }
    Expression.prototype.prop = function(name) {
      return new ReadPropExpr(this, name);
    };
    Expression.prototype.key = function(index, type) {
      if (type === void 0) {
        type = null;
      }
      return new ReadKeyExpr(this, index, type);
    };
    Expression.prototype.callMethod = function(name, params) {
      return new InvokeMethodExpr(this, name, params);
    };
    Expression.prototype.callFn = function(params) {
      return new InvokeFunctionExpr(this, params);
    };
    Expression.prototype.instantiate = function(params, type) {
      if (type === void 0) {
        type = null;
      }
      return new InstantiateExpr(this, params, type);
    };
    Expression.prototype.conditional = function(trueCase, falseCase) {
      if (falseCase === void 0) {
        falseCase = null;
      }
      return new ConditionalExpr(this, trueCase, falseCase);
    };
    Expression.prototype.equals = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs);
    };
    Expression.prototype.notEquals = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs);
    };
    Expression.prototype.identical = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs);
    };
    Expression.prototype.notIdentical = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs);
    };
    Expression.prototype.minus = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs);
    };
    Expression.prototype.plus = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs);
    };
    Expression.prototype.divide = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs);
    };
    Expression.prototype.multiply = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs);
    };
    Expression.prototype.modulo = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs);
    };
    Expression.prototype.and = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.And, this, rhs);
    };
    Expression.prototype.or = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs);
    };
    Expression.prototype.lower = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs);
    };
    Expression.prototype.lowerEquals = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs);
    };
    Expression.prototype.bigger = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs);
    };
    Expression.prototype.biggerEquals = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs);
    };
    Expression.prototype.isBlank = function() {
      return this.equals(NULL_EXPR);
    };
    Expression.prototype.cast = function(type) {
      return new CastExpr(this, type);
    };
    Expression.prototype.toStmt = function() {
      return new ExpressionStatement(this);
    };
    return Expression;
  }());
  var BuiltinVar;
  (function(BuiltinVar) {
    BuiltinVar[BuiltinVar["This"] = 0] = "This";
    BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
    BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
    BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
  })(BuiltinVar || (BuiltinVar = {}));
  var ReadVarExpr = (function(_super) {
    __extends(ReadVarExpr, _super);
    function ReadVarExpr(name, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      if (isString(name)) {
        this.name = name;
        this.builtin = null;
      } else {
        this.name = null;
        this.builtin = name;
      }
    }
    ReadVarExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitReadVarExpr(this, context);
    };
    ReadVarExpr.prototype.set = function(value) {
      return new WriteVarExpr(this.name, value);
    };
    return ReadVarExpr;
  }(Expression));
  var WriteVarExpr = (function(_super) {
    __extends(WriteVarExpr, _super);
    function WriteVarExpr(name, value, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, isPresent(type) ? type : value.type);
      this.name = name;
      this.value = value;
    }
    WriteVarExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitWriteVarExpr(this, context);
    };
    WriteVarExpr.prototype.toDeclStmt = function(type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      return new DeclareVarStmt(this.name, this.value, type, modifiers);
    };
    return WriteVarExpr;
  }(Expression));
  var WriteKeyExpr = (function(_super) {
    __extends(WriteKeyExpr, _super);
    function WriteKeyExpr(receiver, index, value, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, isPresent(type) ? type : value.type);
      this.receiver = receiver;
      this.index = index;
      this.value = value;
    }
    WriteKeyExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitWriteKeyExpr(this, context);
    };
    return WriteKeyExpr;
  }(Expression));
  var WritePropExpr = (function(_super) {
    __extends(WritePropExpr, _super);
    function WritePropExpr(receiver, name, value, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, isPresent(type) ? type : value.type);
      this.receiver = receiver;
      this.name = name;
      this.value = value;
    }
    WritePropExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitWritePropExpr(this, context);
    };
    return WritePropExpr;
  }(Expression));
  var BuiltinMethod;
  (function(BuiltinMethod) {
    BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
    BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
    BuiltinMethod[BuiltinMethod["bind"] = 2] = "bind";
  })(BuiltinMethod || (BuiltinMethod = {}));
  var InvokeMethodExpr = (function(_super) {
    __extends(InvokeMethodExpr, _super);
    function InvokeMethodExpr(receiver, method, args, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.receiver = receiver;
      this.args = args;
      if (isString(method)) {
        this.name = method;
        this.builtin = null;
      } else {
        this.name = null;
        this.builtin = method;
      }
    }
    InvokeMethodExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitInvokeMethodExpr(this, context);
    };
    return InvokeMethodExpr;
  }(Expression));
  var InvokeFunctionExpr = (function(_super) {
    __extends(InvokeFunctionExpr, _super);
    function InvokeFunctionExpr(fn, args, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.fn = fn;
      this.args = args;
    }
    InvokeFunctionExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitInvokeFunctionExpr(this, context);
    };
    return InvokeFunctionExpr;
  }(Expression));
  var InstantiateExpr = (function(_super) {
    __extends(InstantiateExpr, _super);
    function InstantiateExpr(classExpr, args, type) {
      _super.call(this, type);
      this.classExpr = classExpr;
      this.args = args;
    }
    InstantiateExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitInstantiateExpr(this, context);
    };
    return InstantiateExpr;
  }(Expression));
  var LiteralExpr = (function(_super) {
    __extends(LiteralExpr, _super);
    function LiteralExpr(value, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.value = value;
    }
    LiteralExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitLiteralExpr(this, context);
    };
    return LiteralExpr;
  }(Expression));
  var ExternalExpr = (function(_super) {
    __extends(ExternalExpr, _super);
    function ExternalExpr(value, type, typeParams) {
      if (type === void 0) {
        type = null;
      }
      if (typeParams === void 0) {
        typeParams = null;
      }
      _super.call(this, type);
      this.value = value;
      this.typeParams = typeParams;
    }
    ExternalExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitExternalExpr(this, context);
    };
    return ExternalExpr;
  }(Expression));
  var ConditionalExpr = (function(_super) {
    __extends(ConditionalExpr, _super);
    function ConditionalExpr(condition, trueCase, falseCase, type) {
      if (falseCase === void 0) {
        falseCase = null;
      }
      if (type === void 0) {
        type = null;
      }
      _super.call(this, isPresent(type) ? type : trueCase.type);
      this.condition = condition;
      this.falseCase = falseCase;
      this.trueCase = trueCase;
    }
    ConditionalExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitConditionalExpr(this, context);
    };
    return ConditionalExpr;
  }(Expression));
  var NotExpr = (function(_super) {
    __extends(NotExpr, _super);
    function NotExpr(condition) {
      _super.call(this, BOOL_TYPE);
      this.condition = condition;
    }
    NotExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitNotExpr(this, context);
    };
    return NotExpr;
  }(Expression));
  var CastExpr = (function(_super) {
    __extends(CastExpr, _super);
    function CastExpr(value, type) {
      _super.call(this, type);
      this.value = value;
    }
    CastExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitCastExpr(this, context);
    };
    return CastExpr;
  }(Expression));
  var FnParam = (function() {
    function FnParam(name, type) {
      if (type === void 0) {
        type = null;
      }
      this.name = name;
      this.type = type;
    }
    return FnParam;
  }());
  var FunctionExpr = (function(_super) {
    __extends(FunctionExpr, _super);
    function FunctionExpr(params, statements, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.params = params;
      this.statements = statements;
    }
    FunctionExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitFunctionExpr(this, context);
    };
    FunctionExpr.prototype.toDeclStmt = function(name, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers);
    };
    return FunctionExpr;
  }(Expression));
  var BinaryOperatorExpr = (function(_super) {
    __extends(BinaryOperatorExpr, _super);
    function BinaryOperatorExpr(operator, lhs, rhs, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, isPresent(type) ? type : lhs.type);
      this.operator = operator;
      this.rhs = rhs;
      this.lhs = lhs;
    }
    BinaryOperatorExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitBinaryOperatorExpr(this, context);
    };
    return BinaryOperatorExpr;
  }(Expression));
  var ReadPropExpr = (function(_super) {
    __extends(ReadPropExpr, _super);
    function ReadPropExpr(receiver, name, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.receiver = receiver;
      this.name = name;
    }
    ReadPropExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitReadPropExpr(this, context);
    };
    ReadPropExpr.prototype.set = function(value) {
      return new WritePropExpr(this.receiver, this.name, value);
    };
    return ReadPropExpr;
  }(Expression));
  var ReadKeyExpr = (function(_super) {
    __extends(ReadKeyExpr, _super);
    function ReadKeyExpr(receiver, index, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.receiver = receiver;
      this.index = index;
    }
    ReadKeyExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitReadKeyExpr(this, context);
    };
    ReadKeyExpr.prototype.set = function(value) {
      return new WriteKeyExpr(this.receiver, this.index, value);
    };
    return ReadKeyExpr;
  }(Expression));
  var LiteralArrayExpr = (function(_super) {
    __extends(LiteralArrayExpr, _super);
    function LiteralArrayExpr(entries, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.entries = entries;
    }
    LiteralArrayExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitLiteralArrayExpr(this, context);
    };
    return LiteralArrayExpr;
  }(Expression));
  var LiteralMapExpr = (function(_super) {
    __extends(LiteralMapExpr, _super);
    function LiteralMapExpr(entries, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.entries = entries;
      this.valueType = null;
      if (isPresent(type)) {
        this.valueType = type.valueType;
      }
    }
    LiteralMapExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitLiteralMapExpr(this, context);
    };
    return LiteralMapExpr;
  }(Expression));
  var THIS_EXPR = new ReadVarExpr(BuiltinVar.This);
  var SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);
  var CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);
  var CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);
  var NULL_EXPR = new LiteralExpr(null, null);
  var StmtModifier;
  (function(StmtModifier) {
    StmtModifier[StmtModifier["Final"] = 0] = "Final";
    StmtModifier[StmtModifier["Private"] = 1] = "Private";
  })(StmtModifier || (StmtModifier = {}));
  var Statement = (function() {
    function Statement(modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      this.modifiers = modifiers;
      if (isBlank(modifiers)) {
        this.modifiers = [];
      }
    }
    Statement.prototype.hasModifier = function(modifier) {
      return this.modifiers.indexOf(modifier) !== -1;
    };
    return Statement;
  }());
  var DeclareVarStmt = (function(_super) {
    __extends(DeclareVarStmt, _super);
    function DeclareVarStmt(name, value, type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.name = name;
      this.value = value;
      this.type = isPresent(type) ? type : value.type;
    }
    DeclareVarStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitDeclareVarStmt(this, context);
    };
    return DeclareVarStmt;
  }(Statement));
  var DeclareFunctionStmt = (function(_super) {
    __extends(DeclareFunctionStmt, _super);
    function DeclareFunctionStmt(name, params, statements, type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.name = name;
      this.params = params;
      this.statements = statements;
      this.type = type;
    }
    DeclareFunctionStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitDeclareFunctionStmt(this, context);
    };
    return DeclareFunctionStmt;
  }(Statement));
  var ExpressionStatement = (function(_super) {
    __extends(ExpressionStatement, _super);
    function ExpressionStatement(expr) {
      _super.call(this);
      this.expr = expr;
    }
    ExpressionStatement.prototype.visitStatement = function(visitor, context) {
      return visitor.visitExpressionStmt(this, context);
    };
    return ExpressionStatement;
  }(Statement));
  var ReturnStatement = (function(_super) {
    __extends(ReturnStatement, _super);
    function ReturnStatement(value) {
      _super.call(this);
      this.value = value;
    }
    ReturnStatement.prototype.visitStatement = function(visitor, context) {
      return visitor.visitReturnStmt(this, context);
    };
    return ReturnStatement;
  }(Statement));
  var AbstractClassPart = (function() {
    function AbstractClassPart(type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      this.type = type;
      this.modifiers = modifiers;
      if (isBlank(modifiers)) {
        this.modifiers = [];
      }
    }
    AbstractClassPart.prototype.hasModifier = function(modifier) {
      return this.modifiers.indexOf(modifier) !== -1;
    };
    return AbstractClassPart;
  }());
  var ClassField = (function(_super) {
    __extends(ClassField, _super);
    function ClassField(name, type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, type, modifiers);
      this.name = name;
    }
    return ClassField;
  }(AbstractClassPart));
  var ClassMethod = (function(_super) {
    __extends(ClassMethod, _super);
    function ClassMethod(name, params, body, type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, type, modifiers);
      this.name = name;
      this.params = params;
      this.body = body;
    }
    return ClassMethod;
  }(AbstractClassPart));
  var ClassGetter = (function(_super) {
    __extends(ClassGetter, _super);
    function ClassGetter(name, body, type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, type, modifiers);
      this.name = name;
      this.body = body;
    }
    return ClassGetter;
  }(AbstractClassPart));
  var ClassStmt = (function(_super) {
    __extends(ClassStmt, _super);
    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.name = name;
      this.parent = parent;
      this.fields = fields;
      this.getters = getters;
      this.constructorMethod = constructorMethod;
      this.methods = methods;
    }
    ClassStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitDeclareClassStmt(this, context);
    };
    return ClassStmt;
  }(Statement));
  var IfStmt = (function(_super) {
    __extends(IfStmt, _super);
    function IfStmt(condition, trueCase, falseCase) {
      if (falseCase === void 0) {
        falseCase = [];
      }
      _super.call(this);
      this.condition = condition;
      this.trueCase = trueCase;
      this.falseCase = falseCase;
    }
    IfStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitIfStmt(this, context);
    };
    return IfStmt;
  }(Statement));
  var TryCatchStmt = (function(_super) {
    __extends(TryCatchStmt, _super);
    function TryCatchStmt(bodyStmts, catchStmts) {
      _super.call(this);
      this.bodyStmts = bodyStmts;
      this.catchStmts = catchStmts;
    }
    TryCatchStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitTryCatchStmt(this, context);
    };
    return TryCatchStmt;
  }(Statement));
  var ThrowStmt = (function(_super) {
    __extends(ThrowStmt, _super);
    function ThrowStmt(error) {
      _super.call(this);
      this.error = error;
    }
    ThrowStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitThrowStmt(this, context);
    };
    return ThrowStmt;
  }(Statement));
  var ExpressionTransformer = (function() {
    function ExpressionTransformer() {}
    ExpressionTransformer.prototype.visitReadVarExpr = function(ast, context) {
      return ast;
    };
    ExpressionTransformer.prototype.visitWriteVarExpr = function(expr, context) {
      return new WriteVarExpr(expr.name, expr.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitWriteKeyExpr = function(expr, context) {
      return new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitWritePropExpr = function(expr, context) {
      return new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitInvokeMethodExpr = function(ast, context) {
      var method = isPresent(ast.builtin) ? ast.builtin : ast.name;
      return new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type);
    };
    ExpressionTransformer.prototype.visitInvokeFunctionExpr = function(ast, context) {
      return new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
    };
    ExpressionTransformer.prototype.visitInstantiateExpr = function(ast, context) {
      return new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
    };
    ExpressionTransformer.prototype.visitLiteralExpr = function(ast, context) {
      return ast;
    };
    ExpressionTransformer.prototype.visitExternalExpr = function(ast, context) {
      return ast;
    };
    ExpressionTransformer.prototype.visitConditionalExpr = function(ast, context) {
      return new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitNotExpr = function(ast, context) {
      return new NotExpr(ast.condition.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitCastExpr = function(ast, context) {
      return new CastExpr(ast.value.visitExpression(this, context), context);
    };
    ExpressionTransformer.prototype.visitFunctionExpr = function(ast, context) {
      return ast;
    };
    ExpressionTransformer.prototype.visitBinaryOperatorExpr = function(ast, context) {
      return new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type);
    };
    ExpressionTransformer.prototype.visitReadPropExpr = function(ast, context) {
      return new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type);
    };
    ExpressionTransformer.prototype.visitReadKeyExpr = function(ast, context) {
      return new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type);
    };
    ExpressionTransformer.prototype.visitLiteralArrayExpr = function(ast, context) {
      return new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context));
    };
    ExpressionTransformer.prototype.visitLiteralMapExpr = function(ast, context) {
      var _this = this;
      return new LiteralMapExpr(ast.entries.map(function(entry) {
        return [entry[0], entry[1].visitExpression(_this, context)];
      }));
    };
    ExpressionTransformer.prototype.visitAllExpressions = function(exprs, context) {
      var _this = this;
      return exprs.map(function(expr) {
        return expr.visitExpression(_this, context);
      });
    };
    ExpressionTransformer.prototype.visitDeclareVarStmt = function(stmt, context) {
      return new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers);
    };
    ExpressionTransformer.prototype.visitDeclareFunctionStmt = function(stmt, context) {
      return stmt;
    };
    ExpressionTransformer.prototype.visitExpressionStmt = function(stmt, context) {
      return new ExpressionStatement(stmt.expr.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitReturnStmt = function(stmt, context) {
      return new ReturnStatement(stmt.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitDeclareClassStmt = function(stmt, context) {
      return stmt;
    };
    ExpressionTransformer.prototype.visitIfStmt = function(stmt, context) {
      return new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context));
    };
    ExpressionTransformer.prototype.visitTryCatchStmt = function(stmt, context) {
      return new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context));
    };
    ExpressionTransformer.prototype.visitThrowStmt = function(stmt, context) {
      return new ThrowStmt(stmt.error.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitCommentStmt = function(stmt, context) {
      return stmt;
    };
    ExpressionTransformer.prototype.visitAllStatements = function(stmts, context) {
      var _this = this;
      return stmts.map(function(stmt) {
        return stmt.visitStatement(_this, context);
      });
    };
    return ExpressionTransformer;
  }());
  var RecursiveExpressionVisitor = (function() {
    function RecursiveExpressionVisitor() {}
    RecursiveExpressionVisitor.prototype.visitReadVarExpr = function(ast, context) {
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitWriteVarExpr = function(expr, context) {
      expr.value.visitExpression(this, context);
      return expr;
    };
    RecursiveExpressionVisitor.prototype.visitWriteKeyExpr = function(expr, context) {
      expr.receiver.visitExpression(this, context);
      expr.index.visitExpression(this, context);
      expr.value.visitExpression(this, context);
      return expr;
    };
    RecursiveExpressionVisitor.prototype.visitWritePropExpr = function(expr, context) {
      expr.receiver.visitExpression(this, context);
      expr.value.visitExpression(this, context);
      return expr;
    };
    RecursiveExpressionVisitor.prototype.visitInvokeMethodExpr = function(ast, context) {
      ast.receiver.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitInvokeFunctionExpr = function(ast, context) {
      ast.fn.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitInstantiateExpr = function(ast, context) {
      ast.classExpr.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitLiteralExpr = function(ast, context) {
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitExternalExpr = function(ast, context) {
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitConditionalExpr = function(ast, context) {
      ast.condition.visitExpression(this, context);
      ast.trueCase.visitExpression(this, context);
      ast.falseCase.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitNotExpr = function(ast, context) {
      ast.condition.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitCastExpr = function(ast, context) {
      ast.value.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitFunctionExpr = function(ast, context) {
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitBinaryOperatorExpr = function(ast, context) {
      ast.lhs.visitExpression(this, context);
      ast.rhs.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitReadPropExpr = function(ast, context) {
      ast.receiver.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitReadKeyExpr = function(ast, context) {
      ast.receiver.visitExpression(this, context);
      ast.index.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitLiteralArrayExpr = function(ast, context) {
      this.visitAllExpressions(ast.entries, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitLiteralMapExpr = function(ast, context) {
      var _this = this;
      ast.entries.forEach(function(entry) {
        return entry[1].visitExpression(_this, context);
      });
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitAllExpressions = function(exprs, context) {
      var _this = this;
      exprs.forEach(function(expr) {
        return expr.visitExpression(_this, context);
      });
    };
    RecursiveExpressionVisitor.prototype.visitDeclareVarStmt = function(stmt, context) {
      stmt.value.visitExpression(this, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitDeclareFunctionStmt = function(stmt, context) {
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitExpressionStmt = function(stmt, context) {
      stmt.expr.visitExpression(this, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitReturnStmt = function(stmt, context) {
      stmt.value.visitExpression(this, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitDeclareClassStmt = function(stmt, context) {
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitIfStmt = function(stmt, context) {
      stmt.condition.visitExpression(this, context);
      this.visitAllStatements(stmt.trueCase, context);
      this.visitAllStatements(stmt.falseCase, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitTryCatchStmt = function(stmt, context) {
      this.visitAllStatements(stmt.bodyStmts, context);
      this.visitAllStatements(stmt.catchStmts, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitThrowStmt = function(stmt, context) {
      stmt.error.visitExpression(this, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitCommentStmt = function(stmt, context) {
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitAllStatements = function(stmts, context) {
      var _this = this;
      stmts.forEach(function(stmt) {
        return stmt.visitStatement(_this, context);
      });
    };
    return RecursiveExpressionVisitor;
  }());
  function replaceVarInExpression(varName, newValue, expression) {
    var transformer = new _ReplaceVariableTransformer(varName, newValue);
    return expression.visitExpression(transformer, null);
  }
  var _ReplaceVariableTransformer = (function(_super) {
    __extends(_ReplaceVariableTransformer, _super);
    function _ReplaceVariableTransformer(_varName, _newValue) {
      _super.call(this);
      this._varName = _varName;
      this._newValue = _newValue;
    }
    _ReplaceVariableTransformer.prototype.visitReadVarExpr = function(ast, context) {
      return ast.name == this._varName ? this._newValue : ast;
    };
    return _ReplaceVariableTransformer;
  }(ExpressionTransformer));
  function findReadVarNames(stmts) {
    var finder = new _VariableFinder();
    finder.visitAllStatements(stmts, null);
    return finder.varNames;
  }
  var _VariableFinder = (function(_super) {
    __extends(_VariableFinder, _super);
    function _VariableFinder() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
      }
      _super.apply(this, args);
      this.varNames = new Set();
    }
    _VariableFinder.prototype.visitReadVarExpr = function(ast, context) {
      this.varNames.add(ast.name);
      return null;
    };
    return _VariableFinder;
  }(RecursiveExpressionVisitor));
  function variable(name, type) {
    if (type === void 0) {
      type = null;
    }
    return new ReadVarExpr(name, type);
  }
  function importExpr(id, typeParams) {
    if (typeParams === void 0) {
      typeParams = null;
    }
    return new ExternalExpr(id, null, typeParams);
  }
  function importType(id, typeParams, typeModifiers) {
    if (typeParams === void 0) {
      typeParams = null;
    }
    if (typeModifiers === void 0) {
      typeModifiers = null;
    }
    return isPresent(id) ? new ExternalType(id, typeParams, typeModifiers) : null;
  }
  function literal(value, type) {
    if (type === void 0) {
      type = null;
    }
    return new LiteralExpr(value, type);
  }
  function literalArr(values, type) {
    if (type === void 0) {
      type = null;
    }
    return new LiteralArrayExpr(values, type);
  }
  function literalMap(values, type) {
    if (type === void 0) {
      type = null;
    }
    return new LiteralMapExpr(values, type);
  }
  function not(expr) {
    return new NotExpr(expr);
  }
  function fn(params, body, type) {
    if (type === void 0) {
      type = null;
    }
    return new FunctionExpr(params, body, type);
  }
  var _COMPONENT_FACTORY_IDENTIFIER = new CompileIdentifierMetadata({
    name: 'ComponentFactory',
    runtime: _angular_core.ComponentFactory,
    moduleUrl: assetUrl('core', 'linker/component_factory')
  });
  var SourceModule = (function() {
    function SourceModule(moduleUrl, source) {
      this.moduleUrl = moduleUrl;
      this.source = source;
    }
    return SourceModule;
  }());
  var StyleSheetSourceWithImports = (function() {
    function StyleSheetSourceWithImports(source, importedUrls) {
      this.source = source;
      this.importedUrls = importedUrls;
    }
    return StyleSheetSourceWithImports;
  }());
  var NormalizedComponentWithViewDirectives = (function() {
    function NormalizedComponentWithViewDirectives(component, directives, pipes) {
      this.component = component;
      this.directives = directives;
      this.pipes = pipes;
    }
    return NormalizedComponentWithViewDirectives;
  }());
  var OfflineCompiler = (function() {
    function OfflineCompiler(_directiveNormalizer, _templateParser, _styleCompiler, _viewCompiler, _outputEmitter, _xhr) {
      this._directiveNormalizer = _directiveNormalizer;
      this._templateParser = _templateParser;
      this._styleCompiler = _styleCompiler;
      this._viewCompiler = _viewCompiler;
      this._outputEmitter = _outputEmitter;
      this._xhr = _xhr;
    }
    OfflineCompiler.prototype.normalizeDirectiveMetadata = function(directive) {
      return this._directiveNormalizer.normalizeDirective(directive);
    };
    OfflineCompiler.prototype.compileTemplates = function(components) {
      var _this = this;
      if (components.length === 0) {
        throw new BaseException$1('No components given');
      }
      var statements = [];
      var exportedVars = [];
      var moduleUrl = _templateModuleUrl(components[0].component);
      components.forEach(function(componentWithDirs) {
        var compMeta = componentWithDirs.component;
        _assertComponent(compMeta);
        var compViewFactoryVar = _this._compileComponent(compMeta, componentWithDirs.directives, componentWithDirs.pipes, statements);
        exportedVars.push(compViewFactoryVar);
        var hostMeta = createHostComponentMeta(compMeta.type, compMeta.selector);
        var hostViewFactoryVar = _this._compileComponent(hostMeta, [compMeta], [], statements);
        var compFactoryVar = compMeta.type.name + "NgFactory";
        statements.push(variable(compFactoryVar).set(importExpr(_COMPONENT_FACTORY_IDENTIFIER, [importType(compMeta.type)]).instantiate([literal(compMeta.selector), variable(hostViewFactoryVar), importExpr(compMeta.type)], importType(_COMPONENT_FACTORY_IDENTIFIER, [importType(compMeta.type)], [TypeModifier.Const]))).toDeclStmt(null, [StmtModifier.Final]));
        exportedVars.push(compFactoryVar);
      });
      return this._codegenSourceModule(moduleUrl, statements, exportedVars);
    };
    OfflineCompiler.prototype.loadAndCompileStylesheet = function(stylesheetUrl, shim, suffix) {
      var _this = this;
      return this._xhr.get(stylesheetUrl).then(function(cssText) {
        var compileResult = _this._styleCompiler.compileStylesheet(stylesheetUrl, cssText, shim);
        var importedUrls = [];
        compileResult.dependencies.forEach(function(dep) {
          importedUrls.push(dep.moduleUrl);
          dep.valuePlaceholder.moduleUrl = _stylesModuleUrl(dep.moduleUrl, dep.isShimmed, suffix);
        });
        return new StyleSheetSourceWithImports(_this._codgenStyles(stylesheetUrl, shim, suffix, compileResult), importedUrls);
      });
    };
    OfflineCompiler.prototype._compileComponent = function(compMeta, directives, pipes, targetStatements) {
      var styleResult = this._styleCompiler.compileComponent(compMeta);
      var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, compMeta.type.name);
      var viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, variable(styleResult.stylesVar), pipes);
      ListWrapper.addAll(targetStatements, _resolveStyleStatements(compMeta.type.moduleUrl, styleResult));
      ListWrapper.addAll(targetStatements, _resolveViewStatements(viewResult));
      return viewResult.viewFactoryVar;
    };
    OfflineCompiler.prototype._codgenStyles = function(inputUrl, shim, suffix, stylesCompileResult) {
      return this._codegenSourceModule(_stylesModuleUrl(inputUrl, shim, suffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);
    };
    OfflineCompiler.prototype._codegenSourceModule = function(moduleUrl, statements, exportedVars) {
      return new SourceModule(moduleUrl, this._outputEmitter.emitStatements(moduleUrl, statements, exportedVars));
    };
    return OfflineCompiler;
  }());
  function _resolveViewStatements(compileResult) {
    compileResult.dependencies.forEach(function(dep) {
      dep.factoryPlaceholder.moduleUrl = _templateModuleUrl(dep.comp);
    });
    return compileResult.statements;
  }
  function _resolveStyleStatements(containingModuleUrl, compileResult) {
    var containingSuffix = _splitSuffix(containingModuleUrl)[1];
    compileResult.dependencies.forEach(function(dep) {
      dep.valuePlaceholder.moduleUrl = _stylesModuleUrl(dep.moduleUrl, dep.isShimmed, containingSuffix);
    });
    return compileResult.statements;
  }
  function _templateModuleUrl(comp) {
    var urlWithSuffix = _splitSuffix(comp.type.moduleUrl);
    return urlWithSuffix[0] + ".ngfactory" + urlWithSuffix[1];
  }
  function _stylesModuleUrl(stylesheetUrl, shim, suffix) {
    return shim ? stylesheetUrl + ".shim" + suffix : "" + stylesheetUrl + suffix;
  }
  function _assertComponent(meta) {
    if (!meta.isComponent) {
      throw new BaseException$1("Could not compile '" + meta.type.name + "' because it is not a component.");
    }
  }
  function _splitSuffix(path) {
    var lastDot = path.lastIndexOf('.');
    if (lastDot !== -1) {
      return [path.substring(0, lastDot), path.substring(lastDot)];
    } else {
      return [path, ''];
    }
  }
  var PromiseCompleter = (function() {
    function PromiseCompleter() {
      var _this = this;
      this.promise = new Promise(function(res, rej) {
        _this.resolve = res;
        _this.reject = rej;
      });
    }
    return PromiseCompleter;
  }());
  var PromiseWrapper = (function() {
    function PromiseWrapper() {}
    PromiseWrapper.resolve = function(obj) {
      return Promise.resolve(obj);
    };
    PromiseWrapper.reject = function(obj, _) {
      return Promise.reject(obj);
    };
    PromiseWrapper.catchError = function(promise, onError) {
      return promise.catch(onError);
    };
    PromiseWrapper.all = function(promises) {
      if (promises.length == 0)
        return Promise.resolve([]);
      return Promise.all(promises);
    };
    PromiseWrapper.then = function(promise, success, rejection) {
      return promise.then(success, rejection);
    };
    PromiseWrapper.wrap = function(computation) {
      return new Promise(function(res, rej) {
        try {
          res(computation());
        } catch (e) {
          rej(e);
        }
      });
    };
    PromiseWrapper.scheduleMicrotask = function(computation) {
      PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function(_) {});
    };
    PromiseWrapper.isPromise = function(obj) {
      return obj instanceof Promise;
    };
    PromiseWrapper.completer = function() {
      return new PromiseCompleter();
    };
    return PromiseWrapper;
  }());
  var ObservableWrapper = (function() {
    function ObservableWrapper() {}
    ObservableWrapper.subscribe = function(emitter, onNext, onError, onComplete) {
      if (onComplete === void 0) {
        onComplete = function() {};
      }
      onError = (typeof onError === "function") && onError || noop;
      onComplete = (typeof onComplete === "function") && onComplete || noop;
      return emitter.subscribe({
        next: onNext,
        error: onError,
        complete: onComplete
      });
    };
    ObservableWrapper.isObservable = function(obs) {
      return !!obs.subscribe;
    };
    ObservableWrapper.hasSubscribers = function(obs) {
      return obs.observers.length > 0;
    };
    ObservableWrapper.dispose = function(subscription) {
      subscription.unsubscribe();
    };
    ObservableWrapper.callNext = function(emitter, value) {
      emitter.next(value);
    };
    ObservableWrapper.callEmit = function(emitter, value) {
      emitter.emit(value);
    };
    ObservableWrapper.callError = function(emitter, error) {
      emitter.error(error);
    };
    ObservableWrapper.callComplete = function(emitter) {
      emitter.complete();
    };
    ObservableWrapper.fromPromise = function(promise) {
      return rxjs_observable_PromiseObservable.PromiseObservable.create(promise);
    };
    ObservableWrapper.toPromise = function(obj) {
      return rxjs_operator_toPromise.toPromise.call(obj);
    };
    return ObservableWrapper;
  }());
  var ShadowCss = (function() {
    function ShadowCss() {
      this.strictStyling = true;
    }
    ShadowCss.prototype.shimCssText = function(cssText, selector, hostSelector) {
      if (hostSelector === void 0) {
        hostSelector = '';
      }
      cssText = stripComments(cssText);
      cssText = this._insertDirectives(cssText);
      return this._scopeCssText(cssText, selector, hostSelector);
    };
    ShadowCss.prototype._insertDirectives = function(cssText) {
      cssText = this._insertPolyfillDirectivesInCssText(cssText);
      return this._insertPolyfillRulesInCssText(cssText);
    };
    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function(cssText) {
      return StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function(m) {
        return m[1] + '{';
      });
    };
    ShadowCss.prototype._insertPolyfillRulesInCssText = function(cssText) {
      return StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function(m) {
        var rule = m[0];
        rule = StringWrapper.replace(rule, m[1], '');
        rule = StringWrapper.replace(rule, m[2], '');
        return m[3] + rule;
      });
    };
    ShadowCss.prototype._scopeCssText = function(cssText, scopeSelector, hostSelector) {
      var unscoped = this._extractUnscopedRulesFromCssText(cssText);
      cssText = this._insertPolyfillHostInCssText(cssText);
      cssText = this._convertColonHost(cssText);
      cssText = this._convertColonHostContext(cssText);
      cssText = this._convertShadowDOMSelectors(cssText);
      if (isPresent(scopeSelector)) {
        cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
      }
      cssText = cssText + '\n' + unscoped;
      return cssText.trim();
    };
    ShadowCss.prototype._extractUnscopedRulesFromCssText = function(cssText) {
      var r = '',
          m;
      var matcher = RegExpWrapper.matcher(_cssContentUnscopedRuleRe, cssText);
      while (isPresent(m = RegExpMatcherWrapper.next(matcher))) {
        var rule = m[0];
        rule = StringWrapper.replace(rule, m[2], '');
        rule = StringWrapper.replace(rule, m[1], m[3]);
        r += rule + '\n\n';
      }
      return r;
    };
    ShadowCss.prototype._convertColonHost = function(cssText) {
      return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
    };
    ShadowCss.prototype._convertColonHostContext = function(cssText) {
      return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
    };
    ShadowCss.prototype._convertColonRule = function(cssText, regExp, partReplacer) {
      return StringWrapper.replaceAllMapped(cssText, regExp, function(m) {
        if (isPresent(m[2])) {
          var parts = m[2].split(','),
              r = [];
          for (var i = 0; i < parts.length; i++) {
            var p = parts[i];
            if (isBlank(p))
              break;
            p = p.trim();
            r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
          }
          return r.join(',');
        } else {
          return _polyfillHostNoCombinator + m[3];
        }
      });
    };
    ShadowCss.prototype._colonHostContextPartReplacer = function(host, part, suffix) {
      if (StringWrapper.contains(part, _polyfillHost)) {
        return this._colonHostPartReplacer(host, part, suffix);
      } else {
        return host + part + suffix + ', ' + part + ' ' + host + suffix;
      }
    };
    ShadowCss.prototype._colonHostPartReplacer = function(host, part, suffix) {
      return host + StringWrapper.replace(part, _polyfillHost, '') + suffix;
    };
    ShadowCss.prototype._convertShadowDOMSelectors = function(cssText) {
      for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
        cssText = StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
      }
      return cssText;
    };
    ShadowCss.prototype._scopeSelectors = function(cssText, scopeSelector, hostSelector) {
      var _this = this;
      return processRules(cssText, function(rule) {
        var selector = rule.selector;
        var content = rule.content;
        if (rule.selector[0] != '@' || rule.selector.startsWith('@page')) {
          selector = _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);
        } else if (rule.selector.startsWith('@media')) {
          content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);
        }
        return new CssRule(selector, content);
      });
    };
    ShadowCss.prototype._scopeSelector = function(selector, scopeSelector, hostSelector, strict) {
      var r = [],
          parts = selector.split(',');
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i].trim();
        var deepParts = StringWrapper.split(p, _shadowDeepSelectors);
        var shallowPart = deepParts[0];
        if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {
          deepParts[0] = strict && !StringWrapper.contains(shallowPart, _polyfillHostNoCombinator) ? this._applyStrictSelectorScope(shallowPart, scopeSelector) : this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
        }
        r.push(deepParts.join(' '));
      }
      return r.join(', ');
    };
    ShadowCss.prototype._selectorNeedsScoping = function(selector, scopeSelector) {
      var re = this._makeScopeMatcher(scopeSelector);
      return !isPresent(RegExpWrapper.firstMatch(re, selector));
    };
    ShadowCss.prototype._makeScopeMatcher = function(scopeSelector) {
      var lre = /\[/g;
      var rre = /\]/g;
      scopeSelector = StringWrapper.replaceAll(scopeSelector, lre, '\\[');
      scopeSelector = StringWrapper.replaceAll(scopeSelector, rre, '\\]');
      return RegExpWrapper.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
    };
    ShadowCss.prototype._applySelectorScope = function(selector, scopeSelector, hostSelector) {
      return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    };
    ShadowCss.prototype._applySimpleSelectorScope = function(selector, scopeSelector, hostSelector) {
      if (isPresent(RegExpWrapper.firstMatch(_polyfillHostRe, selector))) {
        var replaceBy = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
        selector = StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);
        return StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
      } else {
        return scopeSelector + ' ' + selector;
      }
    };
    ShadowCss.prototype._applyStrictSelectorScope = function(selector, scopeSelector) {
      var isRe = /\[is=([^\]]*)\]/g;
      scopeSelector = StringWrapper.replaceAllMapped(scopeSelector, isRe, function(m) {
        return m[1];
      });
      var splits = [' ', '>', '+', '~'],
          scoped = selector,
          attrName = '[' + scopeSelector + ']';
      for (var i = 0; i < splits.length; i++) {
        var sep = splits[i];
        var parts = scoped.split(sep);
        scoped = parts.map(function(p) {
          var t = StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');
          if (t.length > 0 && !ListWrapper.contains(splits, t) && !StringWrapper.contains(t, attrName)) {
            var re = /([^:]*)(:*)(.*)/g;
            var m = RegExpWrapper.firstMatch(re, t);
            if (isPresent(m)) {
              p = m[1] + attrName + m[2] + m[3];
            }
          }
          return p;
        }).join(sep);
      }
      return scoped;
    };
    ShadowCss.prototype._insertPolyfillHostInCssText = function(selector) {
      selector = StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
      selector = StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);
      return selector;
    };
    return ShadowCss;
  }());
  var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim;
  var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
  var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
  var _polyfillHost = '-shadowcsshost';
  var _polyfillHostContext = '-shadowcsscontext';
  var _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
  var _cssColonHostRe = RegExpWrapper.create('(' + _polyfillHost + _parenSuffix, 'im');
  var _cssColonHostContextRe = RegExpWrapper.create('(' + _polyfillHostContext + _parenSuffix, 'im');
  var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
  var _shadowDOMSelectorsRe = [/::shadow/g, /::content/g, /\/shadow-deep\//g, /\/shadow\//g];
  var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)/g;
  var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
  var _polyfillHostRe = RegExpWrapper.create(_polyfillHost, 'im');
  var _colonHostRe = /:host/gim;
  var _colonHostContextRe = /:host-context/gim;
  var _commentRe = /\/\*[\s\S]*?\*\//g;
  function stripComments(input) {
    return StringWrapper.replaceAllMapped(input, _commentRe, function(_) {
      return '';
    });
  }
  var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
  var _curlyRe = /([{}])/g;
  var OPEN_CURLY = '{';
  var CLOSE_CURLY = '}';
  var BLOCK_PLACEHOLDER = '%BLOCK%';
  var CssRule = (function() {
    function CssRule(selector, content) {
      this.selector = selector;
      this.content = content;
    }
    return CssRule;
  }());
  function processRules(input, ruleCallback) {
    var inputWithEscapedBlocks = escapeBlocks(input);
    var nextBlockIndex = 0;
    return StringWrapper.replaceAllMapped(inputWithEscapedBlocks.escapedString, _ruleRe, function(m) {
      var selector = m[2];
      var content = '';
      var suffix = m[4];
      var contentPrefix = '';
      if (isPresent(m[4]) && m[4].startsWith('{' + BLOCK_PLACEHOLDER)) {
        content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
        suffix = m[4].substring(BLOCK_PLACEHOLDER.length + 1);
        contentPrefix = '{';
      }
      var rule = ruleCallback(new CssRule(selector, content));
      return "" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;
    });
  }
  var StringWithEscapedBlocks = (function() {
    function StringWithEscapedBlocks(escapedString, blocks) {
      this.escapedString = escapedString;
      this.blocks = blocks;
    }
    return StringWithEscapedBlocks;
  }());
  function escapeBlocks(input) {
    var inputParts = StringWrapper.split(input, _curlyRe);
    var resultParts = [];
    var escapedBlocks = [];
    var bracketCount = 0;
    var currentBlockParts = [];
    for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {
      var part = inputParts[partIndex];
      if (part == CLOSE_CURLY) {
        bracketCount--;
      }
      if (bracketCount > 0) {
        currentBlockParts.push(part);
      } else {
        if (currentBlockParts.length > 0) {
          escapedBlocks.push(currentBlockParts.join(''));
          resultParts.push(BLOCK_PLACEHOLDER);
          currentBlockParts = [];
        }
        resultParts.push(part);
      }
      if (part == OPEN_CURLY) {
        bracketCount++;
      }
    }
    if (currentBlockParts.length > 0) {
      escapedBlocks.push(currentBlockParts.join(''));
      resultParts.push(BLOCK_PLACEHOLDER);
    }
    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
  }
  var COMPONENT_VARIABLE = '%COMP%';
  var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
  var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
  var StylesCompileDependency = (function() {
    function StylesCompileDependency(moduleUrl, isShimmed, valuePlaceholder) {
      this.moduleUrl = moduleUrl;
      this.isShimmed = isShimmed;
      this.valuePlaceholder = valuePlaceholder;
    }
    return StylesCompileDependency;
  }());
  var StylesCompileResult = (function() {
    function StylesCompileResult(statements, stylesVar, dependencies) {
      this.statements = statements;
      this.stylesVar = stylesVar;
      this.dependencies = dependencies;
    }
    return StylesCompileResult;
  }());
  var StyleCompiler = (function() {
    function StyleCompiler(_urlResolver) {
      this._urlResolver = _urlResolver;
      this._shadowCss = new ShadowCss();
    }
    StyleCompiler.prototype.compileComponent = function(comp) {
      var shim = comp.template.encapsulation === _angular_core.ViewEncapsulation.Emulated;
      return this._compileStyles(getStylesVarName(comp), comp.template.styles, comp.template.styleUrls, shim);
    };
    StyleCompiler.prototype.compileStylesheet = function(stylesheetUrl, cssText, isShimmed) {
      var styleWithImports = extractStyleUrls(this._urlResolver, stylesheetUrl, cssText);
      return this._compileStyles(getStylesVarName(null), [styleWithImports.style], styleWithImports.styleUrls, isShimmed);
    };
    StyleCompiler.prototype._compileStyles = function(stylesVar, plainStyles, absUrls, shim) {
      var _this = this;
      var styleExpressions = plainStyles.map(function(plainStyle) {
        return literal(_this._shimIfNeeded(plainStyle, shim));
      });
      var dependencies = [];
      for (var i = 0; i < absUrls.length; i++) {
        var identifier = new CompileIdentifierMetadata({name: getStylesVarName(null)});
        dependencies.push(new StylesCompileDependency(absUrls[i], shim, identifier));
        styleExpressions.push(new ExternalExpr(identifier));
      }
      var stmt = variable(stylesVar).set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const]))).toDeclStmt(null, [StmtModifier.Final]);
      return new StylesCompileResult([stmt], stylesVar, dependencies);
    };
    StyleCompiler.prototype._shimIfNeeded = function(style, shim) {
      return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
    };
    return StyleCompiler;
  }());
  StyleCompiler.decorators = [{type: _angular_core.Injectable}];
  StyleCompiler.ctorParameters = [{type: UrlResolver}];
  function getStylesVarName(component) {
    var result = "styles";
    if (isPresent(component)) {
      result += "_" + component.type.name;
    }
    return result;
  }
  function _enumExpression(classIdentifier, value) {
    if (isBlank(value))
      return NULL_EXPR;
    var name = resolveEnumToken(classIdentifier.runtime, value);
    return importExpr(new CompileIdentifierMetadata({
      name: classIdentifier.name + "." + name,
      moduleUrl: classIdentifier.moduleUrl,
      runtime: value
    }));
  }
  var ViewTypeEnum = (function() {
    function ViewTypeEnum() {}
    ViewTypeEnum.fromValue = function(value) {
      return _enumExpression(Identifiers.ViewType, value);
    };
    return ViewTypeEnum;
  }());
  ViewTypeEnum.HOST = ViewTypeEnum.fromValue(ViewType.HOST);
  ViewTypeEnum.COMPONENT = ViewTypeEnum.fromValue(ViewType.COMPONENT);
  ViewTypeEnum.EMBEDDED = ViewTypeEnum.fromValue(ViewType.EMBEDDED);
  var ViewEncapsulationEnum = (function() {
    function ViewEncapsulationEnum() {}
    ViewEncapsulationEnum.fromValue = function(value) {
      return _enumExpression(Identifiers.ViewEncapsulation, value);
    };
    return ViewEncapsulationEnum;
  }());
  ViewEncapsulationEnum.Emulated = ViewEncapsulationEnum.fromValue(_angular_core.ViewEncapsulation.Emulated);
  ViewEncapsulationEnum.Native = ViewEncapsulationEnum.fromValue(_angular_core.ViewEncapsulation.Native);
  ViewEncapsulationEnum.None = ViewEncapsulationEnum.fromValue(_angular_core.ViewEncapsulation.None);
  var ChangeDetectorStateEnum = (function() {
    function ChangeDetectorStateEnum() {}
    ChangeDetectorStateEnum.fromValue = function(value) {
      return _enumExpression(Identifiers.ChangeDetectorState, value);
    };
    return ChangeDetectorStateEnum;
  }());
  ChangeDetectorStateEnum.NeverChecked = ChangeDetectorStateEnum.fromValue(ChangeDetectorState.NeverChecked);
  ChangeDetectorStateEnum.CheckedBefore = ChangeDetectorStateEnum.fromValue(ChangeDetectorState.CheckedBefore);
  ChangeDetectorStateEnum.Errored = ChangeDetectorStateEnum.fromValue(ChangeDetectorState.Errored);
  var ChangeDetectionStrategyEnum = (function() {
    function ChangeDetectionStrategyEnum() {}
    ChangeDetectionStrategyEnum.fromValue = function(value) {
      return _enumExpression(Identifiers.ChangeDetectionStrategy, value);
    };
    return ChangeDetectionStrategyEnum;
  }());
  ChangeDetectionStrategyEnum.CheckOnce = ChangeDetectionStrategyEnum.fromValue(_angular_core.ChangeDetectionStrategy.CheckOnce);
  ChangeDetectionStrategyEnum.Checked = ChangeDetectionStrategyEnum.fromValue(_angular_core.ChangeDetectionStrategy.Checked);
  ChangeDetectionStrategyEnum.CheckAlways = ChangeDetectionStrategyEnum.fromValue(_angular_core.ChangeDetectionStrategy.CheckAlways);
  ChangeDetectionStrategyEnum.Detached = ChangeDetectionStrategyEnum.fromValue(_angular_core.ChangeDetectionStrategy.Detached);
  ChangeDetectionStrategyEnum.OnPush = ChangeDetectionStrategyEnum.fromValue(_angular_core.ChangeDetectionStrategy.OnPush);
  ChangeDetectionStrategyEnum.Default = ChangeDetectionStrategyEnum.fromValue(_angular_core.ChangeDetectionStrategy.Default);
  var ViewConstructorVars = (function() {
    function ViewConstructorVars() {}
    return ViewConstructorVars;
  }());
  ViewConstructorVars.viewUtils = variable('viewUtils');
  ViewConstructorVars.parentInjector = variable('parentInjector');
  ViewConstructorVars.declarationEl = variable('declarationEl');
  var ViewProperties = (function() {
    function ViewProperties() {}
    return ViewProperties;
  }());
  ViewProperties.renderer = THIS_EXPR.prop('renderer');
  ViewProperties.projectableNodes = THIS_EXPR.prop('projectableNodes');
  ViewProperties.viewUtils = THIS_EXPR.prop('viewUtils');
  var EventHandlerVars = (function() {
    function EventHandlerVars() {}
    return EventHandlerVars;
  }());
  EventHandlerVars.event = variable('$event');
  var InjectMethodVars = (function() {
    function InjectMethodVars() {}
    return InjectMethodVars;
  }());
  InjectMethodVars.token = variable('token');
  InjectMethodVars.requestNodeIndex = variable('requestNodeIndex');
  InjectMethodVars.notFoundResult = variable('notFoundResult');
  var DetectChangesVars = (function() {
    function DetectChangesVars() {}
    return DetectChangesVars;
  }());
  DetectChangesVars.throwOnChange = variable("throwOnChange");
  DetectChangesVars.changes = variable("changes");
  DetectChangesVars.changed = variable("changed");
  DetectChangesVars.valUnwrapper = variable("valUnwrapper");
  function getPropertyInView(property, callingView, definedView) {
    if (callingView === definedView) {
      return property;
    } else {
      var viewProp = THIS_EXPR;
      var currView = callingView;
      while (currView !== definedView && isPresent(currView.declarationElement.view)) {
        currView = currView.declarationElement.view;
        viewProp = viewProp.prop('parent');
      }
      if (currView !== definedView) {
        throw new BaseException$1("Internal error: Could not calculate a property in a parent view: " + property);
      }
      if (property instanceof ReadPropExpr) {
        var readPropExpr_1 = property;
        if (definedView.fields.some(function(field) {
          return field.name == readPropExpr_1.name;
        }) || definedView.getters.some(function(field) {
          return field.name == readPropExpr_1.name;
        })) {
          viewProp = viewProp.cast(definedView.classType);
        }
      }
      return replaceVarInExpression(THIS_EXPR.name, viewProp, property);
    }
  }
  function injectFromViewParentInjector(token, optional) {
    var args = [createDiTokenExpression(token)];
    if (optional) {
      args.push(NULL_EXPR);
    }
    return THIS_EXPR.prop('parentInjector').callMethod('get', args);
  }
  function getViewFactoryName(component, embeddedTemplateIndex) {
    return "viewFactory_" + component.type.name + embeddedTemplateIndex;
  }
  function createDiTokenExpression(token) {
    if (isPresent(token.value)) {
      return literal(token.value);
    } else if (token.identifierIsInstance) {
      return importExpr(token.identifier).instantiate([], importType(token.identifier, [], [TypeModifier.Const]));
    } else {
      return importExpr(token.identifier);
    }
  }
  function createFlatArray(expressions) {
    var lastNonArrayExpressions = [];
    var result = literalArr([]);
    for (var i = 0; i < expressions.length; i++) {
      var expr = expressions[i];
      if (expr.type instanceof ArrayType) {
        if (lastNonArrayExpressions.length > 0) {
          result = result.callMethod(BuiltinMethod.ConcatArray, [literalArr(lastNonArrayExpressions)]);
          lastNonArrayExpressions = [];
        }
        result = result.callMethod(BuiltinMethod.ConcatArray, [expr]);
      } else {
        lastNonArrayExpressions.push(expr);
      }
    }
    if (lastNonArrayExpressions.length > 0) {
      result = result.callMethod(BuiltinMethod.ConcatArray, [literalArr(lastNonArrayExpressions)]);
    }
    return result;
  }
  function createPureProxy(fn, argCount, pureProxyProp, view) {
    view.fields.push(new ClassField(pureProxyProp.name, null));
    var pureProxyId = argCount < Identifiers.pureProxies.length ? Identifiers.pureProxies[argCount] : null;
    if (isBlank(pureProxyId)) {
      throw new BaseException$1("Unsupported number of argument for pure functions: " + argCount);
    }
    view.createMethod.addStmt(THIS_EXPR.prop(pureProxyProp.name).set(importExpr(pureProxyId).callFn([fn])).toStmt());
  }
  var ViewQueryValues = (function() {
    function ViewQueryValues(view, values) {
      this.view = view;
      this.values = values;
    }
    return ViewQueryValues;
  }());
  var CompileQuery = (function() {
    function CompileQuery(meta, queryList, ownerDirectiveExpression, view) {
      this.meta = meta;
      this.queryList = queryList;
      this.ownerDirectiveExpression = ownerDirectiveExpression;
      this.view = view;
      this._values = new ViewQueryValues(view, []);
    }
    CompileQuery.prototype.addValue = function(value, view) {
      var currentView = view;
      var elPath = [];
      while (isPresent(currentView) && currentView !== this.view) {
        var parentEl = currentView.declarationElement;
        elPath.unshift(parentEl);
        currentView = parentEl.view;
      }
      var queryListForDirtyExpr = getPropertyInView(this.queryList, view, this.view);
      var viewValues = this._values;
      elPath.forEach(function(el) {
        var last = viewValues.values.length > 0 ? viewValues.values[viewValues.values.length - 1] : null;
        if (last instanceof ViewQueryValues && last.view === el.embeddedView) {
          viewValues = last;
        } else {
          var newViewValues = new ViewQueryValues(el.embeddedView, []);
          viewValues.values.push(newViewValues);
          viewValues = newViewValues;
        }
      });
      viewValues.values.push(value);
      if (elPath.length > 0) {
        view.dirtyParentQueriesMethod.addStmt(queryListForDirtyExpr.callMethod('setDirty', []).toStmt());
      }
    };
    CompileQuery.prototype.afterChildren = function(targetMethod) {
      var values = createQueryValues(this._values);
      var updateStmts = [this.queryList.callMethod('reset', [literalArr(values)]).toStmt()];
      if (isPresent(this.ownerDirectiveExpression)) {
        var valueExpr = this.meta.first ? this.queryList.prop('first') : this.queryList;
        updateStmts.push(this.ownerDirectiveExpression.prop(this.meta.propertyName).set(valueExpr).toStmt());
      }
      if (!this.meta.first) {
        updateStmts.push(this.queryList.callMethod('notifyOnChanges', []).toStmt());
      }
      targetMethod.addStmt(new IfStmt(this.queryList.prop('dirty'), updateStmts));
    };
    return CompileQuery;
  }());
  function createQueryValues(viewValues) {
    return ListWrapper.flatten(viewValues.values.map(function(entry) {
      if (entry instanceof ViewQueryValues) {
        return mapNestedViews(entry.view.declarationElement.appElement, entry.view, createQueryValues(entry));
      } else {
        return entry;
      }
    }));
  }
  function mapNestedViews(declarationAppElement, view, expressions) {
    var adjustedExpressions = expressions.map(function(expr) {
      return replaceVarInExpression(THIS_EXPR.name, variable('nestedView'), expr);
    });
    return declarationAppElement.callMethod('mapNestedViews', [variable(view.className), fn([new FnParam('nestedView', view.classType)], [new ReturnStatement(literalArr(adjustedExpressions))])]);
  }
  function createQueryList(query, directiveInstance, propertyName, compileView) {
    compileView.fields.push(new ClassField(propertyName, importType(Identifiers.QueryList)));
    var expr = THIS_EXPR.prop(propertyName);
    compileView.createMethod.addStmt(THIS_EXPR.prop(propertyName).set(importExpr(Identifiers.QueryList).instantiate([])).toStmt());
    return expr;
  }
  function addQueryToTokenMap(map, query) {
    query.meta.selectors.forEach(function(selector) {
      var entry = map.get(selector);
      if (isBlank(entry)) {
        entry = [];
        map.add(selector, entry);
      }
      entry.push(query);
    });
  }
  var _DebugState = (function() {
    function _DebugState(nodeIndex, sourceAst) {
      this.nodeIndex = nodeIndex;
      this.sourceAst = sourceAst;
    }
    return _DebugState;
  }());
  var NULL_DEBUG_STATE = new _DebugState(null, null);
  var CompileMethod = (function() {
    function CompileMethod(_view) {
      this._view = _view;
      this._newState = NULL_DEBUG_STATE;
      this._currState = NULL_DEBUG_STATE;
      this._bodyStatements = [];
      this._debugEnabled = this._view.genConfig.genDebugInfo;
    }
    CompileMethod.prototype._updateDebugContextIfNeeded = function() {
      if (this._newState.nodeIndex !== this._currState.nodeIndex || this._newState.sourceAst !== this._currState.sourceAst) {
        var expr = this._updateDebugContext(this._newState);
        if (isPresent(expr)) {
          this._bodyStatements.push(expr.toStmt());
        }
      }
    };
    CompileMethod.prototype._updateDebugContext = function(newState) {
      this._currState = this._newState = newState;
      if (this._debugEnabled) {
        var sourceLocation = isPresent(newState.sourceAst) ? newState.sourceAst.sourceSpan.start : null;
        return THIS_EXPR.callMethod('debug', [literal(newState.nodeIndex), isPresent(sourceLocation) ? literal(sourceLocation.line) : NULL_EXPR, isPresent(sourceLocation) ? literal(sourceLocation.col) : NULL_EXPR]);
      } else {
        return null;
      }
    };
    CompileMethod.prototype.resetDebugInfoExpr = function(nodeIndex, templateAst) {
      var res = this._updateDebugContext(new _DebugState(nodeIndex, templateAst));
      return isPresent(res) ? res : NULL_EXPR;
    };
    CompileMethod.prototype.resetDebugInfo = function(nodeIndex, templateAst) {
      this._newState = new _DebugState(nodeIndex, templateAst);
    };
    CompileMethod.prototype.addStmt = function(stmt) {
      this._updateDebugContextIfNeeded();
      this._bodyStatements.push(stmt);
    };
    CompileMethod.prototype.addStmts = function(stmts) {
      this._updateDebugContextIfNeeded();
      ListWrapper.addAll(this._bodyStatements, stmts);
    };
    CompileMethod.prototype.finish = function() {
      return this._bodyStatements;
    };
    CompileMethod.prototype.isEmpty = function() {
      return this._bodyStatements.length === 0;
    };
    return CompileMethod;
  }());
  var CompileNode = (function() {
    function CompileNode(parent, view, nodeIndex, renderNode, sourceAst) {
      this.parent = parent;
      this.view = view;
      this.nodeIndex = nodeIndex;
      this.renderNode = renderNode;
      this.sourceAst = sourceAst;
    }
    CompileNode.prototype.isNull = function() {
      return isBlank(this.renderNode);
    };
    CompileNode.prototype.isRootElement = function() {
      return this.view != this.parent.view;
    };
    return CompileNode;
  }());
  var CompileElement = (function(_super) {
    __extends(CompileElement, _super);
    function CompileElement(parent, view, nodeIndex, renderNode, sourceAst, component, _directives, _resolvedProvidersArray, hasViewContainer, hasEmbeddedView, references) {
      var _this = this;
      _super.call(this, parent, view, nodeIndex, renderNode, sourceAst);
      this.component = component;
      this._directives = _directives;
      this._resolvedProvidersArray = _resolvedProvidersArray;
      this.hasViewContainer = hasViewContainer;
      this.hasEmbeddedView = hasEmbeddedView;
      this._compViewExpr = null;
      this._instances = new CompileTokenMap();
      this._queryCount = 0;
      this._queries = new CompileTokenMap();
      this._componentConstructorViewQueryLists = [];
      this.contentNodesByNgContentIndex = null;
      this.referenceTokens = {};
      references.forEach(function(ref) {
        return _this.referenceTokens[ref.name] = ref.value;
      });
      this.elementRef = importExpr(Identifiers.ElementRef).instantiate([this.renderNode]);
      this._instances.add(identifierToken(Identifiers.ElementRef), this.elementRef);
      this.injector = THIS_EXPR.callMethod('injector', [literal(this.nodeIndex)]);
      this._instances.add(identifierToken(Identifiers.Injector), this.injector);
      this._instances.add(identifierToken(Identifiers.Renderer), THIS_EXPR.prop('renderer'));
      if (this.hasViewContainer || this.hasEmbeddedView || isPresent(this.component)) {
        this._createAppElement();
      }
    }
    CompileElement.createNull = function() {
      return new CompileElement(null, null, null, null, null, null, [], [], false, false, []);
    };
    CompileElement.prototype._createAppElement = function() {
      var fieldName = "_appEl_" + this.nodeIndex;
      var parentNodeIndex = this.isRootElement() ? null : this.parent.nodeIndex;
      this.view.fields.push(new ClassField(fieldName, importType(Identifiers.AppElement), [StmtModifier.Private]));
      var statement = THIS_EXPR.prop(fieldName).set(importExpr(Identifiers.AppElement).instantiate([literal(this.nodeIndex), literal(parentNodeIndex), THIS_EXPR, this.renderNode])).toStmt();
      this.view.createMethod.addStmt(statement);
      this.appElement = THIS_EXPR.prop(fieldName);
      this._instances.add(identifierToken(Identifiers.AppElement), this.appElement);
    };
    CompileElement.prototype.setComponentView = function(compViewExpr) {
      this._compViewExpr = compViewExpr;
      this.contentNodesByNgContentIndex = ListWrapper.createFixedSize(this.component.template.ngContentSelectors.length);
      for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {
        this.contentNodesByNgContentIndex[i] = [];
      }
    };
    CompileElement.prototype.setEmbeddedView = function(embeddedView) {
      this.embeddedView = embeddedView;
      if (isPresent(embeddedView)) {
        var createTemplateRefExpr = importExpr(Identifiers.TemplateRef_).instantiate([this.appElement, this.embeddedView.viewFactory]);
        var provider = new CompileProviderMetadata({
          token: identifierToken(Identifiers.TemplateRef),
          useValue: createTemplateRefExpr
        });
        this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], exports.ProviderAstType.Builtin, this.sourceAst.sourceSpan));
      }
    };
    CompileElement.prototype.beforeChildren = function() {
      var _this = this;
      if (this.hasViewContainer) {
        this._instances.add(identifierToken(Identifiers.ViewContainerRef), this.appElement.prop('vcRef'));
      }
      this._resolvedProviders = new CompileTokenMap();
      this._resolvedProvidersArray.forEach(function(provider) {
        return _this._resolvedProviders.add(provider.token, provider);
      });
      this._resolvedProviders.values().forEach(function(resolvedProvider) {
        var providerValueExpressions = resolvedProvider.providers.map(function(provider) {
          if (isPresent(provider.useExisting)) {
            return _this._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({token: provider.useExisting}));
          } else if (isPresent(provider.useFactory)) {
            var deps = isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
            var depsExpr = deps.map(function(dep) {
              return _this._getDependency(resolvedProvider.providerType, dep);
            });
            return importExpr(provider.useFactory).callFn(depsExpr);
          } else if (isPresent(provider.useClass)) {
            var deps = isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
            var depsExpr = deps.map(function(dep) {
              return _this._getDependency(resolvedProvider.providerType, dep);
            });
            return importExpr(provider.useClass).instantiate(depsExpr, importType(provider.useClass));
          } else {
            return _convertValueToOutputAst(provider.useValue);
          }
        });
        var propName = "_" + resolvedProvider.token.name + "_" + _this.nodeIndex + "_" + _this._instances.size;
        var instance = createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager, _this);
        _this._instances.add(resolvedProvider.token, instance);
      });
      this.directiveInstances = this._directives.map(function(directive) {
        return _this._instances.get(identifierToken(directive.type));
      });
      for (var i = 0; i < this.directiveInstances.length; i++) {
        var directiveInstance = this.directiveInstances[i];
        var directive = this._directives[i];
        directive.queries.forEach(function(queryMeta) {
          _this._addQuery(queryMeta, directiveInstance);
        });
      }
      var queriesWithReads = [];
      this._resolvedProviders.values().forEach(function(resolvedProvider) {
        var queriesForProvider = _this._getQueriesFor(resolvedProvider.token);
        ListWrapper.addAll(queriesWithReads, queriesForProvider.map(function(query) {
          return new _QueryWithRead(query, resolvedProvider.token);
        }));
      });
      StringMapWrapper.forEach(this.referenceTokens, function(_, varName) {
        var token = _this.referenceTokens[varName];
        var varValue;
        if (isPresent(token)) {
          varValue = _this._instances.get(token);
        } else {
          varValue = _this.renderNode;
        }
        _this.view.locals.set(varName, varValue);
        var varToken = new CompileTokenMetadata({value: varName});
        ListWrapper.addAll(queriesWithReads, _this._getQueriesFor(varToken).map(function(query) {
          return new _QueryWithRead(query, varToken);
        }));
      });
      queriesWithReads.forEach(function(queryWithRead) {
        var value;
        if (isPresent(queryWithRead.read.identifier)) {
          value = _this._instances.get(queryWithRead.read);
        } else {
          var token = _this.referenceTokens[queryWithRead.read.value];
          if (isPresent(token)) {
            value = _this._instances.get(token);
          } else {
            value = _this.elementRef;
          }
        }
        if (isPresent(value)) {
          queryWithRead.query.addValue(value, _this.view);
        }
      });
      if (isPresent(this.component)) {
        var componentConstructorViewQueryList = isPresent(this.component) ? literalArr(this._componentConstructorViewQueryLists) : NULL_EXPR;
        var compExpr = isPresent(this.getComponent()) ? this.getComponent() : NULL_EXPR;
        this.view.createMethod.addStmt(this.appElement.callMethod('initComponent', [compExpr, componentConstructorViewQueryList, this._compViewExpr]).toStmt());
      }
    };
    CompileElement.prototype.afterChildren = function(childNodeCount) {
      var _this = this;
      this._resolvedProviders.values().forEach(function(resolvedProvider) {
        var providerExpr = _this._instances.get(resolvedProvider.token);
        var providerChildNodeCount = resolvedProvider.providerType === exports.ProviderAstType.PrivateService ? 0 : childNodeCount;
        _this.view.injectorGetMethod.addStmt(createInjectInternalCondition(_this.nodeIndex, providerChildNodeCount, resolvedProvider, providerExpr));
      });
      this._queries.values().forEach(function(queries) {
        return queries.forEach(function(query) {
          return query.afterChildren(_this.view.updateContentQueriesMethod);
        });
      });
    };
    CompileElement.prototype.addContentNode = function(ngContentIndex, nodeExpr) {
      this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);
    };
    CompileElement.prototype.getComponent = function() {
      return isPresent(this.component) ? this._instances.get(identifierToken(this.component.type)) : null;
    };
    CompileElement.prototype.getProviderTokens = function() {
      return this._resolvedProviders.values().map(function(resolvedProvider) {
        return createDiTokenExpression(resolvedProvider.token);
      });
    };
    CompileElement.prototype._getQueriesFor = function(token) {
      var result = [];
      var currentEl = this;
      var distance = 0;
      var queries;
      while (!currentEl.isNull()) {
        queries = currentEl._queries.get(token);
        if (isPresent(queries)) {
          ListWrapper.addAll(result, queries.filter(function(query) {
            return query.meta.descendants || distance <= 1;
          }));
        }
        if (currentEl._directives.length > 0) {
          distance++;
        }
        currentEl = currentEl.parent;
      }
      queries = this.view.componentView.viewQueries.get(token);
      if (isPresent(queries)) {
        ListWrapper.addAll(result, queries);
      }
      return result;
    };
    CompileElement.prototype._addQuery = function(queryMeta, directiveInstance) {
      var propName = "_query_" + queryMeta.selectors[0].name + "_" + this.nodeIndex + "_" + this._queryCount++;
      var queryList = createQueryList(queryMeta, directiveInstance, propName, this.view);
      var query = new CompileQuery(queryMeta, queryList, directiveInstance, this.view);
      addQueryToTokenMap(this._queries, query);
      return query;
    };
    CompileElement.prototype._getLocalDependency = function(requestingProviderType, dep) {
      var result = null;
      if (isBlank(result) && isPresent(dep.query)) {
        result = this._addQuery(dep.query, null).queryList;
      }
      if (isBlank(result) && isPresent(dep.viewQuery)) {
        result = createQueryList(dep.viewQuery, null, "_viewQuery_" + dep.viewQuery.selectors[0].name + "_" + this.nodeIndex + "_" + this._componentConstructorViewQueryLists.length, this.view);
        this._componentConstructorViewQueryLists.push(result);
      }
      if (isPresent(dep.token)) {
        if (isBlank(result)) {
          if (dep.token.equalsTo(identifierToken(Identifiers.ChangeDetectorRef))) {
            if (requestingProviderType === exports.ProviderAstType.Component) {
              return this._compViewExpr.prop('ref');
            } else {
              return getPropertyInView(THIS_EXPR.prop('ref'), this.view, this.view.componentView);
            }
          }
        }
        if (isBlank(result)) {
          result = this._instances.get(dep.token);
        }
      }
      return result;
    };
    CompileElement.prototype._getDependency = function(requestingProviderType, dep) {
      var currElement = this;
      var result = null;
      if (dep.isValue) {
        result = literal(dep.value);
      }
      if (isBlank(result) && !dep.isSkipSelf) {
        result = this._getLocalDependency(requestingProviderType, dep);
      }
      while (isBlank(result) && !currElement.parent.isNull()) {
        currElement = currElement.parent;
        result = currElement._getLocalDependency(exports.ProviderAstType.PublicService, new CompileDiDependencyMetadata({token: dep.token}));
      }
      if (isBlank(result)) {
        result = injectFromViewParentInjector(dep.token, dep.isOptional);
      }
      if (isBlank(result)) {
        result = NULL_EXPR;
      }
      return getPropertyInView(result, this.view, currElement.view);
    };
    return CompileElement;
  }(CompileNode));
  function createInjectInternalCondition(nodeIndex, childNodeCount, provider, providerExpr) {
    var indexCondition;
    if (childNodeCount > 0) {
      indexCondition = literal(nodeIndex).lowerEquals(InjectMethodVars.requestNodeIndex).and(InjectMethodVars.requestNodeIndex.lowerEquals(literal(nodeIndex + childNodeCount)));
    } else {
      indexCondition = literal(nodeIndex).identical(InjectMethodVars.requestNodeIndex);
    }
    return new IfStmt(InjectMethodVars.token.identical(createDiTokenExpression(provider.token)).and(indexCondition), [new ReturnStatement(providerExpr)]);
  }
  function createProviderProperty(propName, provider, providerValueExpressions, isMulti, isEager, compileElement) {
    var view = compileElement.view;
    var resolvedProviderValueExpr;
    var type;
    if (isMulti) {
      resolvedProviderValueExpr = literalArr(providerValueExpressions);
      type = new ArrayType(DYNAMIC_TYPE);
    } else {
      resolvedProviderValueExpr = providerValueExpressions[0];
      type = providerValueExpressions[0].type;
    }
    if (isBlank(type)) {
      type = DYNAMIC_TYPE;
    }
    if (isEager) {
      view.fields.push(new ClassField(propName, type));
      view.createMethod.addStmt(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
    } else {
      var internalField = "_" + propName;
      view.fields.push(new ClassField(internalField, type));
      var getter = new CompileMethod(view);
      getter.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
      getter.addStmt(new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]));
      getter.addStmt(new ReturnStatement(THIS_EXPR.prop(internalField)));
      view.getters.push(new ClassGetter(propName, getter.finish(), type));
    }
    return THIS_EXPR.prop(propName);
  }
  var _QueryWithRead = (function() {
    function _QueryWithRead(query, match) {
      this.query = query;
      this.read = isPresent(query.meta.read) ? query.meta.read : match;
    }
    return _QueryWithRead;
  }());
  function _convertValueToOutputAst(value) {
    return visitValue(value, new _ValueOutputAstTransformer(), null);
  }
  var _ValueOutputAstTransformer = (function(_super) {
    __extends(_ValueOutputAstTransformer, _super);
    function _ValueOutputAstTransformer() {
      _super.apply(this, arguments);
    }
    _ValueOutputAstTransformer.prototype.visitArray = function(arr, context) {
      var _this = this;
      return literalArr(arr.map(function(value) {
        return visitValue(value, _this, context);
      }));
    };
    _ValueOutputAstTransformer.prototype.visitStringMap = function(map, context) {
      var _this = this;
      var entries = [];
      StringMapWrapper.forEach(map, function(value, key) {
        entries.push([key, visitValue(value, _this, context)]);
      });
      return literalMap(entries);
    };
    _ValueOutputAstTransformer.prototype.visitPrimitive = function(value, context) {
      return literal(value);
    };
    _ValueOutputAstTransformer.prototype.visitOther = function(value, context) {
      if (value instanceof CompileIdentifierMetadata) {
        return importExpr(value);
      } else if (value instanceof Expression) {
        return value;
      } else {
        throw new _angular_core.BaseException("Illegal state: Don't now how to compile value " + value);
      }
    };
    return _ValueOutputAstTransformer;
  }(ValueTransformer));
  var _PurePipeProxy = (function() {
    function _PurePipeProxy(view, instance, argCount) {
      this.view = view;
      this.instance = instance;
      this.argCount = argCount;
    }
    return _PurePipeProxy;
  }());
  var CompilePipe = (function() {
    function CompilePipe(view, meta) {
      this.view = view;
      this.meta = meta;
      this._purePipeProxies = [];
      this.instance = THIS_EXPR.prop("_pipe_" + meta.name + "_" + view.pipeCount++);
    }
    CompilePipe.call = function(view, name, args) {
      var compView = view.componentView;
      var meta = _findPipeMeta(compView, name);
      var pipe;
      if (meta.pure) {
        pipe = compView.purePipes.get(name);
        if (isBlank(pipe)) {
          pipe = new CompilePipe(compView, meta);
          compView.purePipes.set(name, pipe);
          compView.pipes.push(pipe);
        }
      } else {
        pipe = new CompilePipe(view, meta);
        view.pipes.push(pipe);
      }
      return pipe._call(view, args);
    };
    Object.defineProperty(CompilePipe.prototype, "pure", {
      get: function() {
        return this.meta.pure;
      },
      enumerable: true,
      configurable: true
    });
    CompilePipe.prototype.create = function() {
      var _this = this;
      var deps = this.meta.type.diDeps.map(function(diDep) {
        if (diDep.token.equalsTo(identifierToken(Identifiers.ChangeDetectorRef))) {
          return getPropertyInView(THIS_EXPR.prop('ref'), _this.view, _this.view.componentView);
        }
        return injectFromViewParentInjector(diDep.token, false);
      });
      this.view.fields.push(new ClassField(this.instance.name, importType(this.meta.type)));
      this.view.createMethod.resetDebugInfo(null, null);
      this.view.createMethod.addStmt(THIS_EXPR.prop(this.instance.name).set(importExpr(this.meta.type).instantiate(deps)).toStmt());
      this._purePipeProxies.forEach(function(purePipeProxy) {
        var pipeInstanceSeenFromPureProxy = getPropertyInView(_this.instance, purePipeProxy.view, _this.view);
        createPureProxy(pipeInstanceSeenFromPureProxy.prop('transform').callMethod(BuiltinMethod.bind, [pipeInstanceSeenFromPureProxy]), purePipeProxy.argCount, purePipeProxy.instance, purePipeProxy.view);
      });
    };
    CompilePipe.prototype._call = function(callingView, args) {
      if (this.meta.pure) {
        var purePipeProxy = new _PurePipeProxy(callingView, THIS_EXPR.prop(this.instance.name + "_" + this._purePipeProxies.length), args.length);
        this._purePipeProxies.push(purePipeProxy);
        return importExpr(Identifiers.castByValue).callFn([purePipeProxy.instance, getPropertyInView(this.instance.prop('transform'), callingView, this.view)]).callFn(args);
      } else {
        return getPropertyInView(this.instance, callingView, this.view).callMethod('transform', args);
      }
    };
    return CompilePipe;
  }());
  function _findPipeMeta(view, name) {
    var pipeMeta = null;
    for (var i = view.pipeMetas.length - 1; i >= 0; i--) {
      var localPipeMeta = view.pipeMetas[i];
      if (localPipeMeta.name == name) {
        pipeMeta = localPipeMeta;
        break;
      }
    }
    if (isBlank(pipeMeta)) {
      throw new BaseException$1("Illegal state: Could not find pipe " + name + " although the parser should have detected this error!");
    }
    return pipeMeta;
  }
  var CompileView = (function() {
    function CompileView(component, genConfig, pipeMetas, styles, viewIndex, declarationElement, templateVariableBindings) {
      var _this = this;
      this.component = component;
      this.genConfig = genConfig;
      this.pipeMetas = pipeMetas;
      this.styles = styles;
      this.viewIndex = viewIndex;
      this.declarationElement = declarationElement;
      this.templateVariableBindings = templateVariableBindings;
      this.nodes = [];
      this.rootNodesOrAppElements = [];
      this.bindings = [];
      this.classStatements = [];
      this.eventHandlerMethods = [];
      this.fields = [];
      this.getters = [];
      this.disposables = [];
      this.subscriptions = [];
      this.purePipes = new Map();
      this.pipes = [];
      this.locals = new Map();
      this.literalArrayCount = 0;
      this.literalMapCount = 0;
      this.pipeCount = 0;
      this.createMethod = new CompileMethod(this);
      this.injectorGetMethod = new CompileMethod(this);
      this.updateContentQueriesMethod = new CompileMethod(this);
      this.dirtyParentQueriesMethod = new CompileMethod(this);
      this.updateViewQueriesMethod = new CompileMethod(this);
      this.detectChangesInInputsMethod = new CompileMethod(this);
      this.detectChangesRenderPropertiesMethod = new CompileMethod(this);
      this.afterContentLifecycleCallbacksMethod = new CompileMethod(this);
      this.afterViewLifecycleCallbacksMethod = new CompileMethod(this);
      this.destroyMethod = new CompileMethod(this);
      this.viewType = getViewType(component, viewIndex);
      this.className = "_View_" + component.type.name + viewIndex;
      this.classType = importType(new CompileIdentifierMetadata({name: this.className}));
      this.viewFactory = variable(getViewFactoryName(component, viewIndex));
      if (this.viewType === ViewType.COMPONENT || this.viewType === ViewType.HOST) {
        this.componentView = this;
      } else {
        this.componentView = this.declarationElement.view.componentView;
      }
      this.componentContext = getPropertyInView(THIS_EXPR.prop('context'), this, this.componentView);
      var viewQueries = new CompileTokenMap();
      if (this.viewType === ViewType.COMPONENT) {
        var directiveInstance = THIS_EXPR.prop('context');
        ListWrapper.forEachWithIndex(this.component.viewQueries, function(queryMeta, queryIndex) {
          var propName = "_viewQuery_" + queryMeta.selectors[0].name + "_" + queryIndex;
          var queryList = createQueryList(queryMeta, directiveInstance, propName, _this);
          var query = new CompileQuery(queryMeta, queryList, directiveInstance, _this);
          addQueryToTokenMap(viewQueries, query);
        });
        var constructorViewQueryCount = 0;
        this.component.type.diDeps.forEach(function(dep) {
          if (isPresent(dep.viewQuery)) {
            var queryList = THIS_EXPR.prop('declarationAppElement').prop('componentConstructorViewQueries').key(literal(constructorViewQueryCount++));
            var query = new CompileQuery(dep.viewQuery, queryList, null, _this);
            addQueryToTokenMap(viewQueries, query);
          }
        });
      }
      this.viewQueries = viewQueries;
      templateVariableBindings.forEach(function(entry) {
        _this.locals.set(entry[1], THIS_EXPR.prop('context').prop(entry[0]));
      });
      if (!this.declarationElement.isNull()) {
        this.declarationElement.setEmbeddedView(this);
      }
    }
    CompileView.prototype.callPipe = function(name, input, args) {
      return CompilePipe.call(this, name, [input].concat(args));
    };
    CompileView.prototype.getLocal = function(name) {
      if (name == EventHandlerVars.event.name) {
        return EventHandlerVars.event;
      }
      var currView = this;
      var result = currView.locals.get(name);
      while (isBlank(result) && isPresent(currView.declarationElement.view)) {
        currView = currView.declarationElement.view;
        result = currView.locals.get(name);
      }
      if (isPresent(result)) {
        return getPropertyInView(result, this, currView);
      } else {
        return null;
      }
    };
    CompileView.prototype.createLiteralArray = function(values) {
      if (values.length === 0) {
        return importExpr(Identifiers.EMPTY_ARRAY);
      }
      var proxyExpr = THIS_EXPR.prop("_arr_" + this.literalArrayCount++);
      var proxyParams = [];
      var proxyReturnEntries = [];
      for (var i = 0; i < values.length; i++) {
        var paramName = "p" + i;
        proxyParams.push(new FnParam(paramName));
        proxyReturnEntries.push(variable(paramName));
      }
      createPureProxy(fn(proxyParams, [new ReturnStatement(literalArr(proxyReturnEntries))]), values.length, proxyExpr, this);
      return proxyExpr.callFn(values);
    };
    CompileView.prototype.createLiteralMap = function(entries) {
      if (entries.length === 0) {
        return importExpr(Identifiers.EMPTY_MAP);
      }
      var proxyExpr = THIS_EXPR.prop("_map_" + this.literalMapCount++);
      var proxyParams = [];
      var proxyReturnEntries = [];
      var values = [];
      for (var i = 0; i < entries.length; i++) {
        var paramName = "p" + i;
        proxyParams.push(new FnParam(paramName));
        proxyReturnEntries.push([entries[i][0], variable(paramName)]);
        values.push(entries[i][1]);
      }
      createPureProxy(fn(proxyParams, [new ReturnStatement(literalMap(proxyReturnEntries))]), entries.length, proxyExpr, this);
      return proxyExpr.callFn(values);
    };
    CompileView.prototype.afterNodes = function() {
      var _this = this;
      this.pipes.forEach(function(pipe) {
        return pipe.create();
      });
      this.viewQueries.values().forEach(function(queries) {
        return queries.forEach(function(query) {
          return query.afterChildren(_this.updateViewQueriesMethod);
        });
      });
    };
    return CompileView;
  }());
  function getViewType(component, embeddedTemplateIndex) {
    if (embeddedTemplateIndex > 0) {
      return ViewType.EMBEDDED;
    } else if (component.type.isHost) {
      return ViewType.HOST;
    } else {
      return ViewType.COMPONENT;
    }
  }
  var IMPLICIT_TEMPLATE_VAR = '\$implicit';
  var CLASS_ATTR$1 = 'class';
  var STYLE_ATTR = 'style';
  var parentRenderNodeVar = variable('parentRenderNode');
  var rootSelectorVar = variable('rootSelector');
  var ViewCompileDependency = (function() {
    function ViewCompileDependency(comp, factoryPlaceholder) {
      this.comp = comp;
      this.factoryPlaceholder = factoryPlaceholder;
    }
    return ViewCompileDependency;
  }());
  function buildView(view, template, targetDependencies) {
    var builderVisitor = new ViewBuilderVisitor(view, targetDependencies);
    templateVisitAll(builderVisitor, template, view.declarationElement.isNull() ? view.declarationElement : view.declarationElement.parent);
    return builderVisitor.nestedViewCount;
  }
  function finishView(view, targetStatements) {
    view.afterNodes();
    createViewTopLevelStmts(view, targetStatements);
    view.nodes.forEach(function(node) {
      if (node instanceof CompileElement && node.hasEmbeddedView) {
        finishView(node.embeddedView, targetStatements);
      }
    });
  }
  var ViewBuilderVisitor = (function() {
    function ViewBuilderVisitor(view, targetDependencies) {
      this.view = view;
      this.targetDependencies = targetDependencies;
      this.nestedViewCount = 0;
    }
    ViewBuilderVisitor.prototype._isRootNode = function(parent) {
      return parent.view !== this.view;
    };
    ViewBuilderVisitor.prototype._addRootNodeAndProject = function(node, ngContentIndex, parent) {
      var vcAppEl = (node instanceof CompileElement && node.hasViewContainer) ? node.appElement : null;
      if (this._isRootNode(parent)) {
        if (this.view.viewType !== ViewType.COMPONENT) {
          this.view.rootNodesOrAppElements.push(isPresent(vcAppEl) ? vcAppEl : node.renderNode);
        }
      } else if (isPresent(parent.component) && isPresent(ngContentIndex)) {
        parent.addContentNode(ngContentIndex, isPresent(vcAppEl) ? vcAppEl : node.renderNode);
      }
    };
    ViewBuilderVisitor.prototype._getParentRenderNode = function(parent) {
      if (this._isRootNode(parent)) {
        if (this.view.viewType === ViewType.COMPONENT) {
          return parentRenderNodeVar;
        } else {
          return NULL_EXPR;
        }
      } else {
        return isPresent(parent.component) && parent.component.template.encapsulation !== _angular_core.ViewEncapsulation.Native ? NULL_EXPR : parent.renderNode;
      }
    };
    ViewBuilderVisitor.prototype.visitBoundText = function(ast, parent) {
      return this._visitText(ast, '', ast.ngContentIndex, parent);
    };
    ViewBuilderVisitor.prototype.visitText = function(ast, parent) {
      return this._visitText(ast, ast.value, ast.ngContentIndex, parent);
    };
    ViewBuilderVisitor.prototype._visitText = function(ast, value, ngContentIndex, parent) {
      var fieldName = "_text_" + this.view.nodes.length;
      this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderText)));
      var renderNode = THIS_EXPR.prop(fieldName);
      var compileNode = new CompileNode(parent, this.view, this.view.nodes.length, renderNode, ast);
      var createRenderNode = THIS_EXPR.prop(fieldName).set(ViewProperties.renderer.callMethod('createText', [this._getParentRenderNode(parent), literal(value), this.view.createMethod.resetDebugInfoExpr(this.view.nodes.length, ast)])).toStmt();
      this.view.nodes.push(compileNode);
      this.view.createMethod.addStmt(createRenderNode);
      this._addRootNodeAndProject(compileNode, ngContentIndex, parent);
      return renderNode;
    };
    ViewBuilderVisitor.prototype.visitNgContent = function(ast, parent) {
      this.view.createMethod.resetDebugInfo(null, ast);
      var parentRenderNode = this._getParentRenderNode(parent);
      var nodesExpression = ViewProperties.projectableNodes.key(literal(ast.index), new ArrayType(importType(this.view.genConfig.renderTypes.renderNode)));
      if (parentRenderNode !== NULL_EXPR) {
        this.view.createMethod.addStmt(ViewProperties.renderer.callMethod('projectNodes', [parentRenderNode, importExpr(Identifiers.flattenNestedViewRenderNodes).callFn([nodesExpression])]).toStmt());
      } else if (this._isRootNode(parent)) {
        if (this.view.viewType !== ViewType.COMPONENT) {
          this.view.rootNodesOrAppElements.push(nodesExpression);
        }
      } else {
        if (isPresent(parent.component) && isPresent(ast.ngContentIndex)) {
          parent.addContentNode(ast.ngContentIndex, nodesExpression);
        }
      }
      return null;
    };
    ViewBuilderVisitor.prototype.visitElement = function(ast, parent) {
      var nodeIndex = this.view.nodes.length;
      var createRenderNodeExpr;
      var debugContextExpr = this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast);
      if (nodeIndex === 0 && this.view.viewType === ViewType.HOST) {
        createRenderNodeExpr = THIS_EXPR.callMethod('selectOrCreateHostElement', [literal(ast.name), rootSelectorVar, debugContextExpr]);
      } else {
        createRenderNodeExpr = ViewProperties.renderer.callMethod('createElement', [this._getParentRenderNode(parent), literal(ast.name), debugContextExpr]);
      }
      var fieldName = "_el_" + nodeIndex;
      this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderElement)));
      this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName).set(createRenderNodeExpr).toStmt());
      var renderNode = THIS_EXPR.prop(fieldName);
      var directives = ast.directives.map(function(directiveAst) {
        return directiveAst.directive;
      });
      var component = directives.find(function(directive) {
        return directive.isComponent;
      });
      var htmlAttrs = _readHtmlAttrs(ast.attrs);
      var attrNameAndValues = _mergeHtmlAndDirectiveAttrs(htmlAttrs, directives);
      for (var i = 0; i < attrNameAndValues.length; i++) {
        var attrName = attrNameAndValues[i][0];
        var attrValue = attrNameAndValues[i][1];
        this.view.createMethod.addStmt(ViewProperties.renderer.callMethod('setElementAttribute', [renderNode, literal(attrName), literal(attrValue)]).toStmt());
      }
      var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, component, directives, ast.providers, ast.hasViewContainer, false, ast.references);
      this.view.nodes.push(compileElement);
      var compViewExpr = null;
      if (isPresent(component)) {
        var nestedComponentIdentifier = new CompileIdentifierMetadata({name: getViewFactoryName(component, 0)});
        this.targetDependencies.push(new ViewCompileDependency(component, nestedComponentIdentifier));
        compViewExpr = variable("compView_" + nodeIndex);
        compileElement.setComponentView(compViewExpr);
        this.view.createMethod.addStmt(compViewExpr.set(importExpr(nestedComponentIdentifier).callFn([ViewProperties.viewUtils, compileElement.injector, compileElement.appElement])).toDeclStmt());
      }
      compileElement.beforeChildren();
      this._addRootNodeAndProject(compileElement, ast.ngContentIndex, parent);
      templateVisitAll(this, ast.children, compileElement);
      compileElement.afterChildren(this.view.nodes.length - nodeIndex - 1);
      if (isPresent(compViewExpr)) {
        var codeGenContentNodes;
        if (this.view.component.type.isHost) {
          codeGenContentNodes = ViewProperties.projectableNodes;
        } else {
          codeGenContentNodes = literalArr(compileElement.contentNodesByNgContentIndex.map(function(nodes) {
            return createFlatArray(nodes);
          }));
        }
        this.view.createMethod.addStmt(compViewExpr.callMethod('create', [compileElement.getComponent(), codeGenContentNodes, NULL_EXPR]).toStmt());
      }
      return null;
    };
    ViewBuilderVisitor.prototype.visitEmbeddedTemplate = function(ast, parent) {
      var nodeIndex = this.view.nodes.length;
      var fieldName = "_anchor_" + nodeIndex;
      this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderComment)));
      this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName).set(ViewProperties.renderer.callMethod('createTemplateAnchor', [this._getParentRenderNode(parent), this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast)])).toStmt());
      var renderNode = THIS_EXPR.prop(fieldName);
      var templateVariableBindings = ast.variables.map(function(varAst) {
        return [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name];
      });
      var directives = ast.directives.map(function(directiveAst) {
        return directiveAst.directive;
      });
      var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, null, directives, ast.providers, ast.hasViewContainer, true, ast.references);
      this.view.nodes.push(compileElement);
      this.nestedViewCount++;
      var embeddedView = new CompileView(this.view.component, this.view.genConfig, this.view.pipeMetas, NULL_EXPR, this.view.viewIndex + this.nestedViewCount, compileElement, templateVariableBindings);
      this.nestedViewCount += buildView(embeddedView, ast.children, this.targetDependencies);
      compileElement.beforeChildren();
      this._addRootNodeAndProject(compileElement, ast.ngContentIndex, parent);
      compileElement.afterChildren(0);
      return null;
    };
    ViewBuilderVisitor.prototype.visitAttr = function(ast, ctx) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitDirective = function(ast, ctx) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitEvent = function(ast, eventTargetAndNames) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitReference = function(ast, ctx) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitVariable = function(ast, ctx) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitDirectiveProperty = function(ast, context) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitElementProperty = function(ast, context) {
      return null;
    };
    return ViewBuilderVisitor;
  }());
  function _mergeHtmlAndDirectiveAttrs(declaredHtmlAttrs, directives) {
    var result = {};
    StringMapWrapper.forEach(declaredHtmlAttrs, function(value, key) {
      result[key] = value;
    });
    directives.forEach(function(directiveMeta) {
      StringMapWrapper.forEach(directiveMeta.hostAttributes, function(value, name) {
        var prevValue = result[name];
        result[name] = isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
      });
    });
    return mapToKeyValueArray(result);
  }
  function _readHtmlAttrs(attrs) {
    var htmlAttrs = {};
    attrs.forEach(function(ast) {
      htmlAttrs[ast.name] = ast.value;
    });
    return htmlAttrs;
  }
  function mergeAttributeValue(attrName, attrValue1, attrValue2) {
    if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {
      return attrValue1 + " " + attrValue2;
    } else {
      return attrValue2;
    }
  }
  function mapToKeyValueArray(data) {
    var entryArray = [];
    StringMapWrapper.forEach(data, function(value, name) {
      entryArray.push([name, value]);
    });
    ListWrapper.sort(entryArray, function(entry1, entry2) {
      return StringWrapper.compare(entry1[0], entry2[0]);
    });
    var keyValueArray = [];
    entryArray.forEach(function(entry) {
      keyValueArray.push([entry[0], entry[1]]);
    });
    return keyValueArray;
  }
  function createViewTopLevelStmts(view, targetStatements) {
    var nodeDebugInfosVar = NULL_EXPR;
    if (view.genConfig.genDebugInfo) {
      nodeDebugInfosVar = variable("nodeDebugInfos_" + view.component.type.name + view.viewIndex);
      targetStatements.push(nodeDebugInfosVar.set(literalArr(view.nodes.map(createStaticNodeDebugInfo), new ArrayType(new ExternalType(Identifiers.StaticNodeDebugInfo), [TypeModifier.Const]))).toDeclStmt(null, [StmtModifier.Final]));
    }
    var renderCompTypeVar = variable("renderType_" + view.component.type.name);
    if (view.viewIndex === 0) {
      targetStatements.push(renderCompTypeVar.set(NULL_EXPR).toDeclStmt(importType(Identifiers.RenderComponentType)));
    }
    var viewClass = createViewClass(view, renderCompTypeVar, nodeDebugInfosVar);
    targetStatements.push(viewClass);
    targetStatements.push(createViewFactory(view, viewClass, renderCompTypeVar));
  }
  function createStaticNodeDebugInfo(node) {
    var compileElement = node instanceof CompileElement ? node : null;
    var providerTokens = [];
    var componentToken = NULL_EXPR;
    var varTokenEntries = [];
    if (isPresent(compileElement)) {
      providerTokens = compileElement.getProviderTokens();
      if (isPresent(compileElement.component)) {
        componentToken = createDiTokenExpression(identifierToken(compileElement.component.type));
      }
      StringMapWrapper.forEach(compileElement.referenceTokens, function(token, varName) {
        varTokenEntries.push([varName, isPresent(token) ? createDiTokenExpression(token) : NULL_EXPR]);
      });
    }
    return importExpr(Identifiers.StaticNodeDebugInfo).instantiate([literalArr(providerTokens, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])), componentToken, literalMap(varTokenEntries, new MapType(DYNAMIC_TYPE, [TypeModifier.Const]))], importType(Identifiers.StaticNodeDebugInfo, null, [TypeModifier.Const]));
  }
  function createViewClass(view, renderCompTypeVar, nodeDebugInfosVar) {
    var viewConstructorArgs = [new FnParam(ViewConstructorVars.viewUtils.name, importType(Identifiers.ViewUtils)), new FnParam(ViewConstructorVars.parentInjector.name, importType(Identifiers.Injector)), new FnParam(ViewConstructorVars.declarationEl.name, importType(Identifiers.AppElement))];
    var superConstructorArgs = [variable(view.className), renderCompTypeVar, ViewTypeEnum.fromValue(view.viewType), ViewConstructorVars.viewUtils, ViewConstructorVars.parentInjector, ViewConstructorVars.declarationEl, ChangeDetectionStrategyEnum.fromValue(getChangeDetectionMode(view))];
    if (view.genConfig.genDebugInfo) {
      superConstructorArgs.push(nodeDebugInfosVar);
    }
    var viewConstructor = new ClassMethod(null, viewConstructorArgs, [SUPER_EXPR.callFn(superConstructorArgs).toStmt()]);
    var viewMethods = [new ClassMethod('createInternal', [new FnParam(rootSelectorVar.name, STRING_TYPE)], generateCreateMethod(view), importType(Identifiers.AppElement)), new ClassMethod('injectorGetInternal', [new FnParam(InjectMethodVars.token.name, DYNAMIC_TYPE), new FnParam(InjectMethodVars.requestNodeIndex.name, NUMBER_TYPE), new FnParam(InjectMethodVars.notFoundResult.name, DYNAMIC_TYPE)], addReturnValuefNotEmpty(view.injectorGetMethod.finish(), InjectMethodVars.notFoundResult), DYNAMIC_TYPE), new ClassMethod('detectChangesInternal', [new FnParam(DetectChangesVars.throwOnChange.name, BOOL_TYPE)], generateDetectChangesMethod(view)), new ClassMethod('dirtyParentQueriesInternal', [], view.dirtyParentQueriesMethod.finish()), new ClassMethod('destroyInternal', [], view.destroyMethod.finish())].concat(view.eventHandlerMethods);
    var superClass = view.genConfig.genDebugInfo ? Identifiers.DebugAppView : Identifiers.AppView;
    var viewClass = new ClassStmt(view.className, importExpr(superClass, [getContextType(view)]), view.fields, view.getters, viewConstructor, viewMethods.filter(function(method) {
      return method.body.length > 0;
    }));
    return viewClass;
  }
  function createViewFactory(view, viewClass, renderCompTypeVar) {
    var viewFactoryArgs = [new FnParam(ViewConstructorVars.viewUtils.name, importType(Identifiers.ViewUtils)), new FnParam(ViewConstructorVars.parentInjector.name, importType(Identifiers.Injector)), new FnParam(ViewConstructorVars.declarationEl.name, importType(Identifiers.AppElement))];
    var initRenderCompTypeStmts = [];
    var templateUrlInfo;
    if (view.component.template.templateUrl == view.component.type.moduleUrl) {
      templateUrlInfo = view.component.type.moduleUrl + " class " + view.component.type.name + " - inline template";
    } else {
      templateUrlInfo = view.component.template.templateUrl;
    }
    if (view.viewIndex === 0) {
      initRenderCompTypeStmts = [new IfStmt(renderCompTypeVar.identical(NULL_EXPR), [renderCompTypeVar.set(ViewConstructorVars.viewUtils.callMethod('createRenderComponentType', [literal(templateUrlInfo), literal(view.component.template.ngContentSelectors.length), ViewEncapsulationEnum.fromValue(view.component.template.encapsulation), view.styles])).toStmt()])];
    }
    return fn(viewFactoryArgs, initRenderCompTypeStmts.concat([new ReturnStatement(variable(viewClass.name).instantiate(viewClass.constructorMethod.params.map(function(param) {
      return variable(param.name);
    })))]), importType(Identifiers.AppView, [getContextType(view)])).toDeclStmt(view.viewFactory.name, [StmtModifier.Final]);
  }
  function generateCreateMethod(view) {
    var parentRenderNodeExpr = NULL_EXPR;
    var parentRenderNodeStmts = [];
    if (view.viewType === ViewType.COMPONENT) {
      parentRenderNodeExpr = ViewProperties.renderer.callMethod('createViewRoot', [THIS_EXPR.prop('declarationAppElement').prop('nativeElement')]);
      parentRenderNodeStmts = [parentRenderNodeVar.set(parentRenderNodeExpr).toDeclStmt(importType(view.genConfig.renderTypes.renderNode), [StmtModifier.Final])];
    }
    var resultExpr;
    if (view.viewType === ViewType.HOST) {
      resultExpr = view.nodes[0].appElement;
    } else {
      resultExpr = NULL_EXPR;
    }
    return parentRenderNodeStmts.concat(view.createMethod.finish()).concat([THIS_EXPR.callMethod('init', [createFlatArray(view.rootNodesOrAppElements), literalArr(view.nodes.map(function(node) {
      return node.renderNode;
    })), literalArr(view.disposables), literalArr(view.subscriptions)]).toStmt(), new ReturnStatement(resultExpr)]);
  }
  function generateDetectChangesMethod(view) {
    var stmts = [];
    if (view.detectChangesInInputsMethod.isEmpty() && view.updateContentQueriesMethod.isEmpty() && view.afterContentLifecycleCallbacksMethod.isEmpty() && view.detectChangesRenderPropertiesMethod.isEmpty() && view.updateViewQueriesMethod.isEmpty() && view.afterViewLifecycleCallbacksMethod.isEmpty()) {
      return stmts;
    }
    ListWrapper.addAll(stmts, view.detectChangesInInputsMethod.finish());
    stmts.push(THIS_EXPR.callMethod('detectContentChildrenChanges', [DetectChangesVars.throwOnChange]).toStmt());
    var afterContentStmts = view.updateContentQueriesMethod.finish().concat(view.afterContentLifecycleCallbacksMethod.finish());
    if (afterContentStmts.length > 0) {
      stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterContentStmts));
    }
    ListWrapper.addAll(stmts, view.detectChangesRenderPropertiesMethod.finish());
    stmts.push(THIS_EXPR.callMethod('detectViewChildrenChanges', [DetectChangesVars.throwOnChange]).toStmt());
    var afterViewStmts = view.updateViewQueriesMethod.finish().concat(view.afterViewLifecycleCallbacksMethod.finish());
    if (afterViewStmts.length > 0) {
      stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterViewStmts));
    }
    var varStmts = [];
    var readVars = findReadVarNames(stmts);
    if (SetWrapper.has(readVars, DetectChangesVars.changed.name)) {
      varStmts.push(DetectChangesVars.changed.set(literal(true)).toDeclStmt(BOOL_TYPE));
    }
    if (SetWrapper.has(readVars, DetectChangesVars.changes.name)) {
      varStmts.push(DetectChangesVars.changes.set(NULL_EXPR).toDeclStmt(new MapType(importType(Identifiers.SimpleChange))));
    }
    if (SetWrapper.has(readVars, DetectChangesVars.valUnwrapper.name)) {
      varStmts.push(DetectChangesVars.valUnwrapper.set(importExpr(Identifiers.ValueUnwrapper).instantiate([])).toDeclStmt(null, [StmtModifier.Final]));
    }
    return varStmts.concat(stmts);
  }
  function addReturnValuefNotEmpty(statements, value) {
    if (statements.length > 0) {
      return statements.concat([new ReturnStatement(value)]);
    } else {
      return statements;
    }
  }
  function getContextType(view) {
    if (view.viewType === ViewType.COMPONENT) {
      return importType(view.component.type);
    }
    return DYNAMIC_TYPE;
  }
  function getChangeDetectionMode(view) {
    var mode;
    if (view.viewType === ViewType.COMPONENT) {
      mode = isDefaultChangeDetectionStrategy(view.component.changeDetection) ? _angular_core.ChangeDetectionStrategy.CheckAlways : _angular_core.ChangeDetectionStrategy.CheckOnce;
    } else {
      mode = _angular_core.ChangeDetectionStrategy.CheckAlways;
    }
    return mode;
  }
  var IMPLICIT_RECEIVER = variable('#implicit');
  var ExpressionWithWrappedValueInfo = (function() {
    function ExpressionWithWrappedValueInfo(expression, needsValueUnwrapper) {
      this.expression = expression;
      this.needsValueUnwrapper = needsValueUnwrapper;
    }
    return ExpressionWithWrappedValueInfo;
  }());
  function convertCdExpressionToIr(nameResolver, implicitReceiver, expression, valueUnwrapper) {
    var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, valueUnwrapper);
    var irAst = expression.visit(visitor, _Mode.Expression);
    return new ExpressionWithWrappedValueInfo(irAst, visitor.needsValueUnwrapper);
  }
  function convertCdStatementToIr(nameResolver, implicitReceiver, stmt) {
    var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, null);
    var statements = [];
    flattenStatements(stmt.visit(visitor, _Mode.Statement), statements);
    return statements;
  }
  var _Mode;
  (function(_Mode) {
    _Mode[_Mode["Statement"] = 0] = "Statement";
    _Mode[_Mode["Expression"] = 1] = "Expression";
  })(_Mode || (_Mode = {}));
  function ensureStatementMode(mode, ast) {
    if (mode !== _Mode.Statement) {
      throw new BaseException$1("Expected a statement, but saw " + ast);
    }
  }
  function ensureExpressionMode(mode, ast) {
    if (mode !== _Mode.Expression) {
      throw new BaseException$1("Expected an expression, but saw " + ast);
    }
  }
  function convertToStatementIfNeeded(mode, expr) {
    if (mode === _Mode.Statement) {
      return expr.toStmt();
    } else {
      return expr;
    }
  }
  var _AstToIrVisitor = (function() {
    function _AstToIrVisitor(_nameResolver, _implicitReceiver, _valueUnwrapper) {
      this._nameResolver = _nameResolver;
      this._implicitReceiver = _implicitReceiver;
      this._valueUnwrapper = _valueUnwrapper;
      this.needsValueUnwrapper = false;
    }
    _AstToIrVisitor.prototype.visitBinary = function(ast, mode) {
      var op;
      switch (ast.operation) {
        case '+':
          op = BinaryOperator.Plus;
          break;
        case '-':
          op = BinaryOperator.Minus;
          break;
        case '*':
          op = BinaryOperator.Multiply;
          break;
        case '/':
          op = BinaryOperator.Divide;
          break;
        case '%':
          op = BinaryOperator.Modulo;
          break;
        case '&&':
          op = BinaryOperator.And;
          break;
        case '||':
          op = BinaryOperator.Or;
          break;
        case '==':
          op = BinaryOperator.Equals;
          break;
        case '!=':
          op = BinaryOperator.NotEquals;
          break;
        case '===':
          op = BinaryOperator.Identical;
          break;
        case '!==':
          op = BinaryOperator.NotIdentical;
          break;
        case '<':
          op = BinaryOperator.Lower;
          break;
        case '>':
          op = BinaryOperator.Bigger;
          break;
        case '<=':
          op = BinaryOperator.LowerEquals;
          break;
        case '>=':
          op = BinaryOperator.BiggerEquals;
          break;
        default:
          throw new BaseException$1("Unsupported operation " + ast.operation);
      }
      return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, ast.left.visit(this, _Mode.Expression), ast.right.visit(this, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitChain = function(ast, mode) {
      ensureStatementMode(mode, ast);
      return this.visitAll(ast.expressions, mode);
    };
    _AstToIrVisitor.prototype.visitConditional = function(ast, mode) {
      var value = ast.condition.visit(this, _Mode.Expression);
      return convertToStatementIfNeeded(mode, value.conditional(ast.trueExp.visit(this, _Mode.Expression), ast.falseExp.visit(this, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitPipe = function(ast, mode) {
      var input = ast.exp.visit(this, _Mode.Expression);
      var args = this.visitAll(ast.args, _Mode.Expression);
      var value = this._nameResolver.callPipe(ast.name, input, args);
      this.needsValueUnwrapper = true;
      return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));
    };
    _AstToIrVisitor.prototype.visitFunctionCall = function(ast, mode) {
      return convertToStatementIfNeeded(mode, ast.target.visit(this, _Mode.Expression).callFn(this.visitAll(ast.args, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitImplicitReceiver = function(ast, mode) {
      ensureExpressionMode(mode, ast);
      return IMPLICIT_RECEIVER;
    };
    _AstToIrVisitor.prototype.visitInterpolation = function(ast, mode) {
      ensureExpressionMode(mode, ast);
      var args = [literal(ast.expressions.length)];
      for (var i = 0; i < ast.strings.length - 1; i++) {
        args.push(literal(ast.strings[i]));
        args.push(ast.expressions[i].visit(this, _Mode.Expression));
      }
      args.push(literal(ast.strings[ast.strings.length - 1]));
      return importExpr(Identifiers.interpolate).callFn(args);
    };
    _AstToIrVisitor.prototype.visitKeyedRead = function(ast, mode) {
      return convertToStatementIfNeeded(mode, ast.obj.visit(this, _Mode.Expression).key(ast.key.visit(this, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitKeyedWrite = function(ast, mode) {
      var obj = ast.obj.visit(this, _Mode.Expression);
      var key = ast.key.visit(this, _Mode.Expression);
      var value = ast.value.visit(this, _Mode.Expression);
      return convertToStatementIfNeeded(mode, obj.key(key).set(value));
    };
    _AstToIrVisitor.prototype.visitLiteralArray = function(ast, mode) {
      return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralArray(this.visitAll(ast.expressions, mode)));
    };
    _AstToIrVisitor.prototype.visitLiteralMap = function(ast, mode) {
      var parts = [];
      for (var i = 0; i < ast.keys.length; i++) {
        parts.push([ast.keys[i], ast.values[i].visit(this, _Mode.Expression)]);
      }
      return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralMap(parts));
    };
    _AstToIrVisitor.prototype.visitLiteralPrimitive = function(ast, mode) {
      return convertToStatementIfNeeded(mode, literal(ast.value));
    };
    _AstToIrVisitor.prototype.visitMethodCall = function(ast, mode) {
      var args = this.visitAll(ast.args, _Mode.Expression);
      var result = null;
      var receiver = ast.receiver.visit(this, _Mode.Expression);
      if (receiver === IMPLICIT_RECEIVER) {
        var varExpr = this._nameResolver.getLocal(ast.name);
        if (isPresent(varExpr)) {
          result = varExpr.callFn(args);
        } else {
          receiver = this._implicitReceiver;
        }
      }
      if (isBlank(result)) {
        result = receiver.callMethod(ast.name, args);
      }
      return convertToStatementIfNeeded(mode, result);
    };
    _AstToIrVisitor.prototype.visitPrefixNot = function(ast, mode) {
      return convertToStatementIfNeeded(mode, not(ast.expression.visit(this, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitPropertyRead = function(ast, mode) {
      var result = null;
      var receiver = ast.receiver.visit(this, _Mode.Expression);
      if (receiver === IMPLICIT_RECEIVER) {
        result = this._nameResolver.getLocal(ast.name);
        if (isBlank(result)) {
          receiver = this._implicitReceiver;
        }
      }
      if (isBlank(result)) {
        result = receiver.prop(ast.name);
      }
      return convertToStatementIfNeeded(mode, result);
    };
    _AstToIrVisitor.prototype.visitPropertyWrite = function(ast, mode) {
      var receiver = ast.receiver.visit(this, _Mode.Expression);
      if (receiver === IMPLICIT_RECEIVER) {
        var varExpr = this._nameResolver.getLocal(ast.name);
        if (isPresent(varExpr)) {
          throw new BaseException$1('Cannot assign to a reference or variable!');
        }
        receiver = this._implicitReceiver;
      }
      return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(ast.value.visit(this, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitSafePropertyRead = function(ast, mode) {
      var receiver = ast.receiver.visit(this, _Mode.Expression);
      return convertToStatementIfNeeded(mode, receiver.isBlank().conditional(NULL_EXPR, receiver.prop(ast.name)));
    };
    _AstToIrVisitor.prototype.visitSafeMethodCall = function(ast, mode) {
      var receiver = ast.receiver.visit(this, _Mode.Expression);
      var args = this.visitAll(ast.args, _Mode.Expression);
      return convertToStatementIfNeeded(mode, receiver.isBlank().conditional(NULL_EXPR, receiver.callMethod(ast.name, args)));
    };
    _AstToIrVisitor.prototype.visitAll = function(asts, mode) {
      var _this = this;
      return asts.map(function(ast) {
        return ast.visit(_this, mode);
      });
    };
    _AstToIrVisitor.prototype.visitQuote = function(ast, mode) {
      throw new BaseException$1('Quotes are not supported for evaluation!');
    };
    return _AstToIrVisitor;
  }());
  function flattenStatements(arg, output) {
    if (isArray(arg)) {
      arg.forEach(function(entry) {
        return flattenStatements(entry, output);
      });
    } else {
      output.push(arg);
    }
  }
  var CompileBinding = (function() {
    function CompileBinding(node, sourceAst) {
      this.node = node;
      this.sourceAst = sourceAst;
    }
    return CompileBinding;
  }());
  function createBindFieldExpr(exprIndex) {
    return THIS_EXPR.prop("_expr_" + exprIndex);
  }
  function createCurrValueExpr(exprIndex) {
    return variable("currVal_" + exprIndex);
  }
  function bind(view, currValExpr, fieldExpr, parsedExpression, context, actions, method) {
    var checkExpression = convertCdExpressionToIr(view, context, parsedExpression, DetectChangesVars.valUnwrapper);
    if (isBlank(checkExpression.expression)) {
      return;
    }
    view.fields.push(new ClassField(fieldExpr.name, null, [StmtModifier.Private]));
    view.createMethod.addStmt(THIS_EXPR.prop(fieldExpr.name).set(importExpr(Identifiers.uninitialized)).toStmt());
    if (checkExpression.needsValueUnwrapper) {
      var initValueUnwrapperStmt = DetectChangesVars.valUnwrapper.callMethod('reset', []).toStmt();
      method.addStmt(initValueUnwrapperStmt);
    }
    method.addStmt(currValExpr.set(checkExpression.expression).toDeclStmt(null, [StmtModifier.Final]));
    var condition = importExpr(Identifiers.checkBinding).callFn([DetectChangesVars.throwOnChange, fieldExpr, currValExpr]);
    if (checkExpression.needsValueUnwrapper) {
      condition = DetectChangesVars.valUnwrapper.prop('hasWrappedValue').or(condition);
    }
    method.addStmt(new IfStmt(condition, actions.concat([THIS_EXPR.prop(fieldExpr.name).set(currValExpr).toStmt()])));
  }
  function bindRenderText(boundText, compileNode, view) {
    var bindingIndex = view.bindings.length;
    view.bindings.push(new CompileBinding(compileNode, boundText));
    var currValExpr = createCurrValueExpr(bindingIndex);
    var valueField = createBindFieldExpr(bindingIndex);
    view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);
    bind(view, currValExpr, valueField, boundText.value, view.componentContext, [THIS_EXPR.prop('renderer').callMethod('setText', [compileNode.renderNode, currValExpr]).toStmt()], view.detectChangesRenderPropertiesMethod);
  }
  function bindAndWriteToRenderer(boundProps, context, compileElement) {
    var view = compileElement.view;
    var renderNode = compileElement.renderNode;
    boundProps.forEach(function(boundProp) {
      var bindingIndex = view.bindings.length;
      view.bindings.push(new CompileBinding(compileElement, boundProp));
      view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);
      var fieldExpr = createBindFieldExpr(bindingIndex);
      var currValExpr = createCurrValueExpr(bindingIndex);
      var renderMethod;
      var renderValue = sanitizedValue(boundProp, currValExpr);
      var updateStmts = [];
      switch (boundProp.type) {
        case exports.PropertyBindingType.Property:
          renderMethod = 'setElementProperty';
          if (view.genConfig.logBindingUpdate) {
            updateStmts.push(logBindingUpdateStmt(renderNode, boundProp.name, currValExpr));
          }
          break;
        case exports.PropertyBindingType.Attribute:
          renderMethod = 'setElementAttribute';
          renderValue = renderValue.isBlank().conditional(NULL_EXPR, renderValue.callMethod('toString', []));
          break;
        case exports.PropertyBindingType.Class:
          renderMethod = 'setElementClass';
          break;
        case exports.PropertyBindingType.Style:
          renderMethod = 'setElementStyle';
          var strValue = renderValue.callMethod('toString', []);
          if (isPresent(boundProp.unit)) {
            strValue = strValue.plus(literal(boundProp.unit));
          }
          renderValue = renderValue.isBlank().conditional(NULL_EXPR, strValue);
          break;
      }
      updateStmts.push(THIS_EXPR.prop('renderer').callMethod(renderMethod, [renderNode, literal(boundProp.name), renderValue]).toStmt());
      bind(view, currValExpr, fieldExpr, boundProp.value, context, updateStmts, view.detectChangesRenderPropertiesMethod);
    });
  }
  function sanitizedValue(boundProp, renderValue) {
    var enumValue;
    switch (boundProp.securityContext) {
      case SecurityContext.NONE:
        return renderValue;
      case SecurityContext.HTML:
        enumValue = 'HTML';
        break;
      case SecurityContext.STYLE:
        enumValue = 'STYLE';
        break;
      case SecurityContext.SCRIPT:
        enumValue = 'SCRIPT';
        break;
      case SecurityContext.URL:
        enumValue = 'URL';
        break;
      case SecurityContext.RESOURCE_URL:
        enumValue = 'RESOURCE_URL';
        break;
      default:
        throw new Error("internal error, unexpected SecurityContext " + boundProp.securityContext + ".");
    }
    var ctx = ViewProperties.viewUtils.prop('sanitizer');
    var args = [importExpr(Identifiers.SecurityContext).prop(enumValue), renderValue];
    return ctx.callMethod('sanitize', args);
  }
  function bindRenderInputs(boundProps, compileElement) {
    bindAndWriteToRenderer(boundProps, compileElement.view.componentContext, compileElement);
  }
  function bindDirectiveHostProps(directiveAst, directiveInstance, compileElement) {
    bindAndWriteToRenderer(directiveAst.hostProperties, directiveInstance, compileElement);
  }
  function bindDirectiveInputs(directiveAst, directiveInstance, compileElement) {
    if (directiveAst.inputs.length === 0) {
      return;
    }
    var view = compileElement.view;
    var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
    detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    var lifecycleHooks = directiveAst.directive.lifecycleHooks;
    var calcChangesMap = lifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1;
    var isOnPushComp = directiveAst.directive.isComponent && !isDefaultChangeDetectionStrategy(directiveAst.directive.changeDetection);
    if (calcChangesMap) {
      detectChangesInInputsMethod.addStmt(DetectChangesVars.changes.set(NULL_EXPR).toStmt());
    }
    if (isOnPushComp) {
      detectChangesInInputsMethod.addStmt(DetectChangesVars.changed.set(literal(false)).toStmt());
    }
    directiveAst.inputs.forEach(function(input) {
      var bindingIndex = view.bindings.length;
      view.bindings.push(new CompileBinding(compileElement, input));
      detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);
      var fieldExpr = createBindFieldExpr(bindingIndex);
      var currValExpr = createCurrValueExpr(bindingIndex);
      var statements = [directiveInstance.prop(input.directiveName).set(currValExpr).toStmt()];
      if (calcChangesMap) {
        statements.push(new IfStmt(DetectChangesVars.changes.identical(NULL_EXPR), [DetectChangesVars.changes.set(literalMap([], new MapType(importType(Identifiers.SimpleChange)))).toStmt()]));
        statements.push(DetectChangesVars.changes.key(literal(input.directiveName)).set(importExpr(Identifiers.SimpleChange).instantiate([fieldExpr, currValExpr])).toStmt());
      }
      if (isOnPushComp) {
        statements.push(DetectChangesVars.changed.set(literal(true)).toStmt());
      }
      if (view.genConfig.logBindingUpdate) {
        statements.push(logBindingUpdateStmt(compileElement.renderNode, input.directiveName, currValExpr));
      }
      bind(view, currValExpr, fieldExpr, input.value, view.componentContext, statements, detectChangesInInputsMethod);
    });
    if (isOnPushComp) {
      detectChangesInInputsMethod.addStmt(new IfStmt(DetectChangesVars.changed, [compileElement.appElement.prop('componentView').callMethod('markAsCheckOnce', []).toStmt()]));
    }
  }
  function logBindingUpdateStmt(renderNode, propName, value) {
    return THIS_EXPR.prop('renderer').callMethod('setBindingDebugInfo', [renderNode, literal("ng-reflect-" + camelCaseToDashCase(propName)), value.isBlank().conditional(NULL_EXPR, value.callMethod('toString', []))]).toStmt();
  }
  var CompileEventListener = (function() {
    function CompileEventListener(compileElement, eventTarget, eventName, listenerIndex) {
      this.compileElement = compileElement;
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this._hasComponentHostListener = false;
      this._actionResultExprs = [];
      this._method = new CompileMethod(compileElement.view);
      this._methodName = "_handle_" + santitizeEventName(eventName) + "_" + compileElement.nodeIndex + "_" + listenerIndex;
      this._eventParam = new FnParam(EventHandlerVars.event.name, importType(this.compileElement.view.genConfig.renderTypes.renderEvent));
    }
    CompileEventListener.getOrCreate = function(compileElement, eventTarget, eventName, targetEventListeners) {
      var listener = targetEventListeners.find(function(listener) {
        return listener.eventTarget == eventTarget && listener.eventName == eventName;
      });
      if (isBlank(listener)) {
        listener = new CompileEventListener(compileElement, eventTarget, eventName, targetEventListeners.length);
        targetEventListeners.push(listener);
      }
      return listener;
    };
    CompileEventListener.prototype.addAction = function(hostEvent, directive, directiveInstance) {
      if (isPresent(directive) && directive.isComponent) {
        this._hasComponentHostListener = true;
      }
      this._method.resetDebugInfo(this.compileElement.nodeIndex, hostEvent);
      var context = isPresent(directiveInstance) ? directiveInstance : this.compileElement.view.componentContext;
      var actionStmts = convertCdStatementToIr(this.compileElement.view, context, hostEvent.handler);
      var lastIndex = actionStmts.length - 1;
      if (lastIndex >= 0) {
        var lastStatement = actionStmts[lastIndex];
        var returnExpr = convertStmtIntoExpression(lastStatement);
        var preventDefaultVar = variable("pd_" + this._actionResultExprs.length);
        this._actionResultExprs.push(preventDefaultVar);
        if (isPresent(returnExpr)) {
          actionStmts[lastIndex] = preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false))).toDeclStmt(null, [StmtModifier.Final]);
        }
      }
      this._method.addStmts(actionStmts);
    };
    CompileEventListener.prototype.finishMethod = function() {
      var markPathToRootStart = this._hasComponentHostListener ? this.compileElement.appElement.prop('componentView') : THIS_EXPR;
      var resultExpr = literal(true);
      this._actionResultExprs.forEach(function(expr) {
        resultExpr = resultExpr.and(expr);
      });
      var stmts = [markPathToRootStart.callMethod('markPathToRootAsCheckOnce', []).toStmt()].concat(this._method.finish()).concat([new ReturnStatement(resultExpr)]);
      this.compileElement.view.eventHandlerMethods.push(new ClassMethod(this._methodName, [this._eventParam], stmts, BOOL_TYPE, [StmtModifier.Private]));
    };
    CompileEventListener.prototype.listenToRenderer = function() {
      var listenExpr;
      var eventListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.bind, [THIS_EXPR])]);
      if (isPresent(this.eventTarget)) {
        listenExpr = ViewProperties.renderer.callMethod('listenGlobal', [literal(this.eventTarget), literal(this.eventName), eventListener]);
      } else {
        listenExpr = ViewProperties.renderer.callMethod('listen', [this.compileElement.renderNode, literal(this.eventName), eventListener]);
      }
      var disposable = variable("disposable_" + this.compileElement.view.disposables.length);
      this.compileElement.view.disposables.push(disposable);
      this.compileElement.view.createMethod.addStmt(disposable.set(listenExpr).toDeclStmt(FUNCTION_TYPE, [StmtModifier.Private]));
    };
    CompileEventListener.prototype.listenToDirective = function(directiveInstance, observablePropName) {
      var subscription = variable("subscription_" + this.compileElement.view.subscriptions.length);
      this.compileElement.view.subscriptions.push(subscription);
      var eventListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.bind, [THIS_EXPR])]);
      this.compileElement.view.createMethod.addStmt(subscription.set(directiveInstance.prop(observablePropName).callMethod(BuiltinMethod.SubscribeObservable, [eventListener])).toDeclStmt(null, [StmtModifier.Final]));
    };
    return CompileEventListener;
  }());
  function collectEventListeners(hostEvents, dirs, compileElement) {
    var eventListeners = [];
    hostEvents.forEach(function(hostEvent) {
      compileElement.view.bindings.push(new CompileBinding(compileElement, hostEvent));
      var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, eventListeners);
      listener.addAction(hostEvent, null, null);
    });
    ListWrapper.forEachWithIndex(dirs, function(directiveAst, i) {
      var directiveInstance = compileElement.directiveInstances[i];
      directiveAst.hostEvents.forEach(function(hostEvent) {
        compileElement.view.bindings.push(new CompileBinding(compileElement, hostEvent));
        var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, eventListeners);
        listener.addAction(hostEvent, directiveAst.directive, directiveInstance);
      });
    });
    eventListeners.forEach(function(listener) {
      return listener.finishMethod();
    });
    return eventListeners;
  }
  function bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners) {
    StringMapWrapper.forEach(directiveAst.directive.outputs, function(eventName, observablePropName) {
      eventListeners.filter(function(listener) {
        return listener.eventName == eventName;
      }).forEach(function(listener) {
        listener.listenToDirective(directiveInstance, observablePropName);
      });
    });
  }
  function bindRenderOutputs(eventListeners) {
    eventListeners.forEach(function(listener) {
      return listener.listenToRenderer();
    });
  }
  function convertStmtIntoExpression(stmt) {
    if (stmt instanceof ExpressionStatement) {
      return stmt.expr;
    } else if (stmt instanceof ReturnStatement) {
      return stmt.value;
    }
    return null;
  }
  function santitizeEventName(name) {
    return StringWrapper.replaceAll(name, /[^a-zA-Z_]/g, '_');
  }
  var STATE_IS_NEVER_CHECKED = THIS_EXPR.prop('cdState').identical(ChangeDetectorStateEnum.NeverChecked);
  var NOT_THROW_ON_CHANGES = not(DetectChangesVars.throwOnChange);
  function bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement) {
    var view = compileElement.view;
    var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
    var lifecycleHooks = directiveAst.directive.lifecycleHooks;
    if (lifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1 && directiveAst.inputs.length > 0) {
      detectChangesInInputsMethod.addStmt(new IfStmt(DetectChangesVars.changes.notIdentical(NULL_EXPR), [directiveInstance.callMethod('ngOnChanges', [DetectChangesVars.changes]).toStmt()]));
    }
    if (lifecycleHooks.indexOf(LifecycleHooks.OnInit) !== -1) {
      detectChangesInInputsMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED.and(NOT_THROW_ON_CHANGES), [directiveInstance.callMethod('ngOnInit', []).toStmt()]));
    }
    if (lifecycleHooks.indexOf(LifecycleHooks.DoCheck) !== -1) {
      detectChangesInInputsMethod.addStmt(new IfStmt(NOT_THROW_ON_CHANGES, [directiveInstance.callMethod('ngDoCheck', []).toStmt()]));
    }
  }
  function bindDirectiveAfterContentLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
    var view = compileElement.view;
    var lifecycleHooks = directiveMeta.lifecycleHooks;
    var afterContentLifecycleCallbacksMethod = view.afterContentLifecycleCallbacksMethod;
    afterContentLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentInit) !== -1) {
      afterContentLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterContentInit', []).toStmt()]));
    }
    if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentChecked) !== -1) {
      afterContentLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterContentChecked', []).toStmt());
    }
  }
  function bindDirectiveAfterViewLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
    var view = compileElement.view;
    var lifecycleHooks = directiveMeta.lifecycleHooks;
    var afterViewLifecycleCallbacksMethod = view.afterViewLifecycleCallbacksMethod;
    afterViewLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewInit) !== -1) {
      afterViewLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterViewInit', []).toStmt()]));
    }
    if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewChecked) !== -1) {
      afterViewLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterViewChecked', []).toStmt());
    }
  }
  function bindDirectiveDestroyLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
    var onDestroyMethod = compileElement.view.destroyMethod;
    onDestroyMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    if (directiveMeta.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
      onDestroyMethod.addStmt(directiveInstance.callMethod('ngOnDestroy', []).toStmt());
    }
  }
  function bindPipeDestroyLifecycleCallbacks(pipeMeta, pipeInstance, view) {
    var onDestroyMethod = view.destroyMethod;
    if (pipeMeta.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
      onDestroyMethod.addStmt(pipeInstance.callMethod('ngOnDestroy', []).toStmt());
    }
  }
  function bindView(view, parsedTemplate) {
    var visitor = new ViewBinderVisitor(view);
    templateVisitAll(visitor, parsedTemplate);
    view.pipes.forEach(function(pipe) {
      bindPipeDestroyLifecycleCallbacks(pipe.meta, pipe.instance, pipe.view);
    });
  }
  var ViewBinderVisitor = (function() {
    function ViewBinderVisitor(view) {
      this.view = view;
      this._nodeIndex = 0;
    }
    ViewBinderVisitor.prototype.visitBoundText = function(ast, parent) {
      var node = this.view.nodes[this._nodeIndex++];
      bindRenderText(ast, node, this.view);
      return null;
    };
    ViewBinderVisitor.prototype.visitText = function(ast, parent) {
      this._nodeIndex++;
      return null;
    };
    ViewBinderVisitor.prototype.visitNgContent = function(ast, parent) {
      return null;
    };
    ViewBinderVisitor.prototype.visitElement = function(ast, parent) {
      var compileElement = this.view.nodes[this._nodeIndex++];
      var eventListeners = collectEventListeners(ast.outputs, ast.directives, compileElement);
      bindRenderInputs(ast.inputs, compileElement);
      bindRenderOutputs(eventListeners);
      ListWrapper.forEachWithIndex(ast.directives, function(directiveAst, index) {
        var directiveInstance = compileElement.directiveInstances[index];
        bindDirectiveInputs(directiveAst, directiveInstance, compileElement);
        bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement);
        bindDirectiveHostProps(directiveAst, directiveInstance, compileElement);
        bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
      });
      templateVisitAll(this, ast.children, compileElement);
      ListWrapper.forEachWithIndex(ast.directives, function(directiveAst, index) {
        var directiveInstance = compileElement.directiveInstances[index];
        bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
        bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
        bindDirectiveDestroyLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
      });
      return null;
    };
    ViewBinderVisitor.prototype.visitEmbeddedTemplate = function(ast, parent) {
      var compileElement = this.view.nodes[this._nodeIndex++];
      var eventListeners = collectEventListeners(ast.outputs, ast.directives, compileElement);
      ListWrapper.forEachWithIndex(ast.directives, function(directiveAst, index) {
        var directiveInstance = compileElement.directiveInstances[index];
        bindDirectiveInputs(directiveAst, directiveInstance, compileElement);
        bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement);
        bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
        bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
        bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
        bindDirectiveDestroyLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
      });
      bindView(compileElement.embeddedView, ast.children);
      return null;
    };
    ViewBinderVisitor.prototype.visitAttr = function(ast, ctx) {
      return null;
    };
    ViewBinderVisitor.prototype.visitDirective = function(ast, ctx) {
      return null;
    };
    ViewBinderVisitor.prototype.visitEvent = function(ast, eventTargetAndNames) {
      return null;
    };
    ViewBinderVisitor.prototype.visitReference = function(ast, ctx) {
      return null;
    };
    ViewBinderVisitor.prototype.visitVariable = function(ast, ctx) {
      return null;
    };
    ViewBinderVisitor.prototype.visitDirectiveProperty = function(ast, context) {
      return null;
    };
    ViewBinderVisitor.prototype.visitElementProperty = function(ast, context) {
      return null;
    };
    return ViewBinderVisitor;
  }());
  var ViewCompileResult = (function() {
    function ViewCompileResult(statements, viewFactoryVar, dependencies) {
      this.statements = statements;
      this.viewFactoryVar = viewFactoryVar;
      this.dependencies = dependencies;
    }
    return ViewCompileResult;
  }());
  var ViewCompiler = (function() {
    function ViewCompiler(_genConfig) {
      this._genConfig = _genConfig;
    }
    ViewCompiler.prototype.compileComponent = function(component, template, styles, pipes) {
      var statements = [];
      var dependencies = [];
      var view = new CompileView(component, this._genConfig, pipes, styles, 0, CompileElement.createNull(), []);
      buildView(view, template, dependencies);
      bindView(view, template);
      finishView(view, statements);
      return new ViewCompileResult(statements, view.viewFactory.name, dependencies);
    };
    return ViewCompiler;
  }());
  ViewCompiler.decorators = [{type: _angular_core.Injectable}];
  ViewCompiler.ctorParameters = [{type: CompilerConfig}];
  var XHR = (function() {
    function XHR() {}
    XHR.prototype.get = function(url) {
      return null;
    };
    return XHR;
  }());
  var DirectiveNormalizer = (function() {
    function DirectiveNormalizer(_xhr, _urlResolver, _htmlParser) {
      this._xhr = _xhr;
      this._urlResolver = _urlResolver;
      this._htmlParser = _htmlParser;
    }
    DirectiveNormalizer.prototype.normalizeDirective = function(directive) {
      if (!directive.isComponent) {
        return PromiseWrapper.resolve(directive);
      }
      return this.normalizeTemplate(directive.type, directive.template).then(function(normalizedTemplate) {
        return new CompileDirectiveMetadata({
          type: directive.type,
          isComponent: directive.isComponent,
          selector: directive.selector,
          exportAs: directive.exportAs,
          changeDetection: directive.changeDetection,
          inputs: directive.inputs,
          outputs: directive.outputs,
          hostListeners: directive.hostListeners,
          hostProperties: directive.hostProperties,
          hostAttributes: directive.hostAttributes,
          lifecycleHooks: directive.lifecycleHooks,
          providers: directive.providers,
          viewProviders: directive.viewProviders,
          queries: directive.queries,
          viewQueries: directive.viewQueries,
          template: normalizedTemplate
        });
      });
    };
    DirectiveNormalizer.prototype.normalizeTemplate = function(directiveType, template) {
      var _this = this;
      if (isPresent(template.template)) {
        return PromiseWrapper.resolve(this.normalizeLoadedTemplate(directiveType, template, template.template, directiveType.moduleUrl));
      } else if (isPresent(template.templateUrl)) {
        var sourceAbsUrl = this._urlResolver.resolve(directiveType.moduleUrl, template.templateUrl);
        return this._xhr.get(sourceAbsUrl).then(function(templateContent) {
          return _this.normalizeLoadedTemplate(directiveType, template, templateContent, sourceAbsUrl);
        });
      } else {
        throw new BaseException$1("No template specified for component " + directiveType.name);
      }
    };
    DirectiveNormalizer.prototype.normalizeLoadedTemplate = function(directiveType, templateMeta, template, templateAbsUrl) {
      var _this = this;
      var rootNodesAndErrors = this._htmlParser.parse(template, directiveType.name);
      if (rootNodesAndErrors.errors.length > 0) {
        var errorString = rootNodesAndErrors.errors.join('\n');
        throw new BaseException$1("Template parse errors:\n" + errorString);
      }
      var visitor = new TemplatePreparseVisitor();
      htmlVisitAll(visitor, rootNodesAndErrors.rootNodes);
      var allStyles = templateMeta.styles.concat(visitor.styles);
      var allStyleAbsUrls = visitor.styleUrls.filter(isStyleUrlResolvable).map(function(url) {
        return _this._urlResolver.resolve(templateAbsUrl, url);
      }).concat(templateMeta.styleUrls.filter(isStyleUrlResolvable).map(function(url) {
        return _this._urlResolver.resolve(directiveType.moduleUrl, url);
      }));
      var allResolvedStyles = allStyles.map(function(style) {
        var styleWithImports = extractStyleUrls(_this._urlResolver, templateAbsUrl, style);
        styleWithImports.styleUrls.forEach(function(styleUrl) {
          return allStyleAbsUrls.push(styleUrl);
        });
        return styleWithImports.style;
      });
      var encapsulation = templateMeta.encapsulation;
      if (encapsulation === _angular_core.ViewEncapsulation.Emulated && allResolvedStyles.length === 0 && allStyleAbsUrls.length === 0) {
        encapsulation = _angular_core.ViewEncapsulation.None;
      }
      return new CompileTemplateMetadata({
        encapsulation: encapsulation,
        template: template,
        templateUrl: templateAbsUrl,
        styles: allResolvedStyles,
        styleUrls: allStyleAbsUrls,
        ngContentSelectors: visitor.ngContentSelectors
      });
    };
    return DirectiveNormalizer;
  }());
  DirectiveNormalizer.decorators = [{type: _angular_core.Injectable}];
  DirectiveNormalizer.ctorParameters = [{type: XHR}, {type: UrlResolver}, {type: HtmlParser}];
  var TemplatePreparseVisitor = (function() {
    function TemplatePreparseVisitor() {
      this.ngContentSelectors = [];
      this.styles = [];
      this.styleUrls = [];
      this.ngNonBindableStackCount = 0;
    }
    TemplatePreparseVisitor.prototype.visitElement = function(ast, context) {
      var preparsedElement = preparseElement(ast);
      switch (preparsedElement.type) {
        case PreparsedElementType.NG_CONTENT:
          if (this.ngNonBindableStackCount === 0) {
            this.ngContentSelectors.push(preparsedElement.selectAttr);
          }
          break;
        case PreparsedElementType.STYLE:
          var textContent = '';
          ast.children.forEach(function(child) {
            if (child instanceof HtmlTextAst) {
              textContent += child.value;
            }
          });
          this.styles.push(textContent);
          break;
        case PreparsedElementType.STYLESHEET:
          this.styleUrls.push(preparsedElement.hrefAttr);
          break;
        default:
          break;
      }
      if (preparsedElement.nonBindable) {
        this.ngNonBindableStackCount++;
      }
      htmlVisitAll(this, ast.children);
      if (preparsedElement.nonBindable) {
        this.ngNonBindableStackCount--;
      }
      return null;
    };
    TemplatePreparseVisitor.prototype.visitComment = function(ast, context) {
      return null;
    };
    TemplatePreparseVisitor.prototype.visitAttr = function(ast, context) {
      return null;
    };
    TemplatePreparseVisitor.prototype.visitText = function(ast, context) {
      return null;
    };
    TemplatePreparseVisitor.prototype.visitExpansion = function(ast, context) {
      return null;
    };
    TemplatePreparseVisitor.prototype.visitExpansionCase = function(ast, context) {
      return null;
    };
    return TemplatePreparseVisitor;
  }());
  function _isDirectiveMetadata(type) {
    return type instanceof _angular_core.DirectiveMetadata;
  }
  var DirectiveResolver = (function() {
    function DirectiveResolver(_reflector) {
      if (isPresent(_reflector)) {
        this._reflector = _reflector;
      } else {
        this._reflector = _angular_core.reflector;
      }
    }
    DirectiveResolver.prototype.resolve = function(type) {
      var typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));
      if (isPresent(typeMetadata)) {
        var metadata = typeMetadata.find(_isDirectiveMetadata);
        if (isPresent(metadata)) {
          var propertyMetadata = this._reflector.propMetadata(type);
          return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);
        }
      }
      throw new BaseException$1("No Directive annotation found on " + stringify(type));
    };
    DirectiveResolver.prototype._mergeWithPropertyMetadata = function(dm, propertyMetadata, directiveType) {
      var inputs = [];
      var outputs = [];
      var host = {};
      var queries = {};
      StringMapWrapper.forEach(propertyMetadata, function(metadata, propName) {
        metadata.forEach(function(a) {
          if (a instanceof _angular_core.InputMetadata) {
            if (isPresent(a.bindingPropertyName)) {
              inputs.push(propName + ": " + a.bindingPropertyName);
            } else {
              inputs.push(propName);
            }
          }
          if (a instanceof _angular_core.OutputMetadata) {
            if (isPresent(a.bindingPropertyName)) {
              outputs.push(propName + ": " + a.bindingPropertyName);
            } else {
              outputs.push(propName);
            }
          }
          if (a instanceof _angular_core.HostBindingMetadata) {
            if (isPresent(a.hostPropertyName)) {
              host[("[" + a.hostPropertyName + "]")] = propName;
            } else {
              host[("[" + propName + "]")] = propName;
            }
          }
          if (a instanceof _angular_core.HostListenerMetadata) {
            var args = isPresent(a.args) ? a.args.join(', ') : '';
            host[("(" + a.eventName + ")")] = propName + "(" + args + ")";
          }
          if (a instanceof _angular_core.ContentChildrenMetadata) {
            queries[propName] = a;
          }
          if (a instanceof _angular_core.ViewChildrenMetadata) {
            queries[propName] = a;
          }
          if (a instanceof _angular_core.ContentChildMetadata) {
            queries[propName] = a;
          }
          if (a instanceof _angular_core.ViewChildMetadata) {
            queries[propName] = a;
          }
        });
      });
      return this._merge(dm, inputs, outputs, host, queries, directiveType);
    };
    DirectiveResolver.prototype._merge = function(dm, inputs, outputs, host, queries, directiveType) {
      var mergedInputs = isPresent(dm.inputs) ? ListWrapper.concat(dm.inputs, inputs) : inputs;
      var mergedOutputs;
      if (isPresent(dm.outputs)) {
        dm.outputs.forEach(function(propName) {
          if (ListWrapper.contains(outputs, propName)) {
            throw new BaseException$1("Output event '" + propName + "' defined multiple times in '" + stringify(directiveType) + "'");
          }
        });
        mergedOutputs = ListWrapper.concat(dm.outputs, outputs);
      } else {
        mergedOutputs = outputs;
      }
      var mergedHost = isPresent(dm.host) ? StringMapWrapper.merge(dm.host, host) : host;
      var mergedQueries = isPresent(dm.queries) ? StringMapWrapper.merge(dm.queries, queries) : queries;
      if (dm instanceof _angular_core.ComponentMetadata) {
        return new _angular_core.ComponentMetadata({
          selector: dm.selector,
          inputs: mergedInputs,
          outputs: mergedOutputs,
          host: mergedHost,
          exportAs: dm.exportAs,
          moduleId: dm.moduleId,
          queries: mergedQueries,
          changeDetection: dm.changeDetection,
          providers: dm.providers,
          viewProviders: dm.viewProviders
        });
      } else {
        return new _angular_core.DirectiveMetadata({
          selector: dm.selector,
          inputs: mergedInputs,
          outputs: mergedOutputs,
          host: mergedHost,
          exportAs: dm.exportAs,
          queries: mergedQueries,
          providers: dm.providers
        });
      }
    };
    return DirectiveResolver;
  }());
  DirectiveResolver.decorators = [{type: _angular_core.Injectable}];
  DirectiveResolver.ctorParameters = [{type: ReflectorReader}];
  var CODEGEN_DIRECTIVE_RESOLVER = new DirectiveResolver(_angular_core.reflector);
  function _isPipeMetadata(type) {
    return type instanceof _angular_core.PipeMetadata;
  }
  var PipeResolver = (function() {
    function PipeResolver(_reflector) {
      if (isPresent(_reflector)) {
        this._reflector = _reflector;
      } else {
        this._reflector = _angular_core.reflector;
      }
    }
    PipeResolver.prototype.resolve = function(type) {
      var metas = this._reflector.annotations(_angular_core.resolveForwardRef(type));
      if (isPresent(metas)) {
        var annotation = metas.find(_isPipeMetadata);
        if (isPresent(annotation)) {
          return annotation;
        }
      }
      throw new BaseException$1("No Pipe decorator found on " + stringify(type));
    };
    return PipeResolver;
  }());
  PipeResolver.decorators = [{type: _angular_core.Injectable}];
  PipeResolver.ctorParameters = [{type: ReflectorReader}];
  var CODEGEN_PIPE_RESOLVER = new PipeResolver(_angular_core.reflector);
  var ViewResolver = (function() {
    function ViewResolver(_reflector) {
      this._cache = new Map$1();
      if (isPresent(_reflector)) {
        this._reflector = _reflector;
      } else {
        this._reflector = _angular_core.reflector;
      }
    }
    ViewResolver.prototype.resolve = function(component) {
      var view = this._cache.get(component);
      if (isBlank(view)) {
        view = this._resolve(component);
        this._cache.set(component, view);
      }
      return view;
    };
    ViewResolver.prototype._resolve = function(component) {
      var compMeta;
      var viewMeta;
      this._reflector.annotations(component).forEach(function(m) {
        if (m instanceof _angular_core.ViewMetadata) {
          viewMeta = m;
        }
        if (m instanceof _angular_core.ComponentMetadata) {
          compMeta = m;
        }
      });
      if (isPresent(compMeta)) {
        if (isBlank(compMeta.template) && isBlank(compMeta.templateUrl) && isBlank(viewMeta)) {
          throw new BaseException$1("Component '" + stringify(component) + "' must have either 'template' or 'templateUrl' set.");
        } else if (isPresent(compMeta.template) && isPresent(viewMeta)) {
          this._throwMixingViewAndComponent("template", component);
        } else if (isPresent(compMeta.templateUrl) && isPresent(viewMeta)) {
          this._throwMixingViewAndComponent("templateUrl", component);
        } else if (isPresent(compMeta.directives) && isPresent(viewMeta)) {
          this._throwMixingViewAndComponent("directives", component);
        } else if (isPresent(compMeta.pipes) && isPresent(viewMeta)) {
          this._throwMixingViewAndComponent("pipes", component);
        } else if (isPresent(compMeta.encapsulation) && isPresent(viewMeta)) {
          this._throwMixingViewAndComponent("encapsulation", component);
        } else if (isPresent(compMeta.styles) && isPresent(viewMeta)) {
          this._throwMixingViewAndComponent("styles", component);
        } else if (isPresent(compMeta.styleUrls) && isPresent(viewMeta)) {
          this._throwMixingViewAndComponent("styleUrls", component);
        } else if (isPresent(viewMeta)) {
          return viewMeta;
        } else {
          return new _angular_core.ViewMetadata({
            templateUrl: compMeta.templateUrl,
            template: compMeta.template,
            directives: compMeta.directives,
            pipes: compMeta.pipes,
            encapsulation: compMeta.encapsulation,
            styles: compMeta.styles,
            styleUrls: compMeta.styleUrls
          });
        }
      } else {
        if (isBlank(viewMeta)) {
          throw new BaseException$1("Could not compile '" + stringify(component) + "' because it is not a component.");
        } else {
          return viewMeta;
        }
      }
      return null;
    };
    ViewResolver.prototype._throwMixingViewAndComponent = function(propertyName, component) {
      throw new BaseException$1("Component '" + stringify(component) + "' cannot have both '" + propertyName + "' and '@View' set at the same time\"");
    };
    return ViewResolver;
  }());
  ViewResolver.decorators = [{type: _angular_core.Injectable}];
  ViewResolver.ctorParameters = [{type: ReflectorReader}];
  function hasLifecycleHook(lcInterface, token) {
    if (!(token instanceof Type))
      return false;
    var proto = token.prototype;
    switch (lcInterface) {
      case LifecycleHooks.AfterContentInit:
        return !!proto.ngAfterContentInit;
      case LifecycleHooks.AfterContentChecked:
        return !!proto.ngAfterContentChecked;
      case LifecycleHooks.AfterViewInit:
        return !!proto.ngAfterViewInit;
      case LifecycleHooks.AfterViewChecked:
        return !!proto.ngAfterViewChecked;
      case LifecycleHooks.OnChanges:
        return !!proto.ngOnChanges;
      case LifecycleHooks.DoCheck:
        return !!proto.ngDoCheck;
      case LifecycleHooks.OnDestroy:
        return !!proto.ngOnDestroy;
      case LifecycleHooks.OnInit:
        return !!proto.ngOnInit;
      default:
        return false;
    }
  }
  function assertArrayOfStrings(identifier, value) {
    if (!assertionsEnabled() || isBlank(value)) {
      return;
    }
    if (!isArray(value)) {
      throw new BaseException$1("Expected '" + identifier + "' to be an array of strings.");
    }
    for (var i = 0; i < value.length; i += 1) {
      if (!isString(value[i])) {
        throw new BaseException$1("Expected '" + identifier + "' to be an array of strings.");
      }
    }
  }
  var CompileMetadataResolver = (function() {
    function CompileMetadataResolver(_directiveResolver, _pipeResolver, _viewResolver, _platformDirectives, _platformPipes, _reflector) {
      this._directiveResolver = _directiveResolver;
      this._pipeResolver = _pipeResolver;
      this._viewResolver = _viewResolver;
      this._platformDirectives = _platformDirectives;
      this._platformPipes = _platformPipes;
      this._directiveCache = new Map();
      this._pipeCache = new Map();
      this._anonymousTypes = new Map();
      this._anonymousTypeIndex = 0;
      if (isPresent(_reflector)) {
        this._reflector = _reflector;
      } else {
        this._reflector = _angular_core.reflector;
      }
    }
    CompileMetadataResolver.prototype.sanitizeTokenName = function(token) {
      var identifier = stringify(token);
      if (identifier.indexOf('(') >= 0) {
        var found = this._anonymousTypes.get(token);
        if (isBlank(found)) {
          this._anonymousTypes.set(token, this._anonymousTypeIndex++);
          found = this._anonymousTypes.get(token);
        }
        identifier = "anonymous_token_" + found + "_";
      }
      return sanitizeIdentifier(identifier);
    };
    CompileMetadataResolver.prototype.getDirectiveMetadata = function(directiveType) {
      var meta = this._directiveCache.get(directiveType);
      if (isBlank(meta)) {
        var dirMeta = this._directiveResolver.resolve(directiveType);
        var templateMeta = null;
        var changeDetectionStrategy = null;
        var viewProviders = [];
        var moduleUrl = staticTypeModuleUrl(directiveType);
        if (dirMeta instanceof _angular_core.ComponentMetadata) {
          assertArrayOfStrings('styles', dirMeta.styles);
          var cmpMeta = dirMeta;
          var viewMeta = this._viewResolver.resolve(directiveType);
          assertArrayOfStrings('styles', viewMeta.styles);
          templateMeta = new CompileTemplateMetadata({
            encapsulation: viewMeta.encapsulation,
            template: viewMeta.template,
            templateUrl: viewMeta.templateUrl,
            styles: viewMeta.styles,
            styleUrls: viewMeta.styleUrls
          });
          changeDetectionStrategy = cmpMeta.changeDetection;
          if (isPresent(dirMeta.viewProviders)) {
            viewProviders = this.getProvidersMetadata(dirMeta.viewProviders);
          }
          moduleUrl = componentModuleUrl(this._reflector, directiveType, cmpMeta);
        }
        var providers = [];
        if (isPresent(dirMeta.providers)) {
          providers = this.getProvidersMetadata(dirMeta.providers);
        }
        var queries = [];
        var viewQueries = [];
        if (isPresent(dirMeta.queries)) {
          queries = this.getQueriesMetadata(dirMeta.queries, false);
          viewQueries = this.getQueriesMetadata(dirMeta.queries, true);
        }
        meta = CompileDirectiveMetadata.create({
          selector: dirMeta.selector,
          exportAs: dirMeta.exportAs,
          isComponent: isPresent(templateMeta),
          type: this.getTypeMetadata(directiveType, moduleUrl),
          template: templateMeta,
          changeDetection: changeDetectionStrategy,
          inputs: dirMeta.inputs,
          outputs: dirMeta.outputs,
          host: dirMeta.host,
          lifecycleHooks: LIFECYCLE_HOOKS_VALUES.filter(function(hook) {
            return hasLifecycleHook(hook, directiveType);
          }),
          providers: providers,
          viewProviders: viewProviders,
          queries: queries,
          viewQueries: viewQueries
        });
        this._directiveCache.set(directiveType, meta);
      }
      return meta;
    };
    CompileMetadataResolver.prototype.maybeGetDirectiveMetadata = function(someType) {
      try {
        return this.getDirectiveMetadata(someType);
      } catch (e) {
        if (e.message.indexOf('No Directive annotation') !== -1) {
          return null;
        }
        throw e;
      }
    };
    CompileMetadataResolver.prototype.getTypeMetadata = function(type, moduleUrl) {
      return new CompileTypeMetadata({
        name: this.sanitizeTokenName(type),
        moduleUrl: moduleUrl,
        runtime: type,
        diDeps: this.getDependenciesMetadata(type, null)
      });
    };
    CompileMetadataResolver.prototype.getFactoryMetadata = function(factory, moduleUrl) {
      return new CompileFactoryMetadata({
        name: this.sanitizeTokenName(factory),
        moduleUrl: moduleUrl,
        runtime: factory,
        diDeps: this.getDependenciesMetadata(factory, null)
      });
    };
    CompileMetadataResolver.prototype.getPipeMetadata = function(pipeType) {
      var meta = this._pipeCache.get(pipeType);
      if (isBlank(meta)) {
        var pipeMeta = this._pipeResolver.resolve(pipeType);
        meta = new CompilePipeMetadata({
          type: this.getTypeMetadata(pipeType, staticTypeModuleUrl(pipeType)),
          name: pipeMeta.name,
          pure: pipeMeta.pure,
          lifecycleHooks: LIFECYCLE_HOOKS_VALUES.filter(function(hook) {
            return hasLifecycleHook(hook, pipeType);
          })
        });
        this._pipeCache.set(pipeType, meta);
      }
      return meta;
    };
    CompileMetadataResolver.prototype.getViewDirectivesMetadata = function(component) {
      var _this = this;
      var view = this._viewResolver.resolve(component);
      var directives = flattenDirectives(view, this._platformDirectives);
      for (var i = 0; i < directives.length; i++) {
        if (!isValidType(directives[i])) {
          throw new BaseException$1("Unexpected directive value '" + stringify(directives[i]) + "' on the View of component '" + stringify(component) + "'");
        }
      }
      return directives.map(function(type) {
        return _this.getDirectiveMetadata(type);
      });
    };
    CompileMetadataResolver.prototype.getViewPipesMetadata = function(component) {
      var _this = this;
      var view = this._viewResolver.resolve(component);
      var pipes = flattenPipes(view, this._platformPipes);
      for (var i = 0; i < pipes.length; i++) {
        if (!isValidType(pipes[i])) {
          throw new BaseException$1("Unexpected piped value '" + stringify(pipes[i]) + "' on the View of component '" + stringify(component) + "'");
        }
      }
      return pipes.map(function(type) {
        return _this.getPipeMetadata(type);
      });
    };
    CompileMetadataResolver.prototype.getDependenciesMetadata = function(typeOrFunc, dependencies) {
      var _this = this;
      var params = isPresent(dependencies) ? dependencies : this._reflector.parameters(typeOrFunc);
      if (isBlank(params)) {
        params = [];
      }
      return params.map(function(param) {
        if (isBlank(param)) {
          return null;
        }
        var isAttribute = false;
        var isHost = false;
        var isSelf = false;
        var isSkipSelf = false;
        var isOptional = false;
        var query = null;
        var viewQuery = null;
        var token = null;
        if (isArray(param)) {
          param.forEach(function(paramEntry) {
            if (paramEntry instanceof _angular_core.HostMetadata) {
              isHost = true;
            } else if (paramEntry instanceof _angular_core.SelfMetadata) {
              isSelf = true;
            } else if (paramEntry instanceof _angular_core.SkipSelfMetadata) {
              isSkipSelf = true;
            } else if (paramEntry instanceof _angular_core.OptionalMetadata) {
              isOptional = true;
            } else if (paramEntry instanceof _angular_core.AttributeMetadata) {
              isAttribute = true;
              token = paramEntry.attributeName;
            } else if (paramEntry instanceof _angular_core.QueryMetadata) {
              if (paramEntry.isViewQuery) {
                viewQuery = paramEntry;
              } else {
                query = paramEntry;
              }
            } else if (paramEntry instanceof _angular_core.InjectMetadata) {
              token = paramEntry.token;
            } else if (isValidType(paramEntry) && isBlank(token)) {
              token = paramEntry;
            }
          });
        } else {
          token = param;
        }
        if (isBlank(token)) {
          return null;
        }
        return new CompileDiDependencyMetadata({
          isAttribute: isAttribute,
          isHost: isHost,
          isSelf: isSelf,
          isSkipSelf: isSkipSelf,
          isOptional: isOptional,
          query: isPresent(query) ? _this.getQueryMetadata(query, null) : null,
          viewQuery: isPresent(viewQuery) ? _this.getQueryMetadata(viewQuery, null) : null,
          token: _this.getTokenMetadata(token)
        });
      });
    };
    CompileMetadataResolver.prototype.getTokenMetadata = function(token) {
      token = _angular_core.resolveForwardRef(token);
      var compileToken;
      if (isString(token)) {
        compileToken = new CompileTokenMetadata({value: token});
      } else {
        compileToken = new CompileTokenMetadata({identifier: new CompileIdentifierMetadata({
            runtime: token,
            name: this.sanitizeTokenName(token),
            moduleUrl: staticTypeModuleUrl(token)
          })});
      }
      return compileToken;
    };
    CompileMetadataResolver.prototype.getProvidersMetadata = function(providers) {
      var _this = this;
      return providers.map(function(provider) {
        provider = _angular_core.resolveForwardRef(provider);
        if (isArray(provider)) {
          return _this.getProvidersMetadata(provider);
        } else if (provider instanceof _angular_core.Provider) {
          return _this.getProviderMetadata(provider);
        } else if (isProviderLiteral(provider)) {
          return _this.getProviderMetadata(createProvider(provider));
        } else {
          return _this.getTypeMetadata(provider, staticTypeModuleUrl(provider));
        }
      });
    };
    CompileMetadataResolver.prototype.getProviderMetadata = function(provider) {
      var compileDeps;
      if (isPresent(provider.useClass)) {
        compileDeps = this.getDependenciesMetadata(provider.useClass, provider.dependencies);
      } else if (isPresent(provider.useFactory)) {
        compileDeps = this.getDependenciesMetadata(provider.useFactory, provider.dependencies);
      }
      return new CompileProviderMetadata({
        token: this.getTokenMetadata(provider.token),
        useClass: isPresent(provider.useClass) ? this.getTypeMetadata(provider.useClass, staticTypeModuleUrl(provider.useClass)) : null,
        useValue: convertToCompileValue(provider.useValue),
        useFactory: isPresent(provider.useFactory) ? this.getFactoryMetadata(provider.useFactory, staticTypeModuleUrl(provider.useFactory)) : null,
        useExisting: isPresent(provider.useExisting) ? this.getTokenMetadata(provider.useExisting) : null,
        deps: compileDeps,
        multi: provider.multi
      });
    };
    CompileMetadataResolver.prototype.getQueriesMetadata = function(queries, isViewQuery) {
      var _this = this;
      var compileQueries = [];
      StringMapWrapper.forEach(queries, function(query, propertyName) {
        if (query.isViewQuery === isViewQuery) {
          compileQueries.push(_this.getQueryMetadata(query, propertyName));
        }
      });
      return compileQueries;
    };
    CompileMetadataResolver.prototype.getQueryMetadata = function(q, propertyName) {
      var _this = this;
      var selectors;
      if (q.isVarBindingQuery) {
        selectors = q.varBindings.map(function(varName) {
          return _this.getTokenMetadata(varName);
        });
      } else {
        selectors = [this.getTokenMetadata(q.selector)];
      }
      return new CompileQueryMetadata({
        selectors: selectors,
        first: q.first,
        descendants: q.descendants,
        propertyName: propertyName,
        read: isPresent(q.read) ? this.getTokenMetadata(q.read) : null
      });
    };
    return CompileMetadataResolver;
  }());
  CompileMetadataResolver.decorators = [{type: _angular_core.Injectable}];
  CompileMetadataResolver.ctorParameters = [{type: DirectiveResolver}, {type: PipeResolver}, {type: ViewResolver}, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {
      type: _angular_core.Inject,
      args: [_angular_core.PLATFORM_DIRECTIVES]
    }]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {
      type: _angular_core.Inject,
      args: [_angular_core.PLATFORM_PIPES]
    }]
  }, {type: ReflectorReader}];
  function flattenDirectives(view, platformDirectives) {
    var directives = [];
    if (isPresent(platformDirectives)) {
      flattenArray(platformDirectives, directives);
    }
    if (isPresent(view.directives)) {
      flattenArray(view.directives, directives);
    }
    return directives;
  }
  function flattenPipes(view, platformPipes) {
    var pipes = [];
    if (isPresent(platformPipes)) {
      flattenArray(platformPipes, pipes);
    }
    if (isPresent(view.pipes)) {
      flattenArray(view.pipes, pipes);
    }
    return pipes;
  }
  function flattenArray(tree, out) {
    for (var i = 0; i < tree.length; i++) {
      var item = _angular_core.resolveForwardRef(tree[i]);
      if (isArray(item)) {
        flattenArray(item, out);
      } else {
        out.push(item);
      }
    }
  }
  function isStaticType(value) {
    return isStringMap(value) && isPresent(value['name']) && isPresent(value['filePath']);
  }
  function isValidType(value) {
    return isStaticType(value) || (value instanceof Type);
  }
  function staticTypeModuleUrl(value) {
    return isStaticType(value) ? value['filePath'] : null;
  }
  function componentModuleUrl(reflector, type, cmpMetadata) {
    if (isStaticType(type)) {
      return staticTypeModuleUrl(type);
    }
    if (isPresent(cmpMetadata.moduleId)) {
      var moduleId = cmpMetadata.moduleId;
      var scheme = getUrlScheme(moduleId);
      return isPresent(scheme) && scheme.length > 0 ? moduleId : "package:" + moduleId + MODULE_SUFFIX;
    }
    return reflector.importUri(type);
  }
  function convertToCompileValue(value) {
    return visitValue(value, new _CompileValueConverter(), null);
  }
  var _CompileValueConverter = (function(_super) {
    __extends(_CompileValueConverter, _super);
    function _CompileValueConverter() {
      _super.apply(this, arguments);
    }
    _CompileValueConverter.prototype.visitOther = function(value, context) {
      if (isStaticType(value)) {
        return new CompileIdentifierMetadata({
          name: value['name'],
          moduleUrl: staticTypeModuleUrl(value)
        });
      } else {
        return new CompileIdentifierMetadata({runtime: value});
      }
    };
    return _CompileValueConverter;
  }(ValueTransformer));
  var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
  var CATCH_ERROR_VAR$1 = variable('error');
  var CATCH_STACK_VAR$1 = variable('stack');
  var _EmittedLine = (function() {
    function _EmittedLine(indent) {
      this.indent = indent;
      this.parts = [];
    }
    return _EmittedLine;
  }());
  var EmitterVisitorContext = (function() {
    function EmitterVisitorContext(_exportedVars, _indent) {
      this._exportedVars = _exportedVars;
      this._indent = _indent;
      this._classes = [];
      this._lines = [new _EmittedLine(_indent)];
    }
    EmitterVisitorContext.createRoot = function(exportedVars) {
      return new EmitterVisitorContext(exportedVars, 0);
    };
    Object.defineProperty(EmitterVisitorContext.prototype, "_currentLine", {
      get: function() {
        return this._lines[this._lines.length - 1];
      },
      enumerable: true,
      configurable: true
    });
    EmitterVisitorContext.prototype.isExportedVar = function(varName) {
      return this._exportedVars.indexOf(varName) !== -1;
    };
    EmitterVisitorContext.prototype.println = function(lastPart) {
      if (lastPart === void 0) {
        lastPart = '';
      }
      this.print(lastPart, true);
    };
    EmitterVisitorContext.prototype.lineIsEmpty = function() {
      return this._currentLine.parts.length === 0;
    };
    EmitterVisitorContext.prototype.print = function(part, newLine) {
      if (newLine === void 0) {
        newLine = false;
      }
      if (part.length > 0) {
        this._currentLine.parts.push(part);
      }
      if (newLine) {
        this._lines.push(new _EmittedLine(this._indent));
      }
    };
    EmitterVisitorContext.prototype.removeEmptyLastLine = function() {
      if (this.lineIsEmpty()) {
        this._lines.pop();
      }
    };
    EmitterVisitorContext.prototype.incIndent = function() {
      this._indent++;
      this._currentLine.indent = this._indent;
    };
    EmitterVisitorContext.prototype.decIndent = function() {
      this._indent--;
      this._currentLine.indent = this._indent;
    };
    EmitterVisitorContext.prototype.pushClass = function(clazz) {
      this._classes.push(clazz);
    };
    EmitterVisitorContext.prototype.popClass = function() {
      return this._classes.pop();
    };
    Object.defineProperty(EmitterVisitorContext.prototype, "currentClass", {
      get: function() {
        return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
      },
      enumerable: true,
      configurable: true
    });
    EmitterVisitorContext.prototype.toSource = function() {
      var lines = this._lines;
      if (lines[lines.length - 1].parts.length === 0) {
        lines = lines.slice(0, lines.length - 1);
      }
      return lines.map(function(line) {
        if (line.parts.length > 0) {
          return _createIndent(line.indent) + line.parts.join('');
        } else {
          return '';
        }
      }).join('\n');
    };
    return EmitterVisitorContext;
  }());
  var AbstractEmitterVisitor = (function() {
    function AbstractEmitterVisitor(_escapeDollarInStrings) {
      this._escapeDollarInStrings = _escapeDollarInStrings;
    }
    AbstractEmitterVisitor.prototype.visitExpressionStmt = function(stmt, ctx) {
      stmt.expr.visitExpression(this, ctx);
      ctx.println(';');
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReturnStmt = function(stmt, ctx) {
      ctx.print("return ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(';');
      return null;
    };
    AbstractEmitterVisitor.prototype.visitIfStmt = function(stmt, ctx) {
      ctx.print("if (");
      stmt.condition.visitExpression(this, ctx);
      ctx.print(") {");
      var hasElseCase = isPresent(stmt.falseCase) && stmt.falseCase.length > 0;
      if (stmt.trueCase.length <= 1 && !hasElseCase) {
        ctx.print(" ");
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.removeEmptyLastLine();
        ctx.print(" ");
      } else {
        ctx.println();
        ctx.incIndent();
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.decIndent();
        if (hasElseCase) {
          ctx.println("} else {");
          ctx.incIndent();
          this.visitAllStatements(stmt.falseCase, ctx);
          ctx.decIndent();
        }
      }
      ctx.println("}");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitThrowStmt = function(stmt, ctx) {
      ctx.print("throw ");
      stmt.error.visitExpression(this, ctx);
      ctx.println(";");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitCommentStmt = function(stmt, ctx) {
      var lines = stmt.comment.split('\n');
      lines.forEach(function(line) {
        ctx.println("// " + line);
      });
      return null;
    };
    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print('(');
      }
      ctx.print(expr.name + " = ");
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(')');
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print('(');
      }
      expr.receiver.visitExpression(this, ctx);
      ctx.print("[");
      expr.index.visitExpression(this, ctx);
      ctx.print("] = ");
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(')');
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitWritePropExpr = function(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print('(');
      }
      expr.receiver.visitExpression(this, ctx);
      ctx.print("." + expr.name + " = ");
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(')');
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function(expr, ctx) {
      expr.receiver.visitExpression(this, ctx);
      var name = expr.name;
      if (isPresent(expr.builtin)) {
        name = this.getBuiltinMethodName(expr.builtin);
        if (isBlank(name)) {
          return null;
        }
      }
      ctx.print("." + name + "(");
      this.visitAllExpressions(expr.args, ctx, ",");
      ctx.print(")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function(expr, ctx) {
      expr.fn.visitExpression(this, ctx);
      ctx.print("(");
      this.visitAllExpressions(expr.args, ctx, ',');
      ctx.print(")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReadVarExpr = function(ast, ctx) {
      var varName = ast.name;
      if (isPresent(ast.builtin)) {
        switch (ast.builtin) {
          case BuiltinVar.Super:
            varName = 'super';
            break;
          case BuiltinVar.This:
            varName = 'this';
            break;
          case BuiltinVar.CatchError:
            varName = CATCH_ERROR_VAR$1.name;
            break;
          case BuiltinVar.CatchStack:
            varName = CATCH_STACK_VAR$1.name;
            break;
          default:
            throw new BaseException$1("Unknown builtin variable " + ast.builtin);
        }
      }
      ctx.print(varName);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function(ast, ctx) {
      ctx.print("new ");
      ast.classExpr.visitExpression(this, ctx);
      ctx.print("(");
      this.visitAllExpressions(ast.args, ctx, ',');
      ctx.print(")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralExpr = function(ast, ctx) {
      var value = ast.value;
      if (isString(value)) {
        ctx.print(escapeSingleQuoteString(value, this._escapeDollarInStrings));
      } else if (isBlank(value)) {
        ctx.print('null');
      } else {
        ctx.print("" + value);
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitConditionalExpr = function(ast, ctx) {
      ctx.print("(");
      ast.condition.visitExpression(this, ctx);
      ctx.print('? ');
      ast.trueCase.visitExpression(this, ctx);
      ctx.print(': ');
      ast.falseCase.visitExpression(this, ctx);
      ctx.print(")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitNotExpr = function(ast, ctx) {
      ctx.print('!');
      ast.condition.visitExpression(this, ctx);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function(ast, ctx) {
      var opStr;
      switch (ast.operator) {
        case BinaryOperator.Equals:
          opStr = '==';
          break;
        case BinaryOperator.Identical:
          opStr = '===';
          break;
        case BinaryOperator.NotEquals:
          opStr = '!=';
          break;
        case BinaryOperator.NotIdentical:
          opStr = '!==';
          break;
        case BinaryOperator.And:
          opStr = '&&';
          break;
        case BinaryOperator.Or:
          opStr = '||';
          break;
        case BinaryOperator.Plus:
          opStr = '+';
          break;
        case BinaryOperator.Minus:
          opStr = '-';
          break;
        case BinaryOperator.Divide:
          opStr = '/';
          break;
        case BinaryOperator.Multiply:
          opStr = '*';
          break;
        case BinaryOperator.Modulo:
          opStr = '%';
          break;
        case BinaryOperator.Lower:
          opStr = '<';
          break;
        case BinaryOperator.LowerEquals:
          opStr = '<=';
          break;
        case BinaryOperator.Bigger:
          opStr = '>';
          break;
        case BinaryOperator.BiggerEquals:
          opStr = '>=';
          break;
        default:
          throw new BaseException$1("Unknown operator " + ast.operator);
      }
      ctx.print("(");
      ast.lhs.visitExpression(this, ctx);
      ctx.print(" " + opStr + " ");
      ast.rhs.visitExpression(this, ctx);
      ctx.print(")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReadPropExpr = function(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print(".");
      ctx.print(ast.name);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print("[");
      ast.index.visitExpression(this, ctx);
      ctx.print("]");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function(ast, ctx) {
      var useNewLine = ast.entries.length > 1;
      ctx.print("[", useNewLine);
      ctx.incIndent();
      this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);
      ctx.decIndent();
      ctx.print("]", useNewLine);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function(ast, ctx) {
      var _this = this;
      var useNewLine = ast.entries.length > 1;
      ctx.print("{", useNewLine);
      ctx.incIndent();
      this.visitAllObjects(function(entry) {
        ctx.print(escapeSingleQuoteString(entry[0], _this._escapeDollarInStrings) + ": ");
        entry[1].visitExpression(_this, ctx);
      }, ast.entries, ctx, ',', useNewLine);
      ctx.decIndent();
      ctx.print("}", useNewLine);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitAllExpressions = function(expressions, ctx, separator, newLine) {
      var _this = this;
      if (newLine === void 0) {
        newLine = false;
      }
      this.visitAllObjects(function(expr) {
        return expr.visitExpression(_this, ctx);
      }, expressions, ctx, separator, newLine);
    };
    AbstractEmitterVisitor.prototype.visitAllObjects = function(handler, expressions, ctx, separator, newLine) {
      if (newLine === void 0) {
        newLine = false;
      }
      for (var i = 0; i < expressions.length; i++) {
        if (i > 0) {
          ctx.print(separator, newLine);
        }
        handler(expressions[i]);
      }
      if (newLine) {
        ctx.println();
      }
    };
    AbstractEmitterVisitor.prototype.visitAllStatements = function(statements, ctx) {
      var _this = this;
      statements.forEach(function(stmt) {
        return stmt.visitStatement(_this, ctx);
      });
    };
    return AbstractEmitterVisitor;
  }());
  function escapeSingleQuoteString(input, escapeDollar) {
    if (isBlank(input)) {
      return null;
    }
    var body = StringWrapper.replaceAllMapped(input, _SINGLE_QUOTE_ESCAPE_STRING_RE, function(match) {
      if (match[0] == '$') {
        return escapeDollar ? '\\$' : '$';
      } else if (match[0] == '\n') {
        return '\\n';
      } else if (match[0] == '\r') {
        return '\\r';
      } else {
        return "\\" + match[0];
      }
    });
    return "'" + body + "'";
  }
  function _createIndent(count) {
    var res = '';
    for (var i = 0; i < count; i++) {
      res += '  ';
    }
    return res;
  }
  var AbstractJsEmitterVisitor = (function(_super) {
    __extends(AbstractJsEmitterVisitor, _super);
    function AbstractJsEmitterVisitor() {
      _super.call(this, false);
    }
    AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      var _this = this;
      ctx.pushClass(stmt);
      this._visitClassConstructor(stmt, ctx);
      if (isPresent(stmt.parent)) {
        ctx.print(stmt.name + ".prototype = Object.create(");
        stmt.parent.visitExpression(this, ctx);
        ctx.println(".prototype);");
      }
      stmt.getters.forEach(function(getter) {
        return _this._visitClassGetter(stmt, getter, ctx);
      });
      stmt.methods.forEach(function(method) {
        return _this._visitClassMethod(stmt, method, ctx);
      });
      ctx.popClass();
      return null;
    };
    AbstractJsEmitterVisitor.prototype._visitClassConstructor = function(stmt, ctx) {
      ctx.print("function " + stmt.name + "(");
      if (isPresent(stmt.constructorMethod)) {
        this._visitParams(stmt.constructorMethod.params, ctx);
      }
      ctx.println(") {");
      ctx.incIndent();
      if (isPresent(stmt.constructorMethod)) {
        if (stmt.constructorMethod.body.length > 0) {
          ctx.println("var self = this;");
          this.visitAllStatements(stmt.constructorMethod.body, ctx);
        }
      }
      ctx.decIndent();
      ctx.println("}");
    };
    AbstractJsEmitterVisitor.prototype._visitClassGetter = function(stmt, getter, ctx) {
      ctx.println("Object.defineProperty(" + stmt.name + ".prototype, '" + getter.name + "', { get: function() {");
      ctx.incIndent();
      if (getter.body.length > 0) {
        ctx.println("var self = this;");
        this.visitAllStatements(getter.body, ctx);
      }
      ctx.decIndent();
      ctx.println("}});");
    };
    AbstractJsEmitterVisitor.prototype._visitClassMethod = function(stmt, method, ctx) {
      ctx.print(stmt.name + ".prototype." + method.name + " = function(");
      this._visitParams(method.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      if (method.body.length > 0) {
        ctx.println("var self = this;");
        this.visitAllStatements(method.body, ctx);
      }
      ctx.decIndent();
      ctx.println("};");
    };
    AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function(ast, ctx) {
      if (ast.builtin === BuiltinVar.This) {
        ctx.print('self');
      } else if (ast.builtin === BuiltinVar.Super) {
        throw new BaseException$1("'super' needs to be handled at a parent ast node, not at the variable level!");
      } else {
        _super.prototype.visitReadVarExpr.call(this, ast, ctx);
      }
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      ctx.print("var " + stmt.name + " = ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(";");
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitCastExpr = function(ast, ctx) {
      ast.value.visitExpression(this, ctx);
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function(expr, ctx) {
      var fnExpr = expr.fn;
      if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
        ctx.currentClass.parent.visitExpression(this, ctx);
        ctx.print(".call(this");
        if (expr.args.length > 0) {
          ctx.print(", ");
          this.visitAllExpressions(expr.args, ctx, ',');
        }
        ctx.print(")");
      } else {
        _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);
      }
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function(ast, ctx) {
      ctx.print("function(");
      this._visitParams(ast.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      this.visitAllStatements(ast.statements, ctx);
      ctx.decIndent();
      ctx.print("}");
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      ctx.print("function " + stmt.name + "(");
      this._visitParams(stmt.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      this.visitAllStatements(stmt.statements, ctx);
      ctx.decIndent();
      ctx.println("}");
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function(stmt, ctx) {
      ctx.println("try {");
      ctx.incIndent();
      this.visitAllStatements(stmt.bodyStmts, ctx);
      ctx.decIndent();
      ctx.println("} catch (" + CATCH_ERROR_VAR$1.name + ") {");
      ctx.incIndent();
      var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [StmtModifier.Final])].concat(stmt.catchStmts);
      this.visitAllStatements(catchStmts, ctx);
      ctx.decIndent();
      ctx.println("}");
      return null;
    };
    AbstractJsEmitterVisitor.prototype._visitParams = function(params, ctx) {
      this.visitAllObjects(function(param) {
        return ctx.print(param.name);
      }, params, ctx, ',');
    };
    AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function(method) {
      var name;
      switch (method) {
        case BuiltinMethod.ConcatArray:
          name = 'concat';
          break;
        case BuiltinMethod.SubscribeObservable:
          name = 'subscribe';
          break;
        case BuiltinMethod.bind:
          name = 'bind';
          break;
        default:
          throw new BaseException$1("Unknown builtin method: " + method);
      }
      return name;
    };
    return AbstractJsEmitterVisitor;
  }(AbstractEmitterVisitor));
  function jitStatements(sourceUrl, statements, resultVar) {
    var converter = new JitEmitterVisitor();
    var ctx = EmitterVisitorContext.createRoot([resultVar]);
    converter.visitAllStatements(statements, ctx);
    return evalExpression(sourceUrl, resultVar, ctx.toSource(), converter.getArgs());
  }
  var JitEmitterVisitor = (function(_super) {
    __extends(JitEmitterVisitor, _super);
    function JitEmitterVisitor() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
      }
      _super.apply(this, args);
      this._evalArgNames = [];
      this._evalArgValues = [];
    }
    JitEmitterVisitor.prototype.getArgs = function() {
      var result = {};
      for (var i = 0; i < this._evalArgNames.length; i++) {
        result[this._evalArgNames[i]] = this._evalArgValues[i];
      }
      return result;
    };
    JitEmitterVisitor.prototype.visitExternalExpr = function(ast, ctx) {
      var value = ast.value.runtime;
      var id = this._evalArgValues.indexOf(value);
      if (id === -1) {
        id = this._evalArgValues.length;
        this._evalArgValues.push(value);
        var name = isPresent(ast.value.name) ? sanitizeIdentifier(ast.value.name) : 'val';
        this._evalArgNames.push(sanitizeIdentifier("jit_" + name + id));
      }
      ctx.print(this._evalArgNames[id]);
      return null;
    };
    return JitEmitterVisitor;
  }(AbstractJsEmitterVisitor));
  var _debugModuleUrl = 'asset://debug/lib';
  function debugOutputAstAsDart(ast) {
    var converter = new _DartEmitterVisitor(_debugModuleUrl);
    var ctx = EmitterVisitorContext.createRoot([]);
    var asts;
    if (isArray(ast)) {
      asts = ast;
    } else {
      asts = [ast];
    }
    asts.forEach(function(ast) {
      if (ast instanceof Statement) {
        ast.visitStatement(converter, ctx);
      } else if (ast instanceof Expression) {
        ast.visitExpression(converter, ctx);
      } else if (ast instanceof Type$1) {
        ast.visitType(converter, ctx);
      } else {
        throw new BaseException$1("Don't know how to print debug info for " + ast);
      }
    });
    return ctx.toSource();
  }
  var _DartEmitterVisitor = (function(_super) {
    __extends(_DartEmitterVisitor, _super);
    function _DartEmitterVisitor(_moduleUrl) {
      _super.call(this, true);
      this._moduleUrl = _moduleUrl;
      this.importsWithPrefixes = new Map();
    }
    _DartEmitterVisitor.prototype.visitExternalExpr = function(ast, ctx) {
      this._visitIdentifier(ast.value, ast.typeParams, ctx);
      return null;
    };
    _DartEmitterVisitor.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Final)) {
        if (isConstType(stmt.type)) {
          ctx.print("const ");
        } else {
          ctx.print("final ");
        }
      } else if (isBlank(stmt.type)) {
        ctx.print("var ");
      }
      if (isPresent(stmt.type)) {
        stmt.type.visitType(this, ctx);
        ctx.print(" ");
      }
      ctx.print(stmt.name + " = ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(";");
      return null;
    };
    _DartEmitterVisitor.prototype.visitCastExpr = function(ast, ctx) {
      ctx.print("(");
      ast.value.visitExpression(this, ctx);
      ctx.print(" as ");
      ast.type.visitType(this, ctx);
      ctx.print(")");
      return null;
    };
    _DartEmitterVisitor.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      var _this = this;
      ctx.pushClass(stmt);
      ctx.print("class " + stmt.name);
      if (isPresent(stmt.parent)) {
        ctx.print(" extends ");
        stmt.parent.visitExpression(this, ctx);
      }
      ctx.println(" {");
      ctx.incIndent();
      stmt.fields.forEach(function(field) {
        return _this._visitClassField(field, ctx);
      });
      if (isPresent(stmt.constructorMethod)) {
        this._visitClassConstructor(stmt, ctx);
      }
      stmt.getters.forEach(function(getter) {
        return _this._visitClassGetter(getter, ctx);
      });
      stmt.methods.forEach(function(method) {
        return _this._visitClassMethod(method, ctx);
      });
      ctx.decIndent();
      ctx.println("}");
      ctx.popClass();
      return null;
    };
    _DartEmitterVisitor.prototype._visitClassField = function(field, ctx) {
      if (field.hasModifier(StmtModifier.Final)) {
        ctx.print("final ");
      } else if (isBlank(field.type)) {
        ctx.print("var ");
      }
      if (isPresent(field.type)) {
        field.type.visitType(this, ctx);
        ctx.print(" ");
      }
      ctx.println(field.name + ";");
    };
    _DartEmitterVisitor.prototype._visitClassGetter = function(getter, ctx) {
      if (isPresent(getter.type)) {
        getter.type.visitType(this, ctx);
        ctx.print(" ");
      }
      ctx.println("get " + getter.name + " {");
      ctx.incIndent();
      this.visitAllStatements(getter.body, ctx);
      ctx.decIndent();
      ctx.println("}");
    };
    _DartEmitterVisitor.prototype._visitClassConstructor = function(stmt, ctx) {
      ctx.print(stmt.name + "(");
      this._visitParams(stmt.constructorMethod.params, ctx);
      ctx.print(")");
      var ctorStmts = stmt.constructorMethod.body;
      var superCtorExpr = ctorStmts.length > 0 ? getSuperConstructorCallExpr(ctorStmts[0]) : null;
      if (isPresent(superCtorExpr)) {
        ctx.print(": ");
        superCtorExpr.visitExpression(this, ctx);
        ctorStmts = ctorStmts.slice(1);
      }
      ctx.println(" {");
      ctx.incIndent();
      this.visitAllStatements(ctorStmts, ctx);
      ctx.decIndent();
      ctx.println("}");
    };
    _DartEmitterVisitor.prototype._visitClassMethod = function(method, ctx) {
      if (isPresent(method.type)) {
        method.type.visitType(this, ctx);
      } else {
        ctx.print("void");
      }
      ctx.print(" " + method.name + "(");
      this._visitParams(method.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      this.visitAllStatements(method.body, ctx);
      ctx.decIndent();
      ctx.println("}");
    };
    _DartEmitterVisitor.prototype.visitFunctionExpr = function(ast, ctx) {
      ctx.print("(");
      this._visitParams(ast.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      this.visitAllStatements(ast.statements, ctx);
      ctx.decIndent();
      ctx.print("}");
      return null;
    };
    _DartEmitterVisitor.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      if (isPresent(stmt.type)) {
        stmt.type.visitType(this, ctx);
      } else {
        ctx.print("void");
      }
      ctx.print(" " + stmt.name + "(");
      this._visitParams(stmt.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      this.visitAllStatements(stmt.statements, ctx);
      ctx.decIndent();
      ctx.println("}");
      return null;
    };
    _DartEmitterVisitor.prototype.getBuiltinMethodName = function(method) {
      var name;
      switch (method) {
        case BuiltinMethod.ConcatArray:
          name = '.addAll';
          break;
        case BuiltinMethod.SubscribeObservable:
          name = 'listen';
          break;
        case BuiltinMethod.bind:
          name = null;
          break;
        default:
          throw new BaseException$1("Unknown builtin method: " + method);
      }
      return name;
    };
    _DartEmitterVisitor.prototype.visitTryCatchStmt = function(stmt, ctx) {
      ctx.println("try {");
      ctx.incIndent();
      this.visitAllStatements(stmt.bodyStmts, ctx);
      ctx.decIndent();
      ctx.println("} catch (" + CATCH_ERROR_VAR$1.name + ", " + CATCH_STACK_VAR$1.name + ") {");
      ctx.incIndent();
      this.visitAllStatements(stmt.catchStmts, ctx);
      ctx.decIndent();
      ctx.println("}");
      return null;
    };
    _DartEmitterVisitor.prototype.visitBinaryOperatorExpr = function(ast, ctx) {
      switch (ast.operator) {
        case BinaryOperator.Identical:
          ctx.print("identical(");
          ast.lhs.visitExpression(this, ctx);
          ctx.print(", ");
          ast.rhs.visitExpression(this, ctx);
          ctx.print(")");
          break;
        case BinaryOperator.NotIdentical:
          ctx.print("!identical(");
          ast.lhs.visitExpression(this, ctx);
          ctx.print(", ");
          ast.rhs.visitExpression(this, ctx);
          ctx.print(")");
          break;
        default:
          _super.prototype.visitBinaryOperatorExpr.call(this, ast, ctx);
      }
      return null;
    };
    _DartEmitterVisitor.prototype.visitLiteralArrayExpr = function(ast, ctx) {
      if (isConstType(ast.type)) {
        ctx.print("const ");
      }
      return _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);
    };
    _DartEmitterVisitor.prototype.visitLiteralMapExpr = function(ast, ctx) {
      if (isConstType(ast.type)) {
        ctx.print("const ");
      }
      if (isPresent(ast.valueType)) {
        ctx.print("<String, ");
        ast.valueType.visitType(this, ctx);
        ctx.print(">");
      }
      return _super.prototype.visitLiteralMapExpr.call(this, ast, ctx);
    };
    _DartEmitterVisitor.prototype.visitInstantiateExpr = function(ast, ctx) {
      ctx.print(isConstType(ast.type) ? "const" : "new");
      ctx.print(' ');
      ast.classExpr.visitExpression(this, ctx);
      ctx.print("(");
      this.visitAllExpressions(ast.args, ctx, ",");
      ctx.print(")");
      return null;
    };
    _DartEmitterVisitor.prototype.visitBuiltintType = function(type, ctx) {
      var typeStr;
      switch (type.name) {
        case BuiltinTypeName.Bool:
          typeStr = 'bool';
          break;
        case BuiltinTypeName.Dynamic:
          typeStr = 'dynamic';
          break;
        case BuiltinTypeName.Function:
          typeStr = 'Function';
          break;
        case BuiltinTypeName.Number:
          typeStr = 'num';
          break;
        case BuiltinTypeName.Int:
          typeStr = 'int';
          break;
        case BuiltinTypeName.String:
          typeStr = 'String';
          break;
        default:
          throw new BaseException$1("Unsupported builtin type " + type.name);
      }
      ctx.print(typeStr);
      return null;
    };
    _DartEmitterVisitor.prototype.visitExternalType = function(ast, ctx) {
      this._visitIdentifier(ast.value, ast.typeParams, ctx);
      return null;
    };
    _DartEmitterVisitor.prototype.visitArrayType = function(type, ctx) {
      ctx.print("List<");
      if (isPresent(type.of)) {
        type.of.visitType(this, ctx);
      } else {
        ctx.print("dynamic");
      }
      ctx.print(">");
      return null;
    };
    _DartEmitterVisitor.prototype.visitMapType = function(type, ctx) {
      ctx.print("Map<String, ");
      if (isPresent(type.valueType)) {
        type.valueType.visitType(this, ctx);
      } else {
        ctx.print("dynamic");
      }
      ctx.print(">");
      return null;
    };
    _DartEmitterVisitor.prototype._visitParams = function(params, ctx) {
      var _this = this;
      this.visitAllObjects(function(param) {
        if (isPresent(param.type)) {
          param.type.visitType(_this, ctx);
          ctx.print(' ');
        }
        ctx.print(param.name);
      }, params, ctx, ',');
    };
    _DartEmitterVisitor.prototype._visitIdentifier = function(value, typeParams, ctx) {
      var _this = this;
      if (isBlank(value.name)) {
        throw new BaseException$1("Internal error: unknown identifier " + value);
      }
      if (isPresent(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {
        var prefix = this.importsWithPrefixes.get(value.moduleUrl);
        if (isBlank(prefix)) {
          prefix = "import" + this.importsWithPrefixes.size;
          this.importsWithPrefixes.set(value.moduleUrl, prefix);
        }
        ctx.print(prefix + ".");
      }
      ctx.print(value.name);
      if (isPresent(typeParams) && typeParams.length > 0) {
        ctx.print("<");
        this.visitAllObjects(function(type) {
          return type.visitType(_this, ctx);
        }, typeParams, ctx, ',');
        ctx.print(">");
      }
    };
    return _DartEmitterVisitor;
  }(AbstractEmitterVisitor));
  function getSuperConstructorCallExpr(stmt) {
    if (stmt instanceof ExpressionStatement) {
      var expr = stmt.expr;
      if (expr instanceof InvokeFunctionExpr) {
        var fn = expr.fn;
        if (fn instanceof ReadVarExpr) {
          if (fn.builtin === BuiltinVar.Super) {
            return expr;
          }
        }
      }
    }
    return null;
  }
  function isConstType(type) {
    return isPresent(type) && type.hasModifier(TypeModifier.Const);
  }
  var _debugModuleUrl$1 = 'asset://debug/lib';
  function debugOutputAstAsTypeScript(ast) {
    var converter = new _TsEmitterVisitor(_debugModuleUrl$1);
    var ctx = EmitterVisitorContext.createRoot([]);
    var asts;
    if (isArray(ast)) {
      asts = ast;
    } else {
      asts = [ast];
    }
    asts.forEach(function(ast) {
      if (ast instanceof Statement) {
        ast.visitStatement(converter, ctx);
      } else if (ast instanceof Expression) {
        ast.visitExpression(converter, ctx);
      } else if (ast instanceof Type$1) {
        ast.visitType(converter, ctx);
      } else {
        throw new BaseException$1("Don't know how to print debug info for " + ast);
      }
    });
    return ctx.toSource();
  }
  var _TsEmitterVisitor = (function(_super) {
    __extends(_TsEmitterVisitor, _super);
    function _TsEmitterVisitor(_moduleUrl) {
      _super.call(this, false);
      this._moduleUrl = _moduleUrl;
      this.importsWithPrefixes = new Map();
    }
    _TsEmitterVisitor.prototype.visitExternalExpr = function(ast, ctx) {
      this._visitIdentifier(ast.value, ast.typeParams, ctx);
      return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      if (ctx.isExportedVar(stmt.name)) {
        ctx.print("export ");
      }
      if (stmt.hasModifier(StmtModifier.Final)) {
        ctx.print("const");
      } else {
        ctx.print("var");
      }
      ctx.print(" " + stmt.name);
      if (isPresent(stmt.type)) {
        ctx.print(":");
        stmt.type.visitType(this, ctx);
      }
      ctx.print(" = ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(";");
      return null;
    };
    _TsEmitterVisitor.prototype.visitCastExpr = function(ast, ctx) {
      ctx.print("(<");
      ast.type.visitType(this, ctx);
      ctx.print(">");
      ast.value.visitExpression(this, ctx);
      ctx.print(")");
      return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      var _this = this;
      ctx.pushClass(stmt);
      if (ctx.isExportedVar(stmt.name)) {
        ctx.print("export ");
      }
      ctx.print("class " + stmt.name);
      if (isPresent(stmt.parent)) {
        ctx.print(" extends ");
        stmt.parent.visitExpression(this, ctx);
      }
      ctx.println(" {");
      ctx.incIndent();
      stmt.fields.forEach(function(field) {
        return _this._visitClassField(field, ctx);
      });
      if (isPresent(stmt.constructorMethod)) {
        this._visitClassConstructor(stmt, ctx);
      }
      stmt.getters.forEach(function(getter) {
        return _this._visitClassGetter(getter, ctx);
      });
      stmt.methods.forEach(function(method) {
        return _this._visitClassMethod(method, ctx);
      });
      ctx.decIndent();
      ctx.println("}");
      ctx.popClass();
      return null;
    };
    _TsEmitterVisitor.prototype._visitClassField = function(field, ctx) {
      if (field.hasModifier(StmtModifier.Private)) {
        ctx.print("private ");
      }
      ctx.print(field.name);
      if (isPresent(field.type)) {
        ctx.print(":");
        field.type.visitType(this, ctx);
      } else {
        ctx.print(": any");
      }
      ctx.println(";");
    };
    _TsEmitterVisitor.prototype._visitClassGetter = function(getter, ctx) {
      if (getter.hasModifier(StmtModifier.Private)) {
        ctx.print("private ");
      }
      ctx.print("get " + getter.name + "()");
      if (isPresent(getter.type)) {
        ctx.print(":");
        getter.type.visitType(this, ctx);
      }
      ctx.println(" {");
      ctx.incIndent();
      this.visitAllStatements(getter.body, ctx);
      ctx.decIndent();
      ctx.println("}");
    };
    _TsEmitterVisitor.prototype._visitClassConstructor = function(stmt, ctx) {
      ctx.print("constructor(");
      this._visitParams(stmt.constructorMethod.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      this.visitAllStatements(stmt.constructorMethod.body, ctx);
      ctx.decIndent();
      ctx.println("}");
    };
    _TsEmitterVisitor.prototype._visitClassMethod = function(method, ctx) {
      if (method.hasModifier(StmtModifier.Private)) {
        ctx.print("private ");
      }
      ctx.print(method.name + "(");
      this._visitParams(method.params, ctx);
      ctx.print("):");
      if (isPresent(method.type)) {
        method.type.visitType(this, ctx);
      } else {
        ctx.print("void");
      }
      ctx.println(" {");
      ctx.incIndent();
      this.visitAllStatements(method.body, ctx);
      ctx.decIndent();
      ctx.println("}");
    };
    _TsEmitterVisitor.prototype.visitFunctionExpr = function(ast, ctx) {
      ctx.print("(");
      this._visitParams(ast.params, ctx);
      ctx.print("):");
      if (isPresent(ast.type)) {
        ast.type.visitType(this, ctx);
      } else {
        ctx.print("void");
      }
      ctx.println(" => {");
      ctx.incIndent();
      this.visitAllStatements(ast.statements, ctx);
      ctx.decIndent();
      ctx.print("}");
      return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      if (ctx.isExportedVar(stmt.name)) {
        ctx.print("export ");
      }
      ctx.print("function " + stmt.name + "(");
      this._visitParams(stmt.params, ctx);
      ctx.print("):");
      if (isPresent(stmt.type)) {
        stmt.type.visitType(this, ctx);
      } else {
        ctx.print("void");
      }
      ctx.println(" {");
      ctx.incIndent();
      this.visitAllStatements(stmt.statements, ctx);
      ctx.decIndent();
      ctx.println("}");
      return null;
    };
    _TsEmitterVisitor.prototype.visitTryCatchStmt = function(stmt, ctx) {
      ctx.println("try {");
      ctx.incIndent();
      this.visitAllStatements(stmt.bodyStmts, ctx);
      ctx.decIndent();
      ctx.println("} catch (" + CATCH_ERROR_VAR$1.name + ") {");
      ctx.incIndent();
      var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [StmtModifier.Final])].concat(stmt.catchStmts);
      this.visitAllStatements(catchStmts, ctx);
      ctx.decIndent();
      ctx.println("}");
      return null;
    };
    _TsEmitterVisitor.prototype.visitBuiltintType = function(type, ctx) {
      var typeStr;
      switch (type.name) {
        case BuiltinTypeName.Bool:
          typeStr = 'boolean';
          break;
        case BuiltinTypeName.Dynamic:
          typeStr = 'any';
          break;
        case BuiltinTypeName.Function:
          typeStr = 'Function';
          break;
        case BuiltinTypeName.Number:
          typeStr = 'number';
          break;
        case BuiltinTypeName.Int:
          typeStr = 'number';
          break;
        case BuiltinTypeName.String:
          typeStr = 'string';
          break;
        default:
          throw new BaseException$1("Unsupported builtin type " + type.name);
      }
      ctx.print(typeStr);
      return null;
    };
    _TsEmitterVisitor.prototype.visitExternalType = function(ast, ctx) {
      this._visitIdentifier(ast.value, ast.typeParams, ctx);
      return null;
    };
    _TsEmitterVisitor.prototype.visitArrayType = function(type, ctx) {
      if (isPresent(type.of)) {
        type.of.visitType(this, ctx);
      } else {
        ctx.print("any");
      }
      ctx.print("[]");
      return null;
    };
    _TsEmitterVisitor.prototype.visitMapType = function(type, ctx) {
      ctx.print("{[key: string]:");
      if (isPresent(type.valueType)) {
        type.valueType.visitType(this, ctx);
      } else {
        ctx.print("any");
      }
      ctx.print("}");
      return null;
    };
    _TsEmitterVisitor.prototype.getBuiltinMethodName = function(method) {
      var name;
      switch (method) {
        case BuiltinMethod.ConcatArray:
          name = 'concat';
          break;
        case BuiltinMethod.SubscribeObservable:
          name = 'subscribe';
          break;
        case BuiltinMethod.bind:
          name = 'bind';
          break;
        default:
          throw new BaseException$1("Unknown builtin method: " + method);
      }
      return name;
    };
    _TsEmitterVisitor.prototype._visitParams = function(params, ctx) {
      var _this = this;
      this.visitAllObjects(function(param) {
        ctx.print(param.name);
        if (isPresent(param.type)) {
          ctx.print(":");
          param.type.visitType(_this, ctx);
        }
      }, params, ctx, ',');
    };
    _TsEmitterVisitor.prototype._visitIdentifier = function(value, typeParams, ctx) {
      var _this = this;
      if (isBlank(value.name)) {
        throw new BaseException$1("Internal error: unknown identifier " + value);
      }
      if (isPresent(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {
        var prefix = this.importsWithPrefixes.get(value.moduleUrl);
        if (isBlank(prefix)) {
          prefix = "import" + this.importsWithPrefixes.size;
          this.importsWithPrefixes.set(value.moduleUrl, prefix);
        }
        ctx.print(prefix + ".");
      }
      ctx.print(value.name);
      if (isPresent(typeParams) && typeParams.length > 0) {
        ctx.print("<");
        this.visitAllObjects(function(type) {
          return type.visitType(_this, ctx);
        }, typeParams, ctx, ',');
        ctx.print(">");
      }
    };
    return _TsEmitterVisitor;
  }(AbstractEmitterVisitor));
  function interpretStatements(statements, resultVar, instanceFactory) {
    var stmtsWithReturn = statements.concat([new ReturnStatement(variable(resultVar))]);
    var ctx = new _ExecutionContext(null, null, null, null, new Map(), new Map(), new Map(), new Map(), instanceFactory);
    var visitor = new StatementInterpreter();
    var result = visitor.visitAllStatements(stmtsWithReturn, ctx);
    return isPresent(result) ? result.value : null;
  }
  var DynamicInstance = (function() {
    function DynamicInstance() {}
    Object.defineProperty(DynamicInstance.prototype, "props", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DynamicInstance.prototype, "getters", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DynamicInstance.prototype, "methods", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DynamicInstance.prototype, "clazz", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return DynamicInstance;
  }());
  function isDynamicInstance(instance) {
    if (IS_DART) {
      return instance instanceof DynamicInstance;
    } else {
      return isPresent(instance) && isPresent(instance.props) && isPresent(instance.getters) && isPresent(instance.methods);
    }
  }
  function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
    var childCtx = ctx.createChildWihtLocalVars();
    for (var i = 0; i < varNames.length; i++) {
      childCtx.vars.set(varNames[i], varValues[i]);
    }
    var result = visitor.visitAllStatements(statements, childCtx);
    return isPresent(result) ? result.value : null;
  }
  var _ExecutionContext = (function() {
    function _ExecutionContext(parent, superClass, superInstance, className, vars, props, getters, methods, instanceFactory) {
      this.parent = parent;
      this.superClass = superClass;
      this.superInstance = superInstance;
      this.className = className;
      this.vars = vars;
      this.props = props;
      this.getters = getters;
      this.methods = methods;
      this.instanceFactory = instanceFactory;
    }
    _ExecutionContext.prototype.createChildWihtLocalVars = function() {
      return new _ExecutionContext(this, this.superClass, this.superInstance, this.className, new Map(), this.props, this.getters, this.methods, this.instanceFactory);
    };
    return _ExecutionContext;
  }());
  var ReturnValue = (function() {
    function ReturnValue(value) {
      this.value = value;
    }
    return ReturnValue;
  }());
  var _DynamicClass = (function() {
    function _DynamicClass(_classStmt, _ctx, _visitor) {
      this._classStmt = _classStmt;
      this._ctx = _ctx;
      this._visitor = _visitor;
    }
    _DynamicClass.prototype.instantiate = function(args) {
      var _this = this;
      var props = new Map();
      var getters = new Map();
      var methods = new Map();
      var superClass = this._classStmt.parent.visitExpression(this._visitor, this._ctx);
      var instanceCtx = new _ExecutionContext(this._ctx, superClass, null, this._classStmt.name, this._ctx.vars, props, getters, methods, this._ctx.instanceFactory);
      this._classStmt.fields.forEach(function(field) {
        props.set(field.name, null);
      });
      this._classStmt.getters.forEach(function(getter) {
        getters.set(getter.name, function() {
          return _executeFunctionStatements([], [], getter.body, instanceCtx, _this._visitor);
        });
      });
      this._classStmt.methods.forEach(function(method) {
        var paramNames = method.params.map(function(param) {
          return param.name;
        });
        methods.set(method.name, _declareFn(paramNames, method.body, instanceCtx, _this._visitor));
      });
      var ctorParamNames = this._classStmt.constructorMethod.params.map(function(param) {
        return param.name;
      });
      _executeFunctionStatements(ctorParamNames, args, this._classStmt.constructorMethod.body, instanceCtx, this._visitor);
      return instanceCtx.superInstance;
    };
    _DynamicClass.prototype.debugAst = function() {
      return this._visitor.debugAst(this._classStmt);
    };
    return _DynamicClass;
  }());
  var StatementInterpreter = (function() {
    function StatementInterpreter() {}
    StatementInterpreter.prototype.debugAst = function(ast) {
      return IS_DART ? debugOutputAstAsDart(ast) : debugOutputAstAsTypeScript(ast);
    };
    StatementInterpreter.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));
      return null;
    };
    StatementInterpreter.prototype.visitWriteVarExpr = function(expr, ctx) {
      var value = expr.value.visitExpression(this, ctx);
      var currCtx = ctx;
      while (currCtx != null) {
        if (currCtx.vars.has(expr.name)) {
          currCtx.vars.set(expr.name, value);
          return value;
        }
        currCtx = currCtx.parent;
      }
      throw new BaseException$1("Not declared variable " + expr.name);
    };
    StatementInterpreter.prototype.visitReadVarExpr = function(ast, ctx) {
      var varName = ast.name;
      if (isPresent(ast.builtin)) {
        switch (ast.builtin) {
          case BuiltinVar.Super:
          case BuiltinVar.This:
            return ctx.superInstance;
          case BuiltinVar.CatchError:
            varName = CATCH_ERROR_VAR$2;
            break;
          case BuiltinVar.CatchStack:
            varName = CATCH_STACK_VAR$2;
            break;
          default:
            throw new BaseException$1("Unknown builtin variable " + ast.builtin);
        }
      }
      var currCtx = ctx;
      while (currCtx != null) {
        if (currCtx.vars.has(varName)) {
          return currCtx.vars.get(varName);
        }
        currCtx = currCtx.parent;
      }
      throw new BaseException$1("Not declared variable " + varName);
    };
    StatementInterpreter.prototype.visitWriteKeyExpr = function(expr, ctx) {
      var receiver = expr.receiver.visitExpression(this, ctx);
      var index = expr.index.visitExpression(this, ctx);
      var value = expr.value.visitExpression(this, ctx);
      receiver[index] = value;
      return value;
    };
    StatementInterpreter.prototype.visitWritePropExpr = function(expr, ctx) {
      var receiver = expr.receiver.visitExpression(this, ctx);
      var value = expr.value.visitExpression(this, ctx);
      if (isDynamicInstance(receiver)) {
        var di = receiver;
        if (di.props.has(expr.name)) {
          di.props.set(expr.name, value);
        } else {
          _angular_core.reflector.setter(expr.name)(receiver, value);
        }
      } else {
        _angular_core.reflector.setter(expr.name)(receiver, value);
      }
      return value;
    };
    StatementInterpreter.prototype.visitInvokeMethodExpr = function(expr, ctx) {
      var receiver = expr.receiver.visitExpression(this, ctx);
      var args = this.visitAllExpressions(expr.args, ctx);
      var result;
      if (isPresent(expr.builtin)) {
        switch (expr.builtin) {
          case BuiltinMethod.ConcatArray:
            result = ListWrapper.concat(receiver, args[0]);
            break;
          case BuiltinMethod.SubscribeObservable:
            result = ObservableWrapper.subscribe(receiver, args[0]);
            break;
          case BuiltinMethod.bind:
            if (IS_DART) {
              result = receiver;
            } else {
              result = receiver.bind(args[0]);
            }
            break;
          default:
            throw new BaseException$1("Unknown builtin method " + expr.builtin);
        }
      } else if (isDynamicInstance(receiver)) {
        var di = receiver;
        if (di.methods.has(expr.name)) {
          result = FunctionWrapper.apply(di.methods.get(expr.name), args);
        } else {
          result = _angular_core.reflector.method(expr.name)(receiver, args);
        }
      } else {
        result = _angular_core.reflector.method(expr.name)(receiver, args);
      }
      return result;
    };
    StatementInterpreter.prototype.visitInvokeFunctionExpr = function(stmt, ctx) {
      var args = this.visitAllExpressions(stmt.args, ctx);
      var fnExpr = stmt.fn;
      if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
        ctx.superInstance = ctx.instanceFactory.createInstance(ctx.superClass, ctx.className, args, ctx.props, ctx.getters, ctx.methods);
        ctx.parent.superInstance = ctx.superInstance;
        return null;
      } else {
        var fn = stmt.fn.visitExpression(this, ctx);
        return FunctionWrapper.apply(fn, args);
      }
    };
    StatementInterpreter.prototype.visitReturnStmt = function(stmt, ctx) {
      return new ReturnValue(stmt.value.visitExpression(this, ctx));
    };
    StatementInterpreter.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      var clazz = new _DynamicClass(stmt, ctx, this);
      ctx.vars.set(stmt.name, clazz);
      return null;
    };
    StatementInterpreter.prototype.visitExpressionStmt = function(stmt, ctx) {
      return stmt.expr.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitIfStmt = function(stmt, ctx) {
      var condition = stmt.condition.visitExpression(this, ctx);
      if (condition) {
        return this.visitAllStatements(stmt.trueCase, ctx);
      } else if (isPresent(stmt.falseCase)) {
        return this.visitAllStatements(stmt.falseCase, ctx);
      }
      return null;
    };
    StatementInterpreter.prototype.visitTryCatchStmt = function(stmt, ctx) {
      try {
        return this.visitAllStatements(stmt.bodyStmts, ctx);
      } catch (e) {
        var childCtx = ctx.createChildWihtLocalVars();
        childCtx.vars.set(CATCH_ERROR_VAR$2, e);
        childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);
        return this.visitAllStatements(stmt.catchStmts, childCtx);
      }
    };
    StatementInterpreter.prototype.visitThrowStmt = function(stmt, ctx) {
      throw stmt.error.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitCommentStmt = function(stmt, context) {
      return null;
    };
    StatementInterpreter.prototype.visitInstantiateExpr = function(ast, ctx) {
      var args = this.visitAllExpressions(ast.args, ctx);
      var clazz = ast.classExpr.visitExpression(this, ctx);
      if (clazz instanceof _DynamicClass) {
        return clazz.instantiate(args);
      } else {
        return FunctionWrapper.apply(_angular_core.reflector.factory(clazz), args);
      }
    };
    StatementInterpreter.prototype.visitLiteralExpr = function(ast, ctx) {
      return ast.value;
    };
    StatementInterpreter.prototype.visitExternalExpr = function(ast, ctx) {
      return ast.value.runtime;
    };
    StatementInterpreter.prototype.visitConditionalExpr = function(ast, ctx) {
      if (ast.condition.visitExpression(this, ctx)) {
        return ast.trueCase.visitExpression(this, ctx);
      } else if (isPresent(ast.falseCase)) {
        return ast.falseCase.visitExpression(this, ctx);
      }
      return null;
    };
    StatementInterpreter.prototype.visitNotExpr = function(ast, ctx) {
      return !ast.condition.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitCastExpr = function(ast, ctx) {
      return ast.value.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitFunctionExpr = function(ast, ctx) {
      var paramNames = ast.params.map(function(param) {
        return param.name;
      });
      return _declareFn(paramNames, ast.statements, ctx, this);
    };
    StatementInterpreter.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      var paramNames = stmt.params.map(function(param) {
        return param.name;
      });
      ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));
      return null;
    };
    StatementInterpreter.prototype.visitBinaryOperatorExpr = function(ast, ctx) {
      var _this = this;
      var lhs = function() {
        return ast.lhs.visitExpression(_this, ctx);
      };
      var rhs = function() {
        return ast.rhs.visitExpression(_this, ctx);
      };
      switch (ast.operator) {
        case BinaryOperator.Equals:
          return lhs() == rhs();
        case BinaryOperator.Identical:
          return lhs() === rhs();
        case BinaryOperator.NotEquals:
          return lhs() != rhs();
        case BinaryOperator.NotIdentical:
          return lhs() !== rhs();
        case BinaryOperator.And:
          return lhs() && rhs();
        case BinaryOperator.Or:
          return lhs() || rhs();
        case BinaryOperator.Plus:
          return lhs() + rhs();
        case BinaryOperator.Minus:
          return lhs() - rhs();
        case BinaryOperator.Divide:
          return lhs() / rhs();
        case BinaryOperator.Multiply:
          return lhs() * rhs();
        case BinaryOperator.Modulo:
          return lhs() % rhs();
        case BinaryOperator.Lower:
          return lhs() < rhs();
        case BinaryOperator.LowerEquals:
          return lhs() <= rhs();
        case BinaryOperator.Bigger:
          return lhs() > rhs();
        case BinaryOperator.BiggerEquals:
          return lhs() >= rhs();
        default:
          throw new BaseException$1("Unknown operator " + ast.operator);
      }
    };
    StatementInterpreter.prototype.visitReadPropExpr = function(ast, ctx) {
      var result;
      var receiver = ast.receiver.visitExpression(this, ctx);
      if (isDynamicInstance(receiver)) {
        var di = receiver;
        if (di.props.has(ast.name)) {
          result = di.props.get(ast.name);
        } else if (di.getters.has(ast.name)) {
          result = di.getters.get(ast.name)();
        } else if (di.methods.has(ast.name)) {
          result = di.methods.get(ast.name);
        } else {
          result = _angular_core.reflector.getter(ast.name)(receiver);
        }
      } else {
        result = _angular_core.reflector.getter(ast.name)(receiver);
      }
      return result;
    };
    StatementInterpreter.prototype.visitReadKeyExpr = function(ast, ctx) {
      var receiver = ast.receiver.visitExpression(this, ctx);
      var prop = ast.index.visitExpression(this, ctx);
      return receiver[prop];
    };
    StatementInterpreter.prototype.visitLiteralArrayExpr = function(ast, ctx) {
      return this.visitAllExpressions(ast.entries, ctx);
    };
    StatementInterpreter.prototype.visitLiteralMapExpr = function(ast, ctx) {
      var _this = this;
      var result = {};
      ast.entries.forEach(function(entry) {
        return result[entry[0]] = entry[1].visitExpression(_this, ctx);
      });
      return result;
    };
    StatementInterpreter.prototype.visitAllExpressions = function(expressions, ctx) {
      var _this = this;
      return expressions.map(function(expr) {
        return expr.visitExpression(_this, ctx);
      });
    };
    StatementInterpreter.prototype.visitAllStatements = function(statements, ctx) {
      for (var i = 0; i < statements.length; i++) {
        var stmt = statements[i];
        var val = stmt.visitStatement(this, ctx);
        if (val instanceof ReturnValue) {
          return val;
        }
      }
      return null;
    };
    return StatementInterpreter;
  }());
  function _declareFn(varNames, statements, ctx, visitor) {
    switch (varNames.length) {
      case 0:
        return function() {
          return _executeFunctionStatements(varNames, [], statements, ctx, visitor);
        };
      case 1:
        return function(d0) {
          return _executeFunctionStatements(varNames, [d0], statements, ctx, visitor);
        };
      case 2:
        return function(d0, d1) {
          return _executeFunctionStatements(varNames, [d0, d1], statements, ctx, visitor);
        };
      case 3:
        return function(d0, d1, d2) {
          return _executeFunctionStatements(varNames, [d0, d1, d2], statements, ctx, visitor);
        };
      case 4:
        return function(d0, d1, d2, d3) {
          return _executeFunctionStatements(varNames, [d0, d1, d2, d3], statements, ctx, visitor);
        };
      case 5:
        return function(d0, d1, d2, d3, d4) {
          return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4], statements, ctx, visitor);
        };
      case 6:
        return function(d0, d1, d2, d3, d4, d5) {
          return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5], statements, ctx, visitor);
        };
      case 7:
        return function(d0, d1, d2, d3, d4, d5, d6) {
          return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6], statements, ctx, visitor);
        };
      case 8:
        return function(d0, d1, d2, d3, d4, d5, d6, d7) {
          return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6, d7], statements, ctx, visitor);
        };
      case 9:
        return function(d0, d1, d2, d3, d4, d5, d6, d7, d8) {
          return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6, d7, d8], statements, ctx, visitor);
        };
      case 10:
        return function(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9) {
          return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6, d7, d8, d9], statements, ctx, visitor);
        };
      default:
        throw new BaseException$1('Declaring functions with more than 10 arguments is not supported right now');
    }
  }
  var CATCH_ERROR_VAR$2 = 'error';
  var CATCH_STACK_VAR$2 = 'stack';
  var InterpretiveAppViewInstanceFactory = (function() {
    function InterpretiveAppViewInstanceFactory() {}
    InterpretiveAppViewInstanceFactory.prototype.createInstance = function(superClass, clazz, args, props, getters, methods) {
      if (superClass === AppView) {
        args = args.concat([null]);
        return new _InterpretiveAppView(args, props, getters, methods);
      } else if (superClass === DebugAppView) {
        return new _InterpretiveAppView(args, props, getters, methods);
      }
      throw new BaseException$1("Can't instantiate class " + superClass + " in interpretative mode");
    };
    return InterpretiveAppViewInstanceFactory;
  }());
  var _InterpretiveAppView = (function(_super) {
    __extends(_InterpretiveAppView, _super);
    function _InterpretiveAppView(args, props, getters, methods) {
      _super.call(this, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
      this.props = props;
      this.getters = getters;
      this.methods = methods;
    }
    _InterpretiveAppView.prototype.createInternal = function(rootSelector) {
      var m = this.methods.get('createInternal');
      if (isPresent(m)) {
        return m(rootSelector);
      } else {
        return _super.prototype.createInternal.call(this, rootSelector);
      }
    };
    _InterpretiveAppView.prototype.injectorGetInternal = function(token, nodeIndex, notFoundResult) {
      var m = this.methods.get('injectorGetInternal');
      if (isPresent(m)) {
        return m(token, nodeIndex, notFoundResult);
      } else {
        return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
      }
    };
    _InterpretiveAppView.prototype.destroyInternal = function() {
      var m = this.methods.get('destroyInternal');
      if (isPresent(m)) {
        return m();
      } else {
        return _super.prototype.destroyInternal.call(this);
      }
    };
    _InterpretiveAppView.prototype.dirtyParentQueriesInternal = function() {
      var m = this.methods.get('dirtyParentQueriesInternal');
      if (isPresent(m)) {
        return m();
      } else {
        return _super.prototype.dirtyParentQueriesInternal.call(this);
      }
    };
    _InterpretiveAppView.prototype.detectChangesInternal = function(throwOnChange) {
      var m = this.methods.get('detectChangesInternal');
      if (isPresent(m)) {
        return m(throwOnChange);
      } else {
        return _super.prototype.detectChangesInternal.call(this, throwOnChange);
      }
    };
    return _InterpretiveAppView;
  }(DebugAppView));
  var RuntimeCompiler = (function() {
    function RuntimeCompiler(_metadataResolver, _templateNormalizer, _templateParser, _styleCompiler, _viewCompiler, _xhr, _genConfig) {
      this._metadataResolver = _metadataResolver;
      this._templateNormalizer = _templateNormalizer;
      this._templateParser = _templateParser;
      this._styleCompiler = _styleCompiler;
      this._viewCompiler = _viewCompiler;
      this._xhr = _xhr;
      this._genConfig = _genConfig;
      this._styleCache = new Map();
      this._hostCacheKeys = new Map();
      this._compiledTemplateCache = new Map();
      this._compiledTemplateDone = new Map();
    }
    RuntimeCompiler.prototype.resolveComponent = function(componentType) {
      var compMeta = this._metadataResolver.getDirectiveMetadata(componentType);
      var hostCacheKey = this._hostCacheKeys.get(componentType);
      if (isBlank(hostCacheKey)) {
        hostCacheKey = new Object();
        this._hostCacheKeys.set(componentType, hostCacheKey);
        assertComponent(compMeta);
        var hostMeta = createHostComponentMeta(compMeta.type, compMeta.selector);
        this._loadAndCompileComponent(hostCacheKey, hostMeta, [compMeta], [], []);
      }
      return this._compiledTemplateDone.get(hostCacheKey).then(function(compiledTemplate) {
        return new _angular_core.ComponentFactory(compMeta.selector, compiledTemplate.viewFactory, componentType);
      });
    };
    RuntimeCompiler.prototype.clearCache = function() {
      this._styleCache.clear();
      this._compiledTemplateCache.clear();
      this._compiledTemplateDone.clear();
      this._hostCacheKeys.clear();
    };
    RuntimeCompiler.prototype._loadAndCompileComponent = function(cacheKey, compMeta, viewDirectives, pipes, compilingComponentsPath) {
      var _this = this;
      var compiledTemplate = this._compiledTemplateCache.get(cacheKey);
      var done = this._compiledTemplateDone.get(cacheKey);
      if (isBlank(compiledTemplate)) {
        compiledTemplate = new CompiledTemplate();
        this._compiledTemplateCache.set(cacheKey, compiledTemplate);
        done = PromiseWrapper.all([this._compileComponentStyles(compMeta)].concat(viewDirectives.map(function(dirMeta) {
          return _this._templateNormalizer.normalizeDirective(dirMeta);
        }))).then(function(stylesAndNormalizedViewDirMetas) {
          var normalizedViewDirMetas = stylesAndNormalizedViewDirMetas.slice(1);
          var styles = stylesAndNormalizedViewDirMetas[0];
          var parsedTemplate = _this._templateParser.parse(compMeta, compMeta.template.template, normalizedViewDirMetas, pipes, compMeta.type.name);
          var childPromises = [];
          compiledTemplate.init(_this._compileComponent(compMeta, parsedTemplate, styles, pipes, compilingComponentsPath, childPromises));
          return PromiseWrapper.all(childPromises).then(function(_) {
            return compiledTemplate;
          });
        });
        this._compiledTemplateDone.set(cacheKey, done);
      }
      return compiledTemplate;
    };
    RuntimeCompiler.prototype._compileComponent = function(compMeta, parsedTemplate, styles, pipes, compilingComponentsPath, childPromises) {
      var _this = this;
      var compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, new ExternalExpr(new CompileIdentifierMetadata({runtime: styles})), pipes);
      compileResult.dependencies.forEach(function(dep) {
        var childCompilingComponentsPath = ListWrapper.clone(compilingComponentsPath);
        var childCacheKey = dep.comp.type.runtime;
        var childViewDirectives = _this._metadataResolver.getViewDirectivesMetadata(dep.comp.type.runtime);
        var childViewPipes = _this._metadataResolver.getViewPipesMetadata(dep.comp.type.runtime);
        var childIsRecursive = ListWrapper.contains(childCompilingComponentsPath, childCacheKey);
        childCompilingComponentsPath.push(childCacheKey);
        var childComp = _this._loadAndCompileComponent(dep.comp.type.runtime, dep.comp, childViewDirectives, childViewPipes, childCompilingComponentsPath);
        dep.factoryPlaceholder.runtime = childComp.proxyViewFactory;
        dep.factoryPlaceholder.name = "viewFactory_" + dep.comp.type.name;
        if (!childIsRecursive) {
          childPromises.push(_this._compiledTemplateDone.get(childCacheKey));
        }
      });
      var factory;
      if (IS_DART || !this._genConfig.useJit) {
        factory = interpretStatements(compileResult.statements, compileResult.viewFactoryVar, new InterpretiveAppViewInstanceFactory());
      } else {
        factory = jitStatements(compMeta.type.name + ".template.js", compileResult.statements, compileResult.viewFactoryVar);
      }
      return factory;
    };
    RuntimeCompiler.prototype._compileComponentStyles = function(compMeta) {
      var compileResult = this._styleCompiler.compileComponent(compMeta);
      return this._resolveStylesCompileResult(compMeta.type.name, compileResult);
    };
    RuntimeCompiler.prototype._resolveStylesCompileResult = function(sourceUrl, result) {
      var _this = this;
      var promises = result.dependencies.map(function(dep) {
        return _this._loadStylesheetDep(dep);
      });
      return PromiseWrapper.all(promises).then(function(cssTexts) {
        var nestedCompileResultPromises = [];
        for (var i = 0; i < result.dependencies.length; i++) {
          var dep = result.dependencies[i];
          var cssText = cssTexts[i];
          var nestedCompileResult = _this._styleCompiler.compileStylesheet(dep.moduleUrl, cssText, dep.isShimmed);
          nestedCompileResultPromises.push(_this._resolveStylesCompileResult(dep.moduleUrl, nestedCompileResult));
        }
        return PromiseWrapper.all(nestedCompileResultPromises);
      }).then(function(nestedStylesArr) {
        for (var i = 0; i < result.dependencies.length; i++) {
          var dep = result.dependencies[i];
          dep.valuePlaceholder.runtime = nestedStylesArr[i];
          dep.valuePlaceholder.name = "importedStyles" + i;
        }
        if (IS_DART || !_this._genConfig.useJit) {
          return interpretStatements(result.statements, result.stylesVar, new InterpretiveAppViewInstanceFactory());
        } else {
          return jitStatements(sourceUrl + ".css.js", result.statements, result.stylesVar);
        }
      });
    };
    RuntimeCompiler.prototype._loadStylesheetDep = function(dep) {
      var cacheKey = "" + dep.moduleUrl + (dep.isShimmed ? '.shim' : '');
      var cssTextPromise = this._styleCache.get(cacheKey);
      if (isBlank(cssTextPromise)) {
        cssTextPromise = this._xhr.get(dep.moduleUrl);
        this._styleCache.set(cacheKey, cssTextPromise);
      }
      return cssTextPromise;
    };
    return RuntimeCompiler;
  }());
  RuntimeCompiler.decorators = [{type: _angular_core.Injectable}];
  RuntimeCompiler.ctorParameters = [{type: CompileMetadataResolver}, {type: DirectiveNormalizer}, {type: TemplateParser}, {type: StyleCompiler}, {type: ViewCompiler}, {type: XHR}, {type: CompilerConfig}];
  var CompiledTemplate = (function() {
    function CompiledTemplate() {
      var _this = this;
      this.viewFactory = null;
      this.proxyViewFactory = function(viewUtils, childInjector, contextEl) {
        return _this.viewFactory(viewUtils, childInjector, contextEl);
      };
    }
    CompiledTemplate.prototype.init = function(viewFactory) {
      this.viewFactory = viewFactory;
    };
    return CompiledTemplate;
  }());
  function assertComponent(meta) {
    if (!meta.isComponent) {
      throw new BaseException$1("Could not compile '" + meta.type.name + "' because it is not a component.");
    }
  }
  var BOOLEAN = 'boolean';
  var NUMBER = 'number';
  var STRING = 'string';
  var OBJECT = 'object';
  var SCHEMA = (['*|%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop', '^*|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*autocomplete,*autocompleteerror,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'media|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,#volume', '@svg:^*|*abort,*autocomplete,*autocompleteerror,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex', '@svg:graphics^@svg:|', '@svg:animation^@svg:|*begin,*end,*repeat', '@svg:geometry^@svg:|', '@svg:componentTransferFunction^@svg:|', '@svg:gradient^@svg:|', '@svg:textContent^@svg:graphics|', '@svg:textPositioning^@svg:textContent|', 'a|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,rel,rev,search,shape,target,text,type,username', 'area|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,search,shape,target,username', 'audio^media|', 'br|clear', 'base|href,target', 'body|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas|#height,#width', 'content|select', 'dl|!compact', 'datalist|', 'details|!open', 'dialog|!open,returnValue', 'dir|!compact', 'div|align', 'embed|align,height,name,src,type,width', 'fieldset|!disabled,name', 'font|color,face,size', 'form|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr|align,color,!noShade,size,width', 'head|', 'h1,h2,h3,h4,h5,h6|align', 'html|version', 'iframe|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,%sandbox,scrolling,src,srcdoc,width', 'img|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,sizes,src,srcset,useMap,#vspace,#width', 'input|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'keygen|!autofocus,challenge,!disabled,keytype,name', 'li|type,#value', 'label|htmlFor', 'legend|align', 'link|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type', 'map|name', 'marquee|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu|!compact', 'meta|content,httpEquiv,name,scheme', 'meter|#high,#low,#max,#min,#optimum,#value', 'ins,del|cite,dateTime', 'ol|!compact,!reversed,#start,type', 'object|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup|!disabled,label', 'option|!defaultSelected,!disabled,label,!selected,text,value', 'output|defaultValue,%htmlFor,name,value', 'p|align', 'param|name,type,value,valueType', 'picture|', 'pre|#width', 'progress|#max,#value', 'q,blockquote,cite|', 'script|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type', 'select|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'shadow|', 'source|media,sizes,src,srcset,type', 'span|', 'style|!disabled,media,type', 'caption|align', 'th,td|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup|align,ch,chOff,#span,vAlign,width', 'table|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody|align,ch,chOff,vAlign', 'template|', 'textarea|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'title|text', 'track|!default,kind,label,src,srclang', 'ul|!compact,type', 'unknown|', 'video^media|#height,poster,#width', '@svg:a^@svg:graphics|', '@svg:animate^@svg:animation|', '@svg:animateMotion^@svg:animation|', '@svg:animateTransform^@svg:animation|', '@svg:circle^@svg:geometry|', '@svg:clipPath^@svg:graphics|', '@svg:cursor^@svg:|', '@svg:defs^@svg:graphics|', '@svg:desc^@svg:|', '@svg:discard^@svg:|', '@svg:ellipse^@svg:geometry|', '@svg:feBlend^@svg:|', '@svg:feColorMatrix^@svg:|', '@svg:feComponentTransfer^@svg:|', '@svg:feComposite^@svg:|', '@svg:feConvolveMatrix^@svg:|', '@svg:feDiffuseLighting^@svg:|', '@svg:feDisplacementMap^@svg:|', '@svg:feDistantLight^@svg:|', '@svg:feDropShadow^@svg:|', '@svg:feFlood^@svg:|', '@svg:feFuncA^@svg:componentTransferFunction|', '@svg:feFuncB^@svg:componentTransferFunction|', '@svg:feFuncG^@svg:componentTransferFunction|', '@svg:feFuncR^@svg:componentTransferFunction|', '@svg:feGaussianBlur^@svg:|', '@svg:feImage^@svg:|', '@svg:feMerge^@svg:|', '@svg:feMergeNode^@svg:|', '@svg:feMorphology^@svg:|', '@svg:feOffset^@svg:|', '@svg:fePointLight^@svg:|', '@svg:feSpecularLighting^@svg:|', '@svg:feSpotLight^@svg:|', '@svg:feTile^@svg:|', '@svg:feTurbulence^@svg:|', '@svg:filter^@svg:|', '@svg:foreignObject^@svg:graphics|', '@svg:g^@svg:graphics|', '@svg:image^@svg:graphics|', '@svg:line^@svg:geometry|', '@svg:linearGradient^@svg:gradient|', '@svg:mpath^@svg:|', '@svg:marker^@svg:|', '@svg:mask^@svg:|', '@svg:metadata^@svg:|', '@svg:path^@svg:geometry|', '@svg:pattern^@svg:|', '@svg:polygon^@svg:geometry|', '@svg:polyline^@svg:geometry|', '@svg:radialGradient^@svg:gradient|', '@svg:rect^@svg:geometry|', '@svg:svg^@svg:graphics|#currentScale,#zoomAndPan', '@svg:script^@svg:|type', '@svg:set^@svg:animation|', '@svg:stop^@svg:|', '@svg:style^@svg:|!disabled,media,title,type', '@svg:switch^@svg:graphics|', '@svg:symbol^@svg:|', '@svg:tspan^@svg:textPositioning|', '@svg:text^@svg:textPositioning|', '@svg:textPath^@svg:textContent|', '@svg:title^@svg:|', '@svg:use^@svg:graphics|', '@svg:view^@svg:|#zoomAndPan']);
  var attrToPropMap = {
    'class': 'className',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex'
  };
  var DomElementSchemaRegistry = (function(_super) {
    __extends(DomElementSchemaRegistry, _super);
    function DomElementSchemaRegistry() {
      var _this = this;
      _super.call(this);
      this.schema = {};
      SCHEMA.forEach(function(encodedType) {
        var parts = encodedType.split('|');
        var properties = parts[1].split(',');
        var typeParts = (parts[0] + '^').split('^');
        var typeName = typeParts[0];
        var type = {};
        typeName.split(',').forEach(function(tag) {
          return _this.schema[tag] = type;
        });
        var superType = _this.schema[typeParts[1]];
        if (isPresent(superType)) {
          StringMapWrapper.forEach(superType, function(v, k) {
            return type[k] = v;
          });
        }
        properties.forEach(function(property) {
          if (property == '') {} else if (property.startsWith('*')) {} else if (property.startsWith('!')) {
            type[property.substring(1)] = BOOLEAN;
          } else if (property.startsWith('#')) {
            type[property.substring(1)] = NUMBER;
          } else if (property.startsWith('%')) {
            type[property.substring(1)] = OBJECT;
          } else {
            type[property] = STRING;
          }
        });
      });
    }
    DomElementSchemaRegistry.prototype.hasProperty = function(tagName, propName) {
      if (tagName.indexOf('-') !== -1) {
        return true;
      } else {
        var elementProperties = this.schema[tagName.toLowerCase()];
        if (!isPresent(elementProperties)) {
          elementProperties = this.schema['unknown'];
        }
        return isPresent(elementProperties[propName]);
      }
    };
    DomElementSchemaRegistry.prototype.securityContext = function(tagName, propName) {
      if (propName === 'style')
        return SecurityContext.STYLE;
      if (tagName === 'a' && propName === 'href')
        return SecurityContext.URL;
      if (propName === 'innerHTML')
        return SecurityContext.HTML;
      return SecurityContext.NONE;
    };
    DomElementSchemaRegistry.prototype.getMappedPropName = function(propName) {
      var mappedPropName = StringMapWrapper.get(attrToPropMap, propName);
      return isPresent(mappedPropName) ? mappedPropName : propName;
    };
    return DomElementSchemaRegistry;
  }(ElementSchemaRegistry));
  DomElementSchemaRegistry.decorators = [{type: _angular_core.Injectable}];
  DomElementSchemaRegistry.ctorParameters = [];
  function _createCompilerConfig() {
    return new CompilerConfig(assertionsEnabled(), false, true);
  }
  var COMPILER_PROVIDERS = [Lexer, Parser, HtmlParser, TemplateParser, DirectiveNormalizer, CompileMetadataResolver, DEFAULT_PACKAGE_URL_PROVIDER, StyleCompiler, ViewCompiler, {
    provide: CompilerConfig,
    useFactory: _createCompilerConfig,
    deps: []
  }, RuntimeCompiler, {
    provide: _angular_core.ComponentResolver,
    useExisting: RuntimeCompiler
  }, DomElementSchemaRegistry, {
    provide: ElementSchemaRegistry,
    useExisting: DomElementSchemaRegistry
  }, UrlResolver, ViewResolver, DirectiveResolver, PipeResolver];
  var _ASSET_URL_RE = /asset:([^\/]+)\/([^\/]+)\/(.+)/g;
  var ImportGenerator = (function() {
    function ImportGenerator() {}
    ImportGenerator.parseAssetUrl = function(url) {
      return AssetUrl.parse(url);
    };
    return ImportGenerator;
  }());
  var AssetUrl = (function() {
    function AssetUrl(packageName, firstLevelDir, modulePath) {
      this.packageName = packageName;
      this.firstLevelDir = firstLevelDir;
      this.modulePath = modulePath;
    }
    AssetUrl.parse = function(url, allowNonMatching) {
      if (allowNonMatching === void 0) {
        allowNonMatching = true;
      }
      var match = RegExpWrapper.firstMatch(_ASSET_URL_RE, url);
      if (isPresent(match)) {
        return new AssetUrl(match[1], match[2], match[3]);
      }
      if (allowNonMatching) {
        return null;
      }
      throw new BaseException$1("Url " + url + " is not a valid asset: url");
    };
    return AssetUrl;
  }());
  exports.__compiler_private__;
  (function(__compiler_private__) {
    __compiler_private__.SelectorMatcher = SelectorMatcher;
    __compiler_private__.CssSelector = CssSelector;
    __compiler_private__.AssetUrl = AssetUrl;
    __compiler_private__.ImportGenerator = ImportGenerator;
  })(exports.__compiler_private__ || (exports.__compiler_private__ = {}));
  exports.ElementSchemaRegistry = ElementSchemaRegistry;
  exports.COMPILER_PROVIDERS = COMPILER_PROVIDERS;
  exports.TEMPLATE_TRANSFORMS = TEMPLATE_TRANSFORMS;
  exports.CompilerConfig = CompilerConfig;
  exports.RenderTypes = RenderTypes;
  exports.UrlResolver = UrlResolver;
  exports.DEFAULT_PACKAGE_URL_PROVIDER = DEFAULT_PACKAGE_URL_PROVIDER;
  exports.createOfflineCompileUrlResolver = createOfflineCompileUrlResolver;
  exports.XHR = XHR;
  exports.ViewResolver = ViewResolver;
  exports.DirectiveResolver = DirectiveResolver;
  exports.PipeResolver = PipeResolver;
  exports.SourceModule = SourceModule;
  exports.NormalizedComponentWithViewDirectives = NormalizedComponentWithViewDirectives;
  exports.OfflineCompiler = OfflineCompiler;
  exports.CompileMetadataWithIdentifier = CompileMetadataWithIdentifier;
  exports.CompileMetadataWithType = CompileMetadataWithType;
  exports.CompileIdentifierMetadata = CompileIdentifierMetadata;
  exports.CompileDiDependencyMetadata = CompileDiDependencyMetadata;
  exports.CompileProviderMetadata = CompileProviderMetadata;
  exports.CompileFactoryMetadata = CompileFactoryMetadata;
  exports.CompileTokenMetadata = CompileTokenMetadata;
  exports.CompileTypeMetadata = CompileTypeMetadata;
  exports.CompileQueryMetadata = CompileQueryMetadata;
  exports.CompileTemplateMetadata = CompileTemplateMetadata;
  exports.CompileDirectiveMetadata = CompileDirectiveMetadata;
  exports.CompilePipeMetadata = CompilePipeMetadata;
  exports.TextAst = TextAst;
  exports.BoundTextAst = BoundTextAst;
  exports.AttrAst = AttrAst;
  exports.BoundElementPropertyAst = BoundElementPropertyAst;
  exports.BoundEventAst = BoundEventAst;
  exports.ReferenceAst = ReferenceAst;
  exports.VariableAst = VariableAst;
  exports.ElementAst = ElementAst;
  exports.EmbeddedTemplateAst = EmbeddedTemplateAst;
  exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;
  exports.DirectiveAst = DirectiveAst;
  exports.ProviderAst = ProviderAst;
  exports.NgContentAst = NgContentAst;
  exports.templateVisitAll = templateVisitAll;
}));

})();
(function() {
var define = $__System.amdDefine;
var __extends = (this && this.__extends) || function(d, b) {
  for (var p in b)
    if (b.hasOwnProperty(p))
      d[p] = b[p];
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Subject'), require('rxjs/observable/PromiseObservable'), require('rxjs/operator/toPromise'), require('rxjs/Observable')) : typeof define === 'function' && define.amd ? define("8", ["exports", "3", "4", "5", "6", "7"], factory) : (factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}), global.ng.core, global.Rx, global.Rx, global.Rx.Observable.prototype, global.Rx));
}(this, function(exports, _angular_core, rxjs_Subject, rxjs_observable_PromiseObservable, rxjs_operator_toPromise, rxjs_Observable) {
  'use strict';
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  var global$1 = globalScope;
  function getTypeNameForDebugging(type) {
    if (type['name']) {
      return type['name'];
    }
    return typeof type;
  }
  var Date = global$1.Date;
  global$1.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  function isNumber(obj) {
    return typeof obj === "number";
  }
  function isString(obj) {
    return typeof obj === "string";
  }
  function isFunction(obj) {
    return typeof obj === "function";
  }
  function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
  }
  function isPromise(obj) {
    return obj instanceof global$1.Promise;
  }
  function isArray(obj) {
    return Array.isArray(obj);
  }
  function isDate(obj) {
    return obj instanceof Date && !isNaN(obj.valueOf());
  }
  function noop() {}
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.name) {
      return token.name;
    }
    if (token.overriddenName) {
      return token.overriddenName;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  var StringWrapper = (function() {
    function StringWrapper() {}
    StringWrapper.fromCharCode = function(code) {
      return String.fromCharCode(code);
    };
    StringWrapper.charCodeAt = function(s, index) {
      return s.charCodeAt(index);
    };
    StringWrapper.split = function(s, regExp) {
      return s.split(regExp);
    };
    StringWrapper.equals = function(s, s2) {
      return s === s2;
    };
    StringWrapper.stripLeft = function(s, charVal) {
      if (s && s.length) {
        var pos = 0;
        for (var i = 0; i < s.length; i++) {
          if (s[i] != charVal)
            break;
          pos++;
        }
        s = s.substring(pos);
      }
      return s;
    };
    StringWrapper.stripRight = function(s, charVal) {
      if (s && s.length) {
        var pos = s.length;
        for (var i = s.length - 1; i >= 0; i--) {
          if (s[i] != charVal)
            break;
          pos--;
        }
        s = s.substring(0, pos);
      }
      return s;
    };
    StringWrapper.replace = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.slice = function(s, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function(s, from, cb) {
      return s.replace(from, function() {
        var matches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          matches[_i - 0] = arguments[_i];
        }
        matches.splice(-2, 2);
        return cb(matches);
      });
    };
    StringWrapper.contains = function(s, substr) {
      return s.indexOf(substr) != -1;
    };
    StringWrapper.compare = function(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    return StringWrapper;
  }());
  var NumberParseError = (function(_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
      _super.call(this);
      this.message = message;
    }
    NumberParseError.prototype.toString = function() {
      return this.message;
    };
    return NumberParseError;
  }(Error));
  var NumberWrapper = (function() {
    function NumberWrapper() {}
    NumberWrapper.toFixed = function(n, fractionDigits) {
      return n.toFixed(fractionDigits);
    };
    NumberWrapper.equal = function(a, b) {
      return a === b;
    };
    NumberWrapper.parseIntAutoRadix = function(text) {
      var result = parseInt(text);
      if (isNaN(result)) {
        throw new NumberParseError("Invalid integer literal when parsing " + text);
      }
      return result;
    };
    NumberWrapper.parseInt = function(text, radix) {
      if (radix == 10) {
        if (/^(\-|\+)?[0-9]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else if (radix == 16) {
        if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else {
        var result = parseInt(text, radix);
        if (!isNaN(result)) {
          return result;
        }
      }
      throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " + radix);
    };
    NumberWrapper.parseFloat = function(text) {
      return parseFloat(text);
    };
    Object.defineProperty(NumberWrapper, "NaN", {
      get: function() {
        return NaN;
      },
      enumerable: true,
      configurable: true
    });
    NumberWrapper.isNaN = function(value) {
      return isNaN(value);
    };
    NumberWrapper.isInteger = function(value) {
      return Number.isInteger(value);
    };
    return NumberWrapper;
  }());
  var RegExpWrapper = (function() {
    function RegExpWrapper() {}
    RegExpWrapper.create = function(regExpStr, flags) {
      if (flags === void 0) {
        flags = '';
      }
      flags = flags.replace(/g/g, '');
      return new global$1.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function(regExp, input) {
      regExp.lastIndex = 0;
      return regExp.exec(input);
    };
    RegExpWrapper.test = function(regExp, input) {
      regExp.lastIndex = 0;
      return regExp.test(input);
    };
    RegExpWrapper.matcher = function(regExp, input) {
      regExp.lastIndex = 0;
      return {
        re: regExp,
        input: input
      };
    };
    RegExpWrapper.replaceAll = function(regExp, input, replace) {
      var c = regExp.exec(input);
      var res = '';
      regExp.lastIndex = 0;
      var prev = 0;
      while (c) {
        res += input.substring(prev, c.index);
        res += replace(c);
        prev = c.index + c[0].length;
        regExp.lastIndex = prev;
        c = regExp.exec(input);
      }
      res += input.substring(prev);
      return res;
    };
    return RegExpWrapper;
  }());
  function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
  }
  function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
  }
  function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
  }
  function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
  }
  var Json = (function() {
    function Json() {}
    Json.parse = function(s) {
      return global$1.JSON.parse(s);
    };
    Json.stringify = function(data) {
      return global$1.JSON.stringify(data, null, 2);
    };
    return Json;
  }());
  var DateWrapper = (function() {
    function DateWrapper() {}
    DateWrapper.create = function(year, month, day, hour, minutes, seconds, milliseconds) {
      if (month === void 0) {
        month = 1;
      }
      if (day === void 0) {
        day = 1;
      }
      if (hour === void 0) {
        hour = 0;
      }
      if (minutes === void 0) {
        minutes = 0;
      }
      if (seconds === void 0) {
        seconds = 0;
      }
      if (milliseconds === void 0) {
        milliseconds = 0;
      }
      return new Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function(str) {
      return new Date(str);
    };
    DateWrapper.fromMillis = function(ms) {
      return new Date(ms);
    };
    DateWrapper.toMillis = function(date) {
      return date.getTime();
    };
    DateWrapper.now = function() {
      return new Date();
    };
    DateWrapper.toJson = function(date) {
      return date.toJSON();
    };
    return DateWrapper;
  }());
  var _symbolIterator = null;
  function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
      if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
        _symbolIterator = Symbol.iterator;
      } else {
        var keys = Object.getOwnPropertyNames(Map.prototype);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  function isPrimitive(obj) {
    return !isJsObject(obj);
  }
  function hasConstructor(value, type) {
    return value.constructor === type;
  }
  var PromiseCompleter = (function() {
    function PromiseCompleter() {
      var _this = this;
      this.promise = new Promise(function(res, rej) {
        _this.resolve = res;
        _this.reject = rej;
      });
    }
    return PromiseCompleter;
  }());
  var PromiseWrapper = (function() {
    function PromiseWrapper() {}
    PromiseWrapper.resolve = function(obj) {
      return Promise.resolve(obj);
    };
    PromiseWrapper.reject = function(obj, _) {
      return Promise.reject(obj);
    };
    PromiseWrapper.catchError = function(promise, onError) {
      return promise.catch(onError);
    };
    PromiseWrapper.all = function(promises) {
      if (promises.length == 0)
        return Promise.resolve([]);
      return Promise.all(promises);
    };
    PromiseWrapper.then = function(promise, success, rejection) {
      return promise.then(success, rejection);
    };
    PromiseWrapper.wrap = function(computation) {
      return new Promise(function(res, rej) {
        try {
          res(computation());
        } catch (e) {
          rej(e);
        }
      });
    };
    PromiseWrapper.scheduleMicrotask = function(computation) {
      PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function(_) {});
    };
    PromiseWrapper.isPromise = function(obj) {
      return obj instanceof Promise;
    };
    PromiseWrapper.completer = function() {
      return new PromiseCompleter();
    };
    return PromiseWrapper;
  }());
  var ObservableWrapper = (function() {
    function ObservableWrapper() {}
    ObservableWrapper.subscribe = function(emitter, onNext, onError, onComplete) {
      if (onComplete === void 0) {
        onComplete = function() {};
      }
      onError = (typeof onError === "function") && onError || noop;
      onComplete = (typeof onComplete === "function") && onComplete || noop;
      return emitter.subscribe({
        next: onNext,
        error: onError,
        complete: onComplete
      });
    };
    ObservableWrapper.isObservable = function(obs) {
      return !!obs.subscribe;
    };
    ObservableWrapper.hasSubscribers = function(obs) {
      return obs.observers.length > 0;
    };
    ObservableWrapper.dispose = function(subscription) {
      subscription.unsubscribe();
    };
    ObservableWrapper.callNext = function(emitter, value) {
      emitter.next(value);
    };
    ObservableWrapper.callEmit = function(emitter, value) {
      emitter.emit(value);
    };
    ObservableWrapper.callError = function(emitter, error) {
      emitter.error(error);
    };
    ObservableWrapper.callComplete = function(emitter) {
      emitter.complete();
    };
    ObservableWrapper.fromPromise = function(promise) {
      return rxjs_observable_PromiseObservable.PromiseObservable.create(promise);
    };
    ObservableWrapper.toPromise = function(obj) {
      return rxjs_operator_toPromise.toPromise.call(obj);
    };
    return ObservableWrapper;
  }());
  var EventEmitter = (function(_super) {
    __extends(EventEmitter, _super);
    function EventEmitter(isAsync) {
      if (isAsync === void 0) {
        isAsync = true;
      }
      _super.call(this);
      this._isAsync = isAsync;
    }
    EventEmitter.prototype.emit = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.next = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.subscribe = function(generatorOrNext, error, complete) {
      var schedulerFn;
      var errorFn = function(err) {
        return null;
      };
      var completeFn = function() {
        return null;
      };
      if (generatorOrNext && typeof generatorOrNext === 'object') {
        schedulerFn = this._isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext.next(value);
          });
        } : function(value) {
          generatorOrNext.next(value);
        };
        if (generatorOrNext.error) {
          errorFn = this._isAsync ? function(err) {
            setTimeout(function() {
              return generatorOrNext.error(err);
            });
          } : function(err) {
            generatorOrNext.error(err);
          };
        }
        if (generatorOrNext.complete) {
          completeFn = this._isAsync ? function() {
            setTimeout(function() {
              return generatorOrNext.complete();
            });
          } : function() {
            generatorOrNext.complete();
          };
        }
      } else {
        schedulerFn = this._isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext(value);
          });
        } : function(value) {
          generatorOrNext(value);
        };
        if (error) {
          errorFn = this._isAsync ? function(err) {
            setTimeout(function() {
              return error(err);
            });
          } : function(err) {
            error(err);
          };
        }
        if (complete) {
          completeFn = this._isAsync ? function() {
            setTimeout(function() {
              return complete();
            });
          } : function() {
            complete();
          };
        }
      }
      return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
    };
    return EventEmitter;
  }(rxjs_Subject.Subject));
  var Map$1 = global$1.Map;
  var Set$1 = global$1.Set;
  var createMapFromPairs = (function() {
    try {
      if (new Map$1([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new Map$1(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new Map$1();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new Map$1(new Map$1())) {
        return function createMapFromMap(m) {
          return new Map$1(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new Map$1();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new Map$1()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new Map$1()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var MapWrapper = (function() {
    function MapWrapper() {}
    MapWrapper.clone = function(m) {
      return createMapFromMap(m);
    };
    MapWrapper.createFromStringMap = function(stringMap) {
      var result = new Map$1();
      for (var prop in stringMap) {
        result.set(prop, stringMap[prop]);
      }
      return result;
    };
    MapWrapper.toStringMap = function(m) {
      var r = {};
      m.forEach(function(v, k) {
        return r[k] = v;
      });
      return r;
    };
    MapWrapper.createFromPairs = function(pairs) {
      return createMapFromPairs(pairs);
    };
    MapWrapper.clearValues = function(m) {
      _clearValues(m);
    };
    MapWrapper.iterable = function(m) {
      return m;
    };
    MapWrapper.keys = function(m) {
      return _arrayFromMap(m, false);
    };
    MapWrapper.values = function(m) {
      return _arrayFromMap(m, true);
    };
    return MapWrapper;
  }());
  var StringMapWrapper = (function() {
    function StringMapWrapper() {}
    StringMapWrapper.create = function() {
      return {};
    };
    StringMapWrapper.contains = function(map, key) {
      return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function(map, key) {
      return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function(map, key, value) {
      map[key] = value;
    };
    StringMapWrapper.keys = function(map) {
      return Object.keys(map);
    };
    StringMapWrapper.values = function(map) {
      return Object.keys(map).reduce(function(r, a) {
        r.push(map[a]);
        return r;
      }, []);
    };
    StringMapWrapper.isEmpty = function(map) {
      for (var prop in map) {
        return false;
      }
      return true;
    };
    StringMapWrapper.delete = function(map, key) {
      delete map[key];
    };
    StringMapWrapper.forEach = function(map, callback) {
      for (var prop in map) {
        if (map.hasOwnProperty(prop)) {
          callback(map[prop], prop);
        }
      }
    };
    StringMapWrapper.merge = function(m1, m2) {
      var m = {};
      for (var attr in m1) {
        if (m1.hasOwnProperty(attr)) {
          m[attr] = m1[attr];
        }
      }
      for (var attr in m2) {
        if (m2.hasOwnProperty(attr)) {
          m[attr] = m2[attr];
        }
      }
      return m;
    };
    StringMapWrapper.equals = function(m1, m2) {
      var k1 = Object.keys(m1);
      var k2 = Object.keys(m2);
      if (k1.length != k2.length) {
        return false;
      }
      var key;
      for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (m1[key] !== m2[key]) {
          return false;
        }
      }
      return true;
    };
    return StringMapWrapper;
  }());
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  function _flattenArray(source, target) {
    if (isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  function isListLikeIterable(obj) {
    if (!isJsObject(obj))
      return false;
    return isArray(obj) || (!(obj instanceof Map$1) && getSymbolIterator() in obj);
  }
  var createSetFromList = (function() {
    var test = new Set$1([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new Set$1(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new Set$1(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var BaseException = (function(_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
      if (message === void 0) {
        message = "--";
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function() {
      return this.message;
    };
    return BaseException;
  }(Error));
  function unimplemented() {
    throw new BaseException('unimplemented');
  }
  var InvalidPipeArgumentException = (function(_super) {
    __extends(InvalidPipeArgumentException, _super);
    function InvalidPipeArgumentException(type, value) {
      _super.call(this, "Invalid argument '" + value + "' for pipe '" + stringify(type) + "'");
    }
    return InvalidPipeArgumentException;
  }(BaseException));
  var ObservableStrategy = (function() {
    function ObservableStrategy() {}
    ObservableStrategy.prototype.createSubscription = function(async, updateLatestValue) {
      return ObservableWrapper.subscribe(async, updateLatestValue, function(e) {
        throw e;
      });
    };
    ObservableStrategy.prototype.dispose = function(subscription) {
      ObservableWrapper.dispose(subscription);
    };
    ObservableStrategy.prototype.onDestroy = function(subscription) {
      ObservableWrapper.dispose(subscription);
    };
    return ObservableStrategy;
  }());
  var PromiseStrategy = (function() {
    function PromiseStrategy() {}
    PromiseStrategy.prototype.createSubscription = function(async, updateLatestValue) {
      return async.then(updateLatestValue);
    };
    PromiseStrategy.prototype.dispose = function(subscription) {};
    PromiseStrategy.prototype.onDestroy = function(subscription) {};
    return PromiseStrategy;
  }());
  var _promiseStrategy = new PromiseStrategy();
  var _observableStrategy = new ObservableStrategy();
  var AsyncPipe = (function() {
    function AsyncPipe(_ref) {
      this._latestValue = null;
      this._latestReturnedValue = null;
      this._subscription = null;
      this._obj = null;
      this._strategy = null;
      this._ref = _ref;
    }
    AsyncPipe.prototype.ngOnDestroy = function() {
      if (isPresent(this._subscription)) {
        this._dispose();
      }
    };
    AsyncPipe.prototype.transform = function(obj) {
      if (isBlank(this._obj)) {
        if (isPresent(obj)) {
          this._subscribe(obj);
        }
        this._latestReturnedValue = this._latestValue;
        return this._latestValue;
      }
      if (obj !== this._obj) {
        this._dispose();
        return this.transform(obj);
      }
      if (this._latestValue === this._latestReturnedValue) {
        return this._latestReturnedValue;
      } else {
        this._latestReturnedValue = this._latestValue;
        return _angular_core.WrappedValue.wrap(this._latestValue);
      }
    };
    AsyncPipe.prototype._subscribe = function(obj) {
      var _this = this;
      this._obj = obj;
      this._strategy = this._selectStrategy(obj);
      this._subscription = this._strategy.createSubscription(obj, function(value) {
        return _this._updateLatestValue(obj, value);
      });
    };
    AsyncPipe.prototype._selectStrategy = function(obj) {
      if (isPromise(obj)) {
        return _promiseStrategy;
      } else if (ObservableWrapper.isObservable(obj)) {
        return _observableStrategy;
      } else {
        throw new InvalidPipeArgumentException(AsyncPipe, obj);
      }
    };
    AsyncPipe.prototype._dispose = function() {
      this._strategy.dispose(this._subscription);
      this._latestValue = null;
      this._latestReturnedValue = null;
      this._subscription = null;
      this._obj = null;
    };
    AsyncPipe.prototype._updateLatestValue = function(async, value) {
      if (async === this._obj) {
        this._latestValue = value;
        this._ref.markForCheck();
      }
    };
    return AsyncPipe;
  }());
  AsyncPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'async',
      pure: false
    }]
  }, {type: _angular_core.Injectable}];
  AsyncPipe.ctorParameters = [{type: _angular_core.ChangeDetectorRef}];
  var NumberFormatStyle;
  (function(NumberFormatStyle) {
    NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
    NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
    NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
  })(NumberFormatStyle || (NumberFormatStyle = {}));
  var NumberFormatter = (function() {
    function NumberFormatter() {}
    NumberFormatter.format = function(num, locale, style, _a) {
      var _b = _a === void 0 ? {} : _a,
          _c = _b.minimumIntegerDigits,
          minimumIntegerDigits = _c === void 0 ? 1 : _c,
          _d = _b.minimumFractionDigits,
          minimumFractionDigits = _d === void 0 ? 0 : _d,
          _e = _b.maximumFractionDigits,
          maximumFractionDigits = _e === void 0 ? 3 : _e,
          currency = _b.currency,
          _f = _b.currencyAsSymbol,
          currencyAsSymbol = _f === void 0 ? false : _f;
      var intlOptions = {
        minimumIntegerDigits: minimumIntegerDigits,
        minimumFractionDigits: minimumFractionDigits,
        maximumFractionDigits: maximumFractionDigits
      };
      intlOptions.style = NumberFormatStyle[style].toLowerCase();
      if (style == NumberFormatStyle.Currency) {
        intlOptions.currency = currency;
        intlOptions.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
      }
      return new Intl.NumberFormat(locale, intlOptions).format(num);
    };
    return NumberFormatter;
  }());
  function digitCondition(len) {
    return len == 2 ? '2-digit' : 'numeric';
  }
  function nameCondition(len) {
    return len < 4 ? 'short' : 'long';
  }
  function extractComponents(pattern) {
    var ret = {};
    var i = 0,
        j;
    while (i < pattern.length) {
      j = i;
      while (j < pattern.length && pattern[j] == pattern[i])
        j++;
      var len = j - i;
      switch (pattern[i]) {
        case 'G':
          ret.era = nameCondition(len);
          break;
        case 'y':
          ret.year = digitCondition(len);
          break;
        case 'M':
          if (len >= 3)
            ret.month = nameCondition(len);
          else
            ret.month = digitCondition(len);
          break;
        case 'd':
          ret.day = digitCondition(len);
          break;
        case 'E':
          ret.weekday = nameCondition(len);
          break;
        case 'j':
          ret.hour = digitCondition(len);
          break;
        case 'h':
          ret.hour = digitCondition(len);
          ret.hour12 = true;
          break;
        case 'H':
          ret.hour = digitCondition(len);
          ret.hour12 = false;
          break;
        case 'm':
          ret.minute = digitCondition(len);
          break;
        case 's':
          ret.second = digitCondition(len);
          break;
        case 'z':
          ret.timeZoneName = 'long';
          break;
        case 'Z':
          ret.timeZoneName = 'short';
          break;
      }
      i = j;
    }
    return ret;
  }
  var dateFormatterCache = new Map();
  var DateFormatter = (function() {
    function DateFormatter() {}
    DateFormatter.format = function(date, locale, pattern) {
      var key = locale + pattern;
      if (dateFormatterCache.has(key)) {
        return dateFormatterCache.get(key).format(date);
      }
      var formatter = new Intl.DateTimeFormat(locale, extractComponents(pattern));
      dateFormatterCache.set(key, formatter);
      return formatter.format(date);
    };
    return DateFormatter;
  }());
  var defaultLocale = 'en-US';
  var DatePipe = (function() {
    function DatePipe() {}
    DatePipe.prototype.transform = function(value, pattern) {
      if (pattern === void 0) {
        pattern = 'mediumDate';
      }
      if (isBlank(value))
        return null;
      if (!this.supports(value)) {
        throw new InvalidPipeArgumentException(DatePipe, value);
      }
      if (isNumber(value)) {
        value = DateWrapper.fromMillis(value);
      }
      if (StringMapWrapper.contains(DatePipe._ALIASES, pattern)) {
        pattern = StringMapWrapper.get(DatePipe._ALIASES, pattern);
      }
      return DateFormatter.format(value, defaultLocale, pattern);
    };
    DatePipe.prototype.supports = function(obj) {
      return isDate(obj) || isNumber(obj);
    };
    return DatePipe;
  }());
  DatePipe._ALIASES = {
    'medium': 'yMMMdjms',
    'short': 'yMdjm',
    'fullDate': 'yMMMMEEEEd',
    'longDate': 'yMMMMd',
    'mediumDate': 'yMMMd',
    'shortDate': 'yMd',
    'mediumTime': 'jms',
    'shortTime': 'jm'
  };
  DatePipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'date',
      pure: true
    }]
  }, {type: _angular_core.Injectable}];
  var JsonPipe = (function() {
    function JsonPipe() {}
    JsonPipe.prototype.transform = function(value) {
      return Json.stringify(value);
    };
    return JsonPipe;
  }());
  JsonPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'json',
      pure: false
    }]
  }, {type: _angular_core.Injectable}];
  var SlicePipe = (function() {
    function SlicePipe() {}
    SlicePipe.prototype.transform = function(value, start, end) {
      if (end === void 0) {
        end = null;
      }
      if (!this.supports(value)) {
        throw new InvalidPipeArgumentException(SlicePipe, value);
      }
      if (isBlank(value))
        return value;
      if (isString(value)) {
        return StringWrapper.slice(value, start, end);
      }
      return ListWrapper.slice(value, start, end);
    };
    SlicePipe.prototype.supports = function(obj) {
      return isString(obj) || isArray(obj);
    };
    return SlicePipe;
  }());
  SlicePipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'slice',
      pure: false
    }]
  }, {type: _angular_core.Injectable}];
  var LowerCasePipe = (function() {
    function LowerCasePipe() {}
    LowerCasePipe.prototype.transform = function(value) {
      if (isBlank(value))
        return value;
      if (!isString(value)) {
        throw new InvalidPipeArgumentException(LowerCasePipe, value);
      }
      return value.toLowerCase();
    };
    return LowerCasePipe;
  }());
  LowerCasePipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'lowercase'}]
  }, {type: _angular_core.Injectable}];
  var defaultLocale$1 = 'en-US';
  var _re = RegExpWrapper.create('^(\\d+)?\\.((\\d+)(\\-(\\d+))?)?$');
  var NumberPipe = (function() {
    function NumberPipe() {}
    NumberPipe._format = function(value, style, digits, currency, currencyAsSymbol) {
      if (currency === void 0) {
        currency = null;
      }
      if (currencyAsSymbol === void 0) {
        currencyAsSymbol = false;
      }
      if (isBlank(value))
        return null;
      if (!isNumber(value)) {
        throw new InvalidPipeArgumentException(NumberPipe, value);
      }
      var minInt = 1,
          minFraction = 0,
          maxFraction = 3;
      if (isPresent(digits)) {
        var parts = RegExpWrapper.firstMatch(_re, digits);
        if (isBlank(parts)) {
          throw new BaseException(digits + " is not a valid digit info for number pipes");
        }
        if (isPresent(parts[1])) {
          minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
        }
        if (isPresent(parts[3])) {
          minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
        }
        if (isPresent(parts[5])) {
          maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
        }
      }
      return NumberFormatter.format(value, defaultLocale$1, style, {
        minimumIntegerDigits: minInt,
        minimumFractionDigits: minFraction,
        maximumFractionDigits: maxFraction,
        currency: currency,
        currencyAsSymbol: currencyAsSymbol
      });
    };
    return NumberPipe;
  }());
  NumberPipe.decorators = [{type: _angular_core.Injectable}];
  var DecimalPipe = (function(_super) {
    __extends(DecimalPipe, _super);
    function DecimalPipe() {
      _super.apply(this, arguments);
    }
    DecimalPipe.prototype.transform = function(value, digits) {
      if (digits === void 0) {
        digits = null;
      }
      return NumberPipe._format(value, NumberFormatStyle.Decimal, digits);
    };
    return DecimalPipe;
  }(NumberPipe));
  DecimalPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'number'}]
  }, {type: _angular_core.Injectable}];
  var PercentPipe = (function(_super) {
    __extends(PercentPipe, _super);
    function PercentPipe() {
      _super.apply(this, arguments);
    }
    PercentPipe.prototype.transform = function(value, digits) {
      if (digits === void 0) {
        digits = null;
      }
      return NumberPipe._format(value, NumberFormatStyle.Percent, digits);
    };
    return PercentPipe;
  }(NumberPipe));
  PercentPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'percent'}]
  }, {type: _angular_core.Injectable}];
  var CurrencyPipe = (function(_super) {
    __extends(CurrencyPipe, _super);
    function CurrencyPipe() {
      _super.apply(this, arguments);
    }
    CurrencyPipe.prototype.transform = function(value, currencyCode, symbolDisplay, digits) {
      if (currencyCode === void 0) {
        currencyCode = 'USD';
      }
      if (symbolDisplay === void 0) {
        symbolDisplay = false;
      }
      if (digits === void 0) {
        digits = null;
      }
      return NumberPipe._format(value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
    };
    return CurrencyPipe;
  }(NumberPipe));
  CurrencyPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'currency'}]
  }, {type: _angular_core.Injectable}];
  var UpperCasePipe = (function() {
    function UpperCasePipe() {}
    UpperCasePipe.prototype.transform = function(value) {
      if (isBlank(value))
        return value;
      if (!isString(value)) {
        throw new InvalidPipeArgumentException(UpperCasePipe, value);
      }
      return value.toUpperCase();
    };
    return UpperCasePipe;
  }());
  UpperCasePipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'uppercase'}]
  }, {type: _angular_core.Injectable}];
  var ReplacePipe = (function() {
    function ReplacePipe() {}
    ReplacePipe.prototype.transform = function(value, pattern, replacement) {
      if (isBlank(value)) {
        return value;
      }
      if (!this._supportedInput(value)) {
        throw new InvalidPipeArgumentException(ReplacePipe, value);
      }
      var input = value.toString();
      if (!this._supportedPattern(pattern)) {
        throw new InvalidPipeArgumentException(ReplacePipe, pattern);
      }
      if (!this._supportedReplacement(replacement)) {
        throw new InvalidPipeArgumentException(ReplacePipe, replacement);
      }
      if (isFunction(replacement)) {
        var rgxPattern = isString(pattern) ? RegExpWrapper.create(pattern) : pattern;
        return StringWrapper.replaceAllMapped(input, rgxPattern, replacement);
      }
      if (pattern instanceof RegExp) {
        return StringWrapper.replaceAll(input, pattern, replacement);
      }
      return StringWrapper.replace(input, pattern, replacement);
    };
    ReplacePipe.prototype._supportedInput = function(input) {
      return isString(input) || isNumber(input);
    };
    ReplacePipe.prototype._supportedPattern = function(pattern) {
      return isString(pattern) || pattern instanceof RegExp;
    };
    ReplacePipe.prototype._supportedReplacement = function(replacement) {
      return isString(replacement) || isFunction(replacement);
    };
    return ReplacePipe;
  }());
  ReplacePipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'replace'}]
  }, {type: _angular_core.Injectable}];
  var interpolationExp = RegExpWrapper.create('#');
  var I18nPluralPipe = (function() {
    function I18nPluralPipe() {}
    I18nPluralPipe.prototype.transform = function(value, pluralMap) {
      var key;
      var valueStr;
      if (!isStringMap(pluralMap)) {
        throw new InvalidPipeArgumentException(I18nPluralPipe, pluralMap);
      }
      key = value === 0 || value === 1 ? "=" + value : 'other';
      valueStr = isPresent(value) ? value.toString() : '';
      return StringWrapper.replaceAll(pluralMap[key], interpolationExp, valueStr);
    };
    return I18nPluralPipe;
  }());
  I18nPluralPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'i18nPlural',
      pure: true
    }]
  }, {type: _angular_core.Injectable}];
  var I18nSelectPipe = (function() {
    function I18nSelectPipe() {}
    I18nSelectPipe.prototype.transform = function(value, mapping) {
      if (!isStringMap(mapping)) {
        throw new InvalidPipeArgumentException(I18nSelectPipe, mapping);
      }
      return StringMapWrapper.contains(mapping, value) ? mapping[value] : mapping['other'];
    };
    return I18nSelectPipe;
  }());
  I18nSelectPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'i18nSelect',
      pure: true
    }]
  }, {type: _angular_core.Injectable}];
  var COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, CurrencyPipe, DatePipe, ReplacePipe, I18nPluralPipe, I18nSelectPipe];
  var NgClass = (function() {
    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
      this._iterableDiffers = _iterableDiffers;
      this._keyValueDiffers = _keyValueDiffers;
      this._ngEl = _ngEl;
      this._renderer = _renderer;
      this._initialClasses = [];
    }
    Object.defineProperty(NgClass.prototype, "initialClasses", {
      set: function(v) {
        this._applyInitialClasses(true);
        this._initialClasses = isPresent(v) && isString(v) ? v.split(' ') : [];
        this._applyInitialClasses(false);
        this._applyClasses(this._rawClass, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgClass.prototype, "rawClass", {
      set: function(v) {
        this._cleanupClasses(this._rawClass);
        if (isString(v)) {
          v = v.split(' ');
        }
        this._rawClass = v;
        this._iterableDiffer = null;
        this._keyValueDiffer = null;
        if (isPresent(v)) {
          if (isListLikeIterable(v)) {
            this._iterableDiffer = this._iterableDiffers.find(v).create(null);
          } else {
            this._keyValueDiffer = this._keyValueDiffers.find(v).create(null);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    NgClass.prototype.ngDoCheck = function() {
      if (isPresent(this._iterableDiffer)) {
        var changes = this._iterableDiffer.diff(this._rawClass);
        if (isPresent(changes)) {
          this._applyIterableChanges(changes);
        }
      }
      if (isPresent(this._keyValueDiffer)) {
        var changes = this._keyValueDiffer.diff(this._rawClass);
        if (isPresent(changes)) {
          this._applyKeyValueChanges(changes);
        }
      }
    };
    NgClass.prototype.ngOnDestroy = function() {
      this._cleanupClasses(this._rawClass);
    };
    NgClass.prototype._cleanupClasses = function(rawClassVal) {
      this._applyClasses(rawClassVal, true);
      this._applyInitialClasses(false);
    };
    NgClass.prototype._applyKeyValueChanges = function(changes) {
      var _this = this;
      changes.forEachAddedItem(function(record) {
        _this._toggleClass(record.key, record.currentValue);
      });
      changes.forEachChangedItem(function(record) {
        _this._toggleClass(record.key, record.currentValue);
      });
      changes.forEachRemovedItem(function(record) {
        if (record.previousValue) {
          _this._toggleClass(record.key, false);
        }
      });
    };
    NgClass.prototype._applyIterableChanges = function(changes) {
      var _this = this;
      changes.forEachAddedItem(function(record) {
        _this._toggleClass(record.item, true);
      });
      changes.forEachRemovedItem(function(record) {
        _this._toggleClass(record.item, false);
      });
    };
    NgClass.prototype._applyInitialClasses = function(isCleanup) {
      var _this = this;
      this._initialClasses.forEach(function(className) {
        return _this._toggleClass(className, !isCleanup);
      });
    };
    NgClass.prototype._applyClasses = function(rawClassVal, isCleanup) {
      var _this = this;
      if (isPresent(rawClassVal)) {
        if (isArray(rawClassVal)) {
          rawClassVal.forEach(function(className) {
            return _this._toggleClass(className, !isCleanup);
          });
        } else if (rawClassVal instanceof Set) {
          rawClassVal.forEach(function(className) {
            return _this._toggleClass(className, !isCleanup);
          });
        } else {
          StringMapWrapper.forEach(rawClassVal, function(expVal, className) {
            if (isPresent(expVal))
              _this._toggleClass(className, !isCleanup);
          });
        }
      }
    };
    NgClass.prototype._toggleClass = function(className, enabled) {
      className = className.trim();
      if (className.length > 0) {
        if (className.indexOf(' ') > -1) {
          var classes = className.split(/\s+/g);
          for (var i = 0,
              len = classes.length; i < len; i++) {
            this._renderer.setElementClass(this._ngEl.nativeElement, classes[i], enabled);
          }
        } else {
          this._renderer.setElementClass(this._ngEl.nativeElement, className, enabled);
        }
      }
    };
    return NgClass;
  }());
  NgClass.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngClass]',
      inputs: ['rawClass: ngClass', 'initialClasses: class']
    }]
  }];
  NgClass.ctorParameters = [{type: _angular_core.IterableDiffers}, {type: _angular_core.KeyValueDiffers}, {type: _angular_core.ElementRef}, {type: _angular_core.Renderer}];
  var NgForRow = (function() {
    function NgForRow($implicit, index, count) {
      this.$implicit = $implicit;
      this.index = index;
      this.count = count;
    }
    Object.defineProperty(NgForRow.prototype, "first", {
      get: function() {
        return this.index === 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForRow.prototype, "last", {
      get: function() {
        return this.index === this.count - 1;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForRow.prototype, "even", {
      get: function() {
        return this.index % 2 === 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForRow.prototype, "odd", {
      get: function() {
        return !this.even;
      },
      enumerable: true,
      configurable: true
    });
    return NgForRow;
  }());
  var NgFor = (function() {
    function NgFor(_viewContainer, _templateRef, _iterableDiffers, _cdr) {
      this._viewContainer = _viewContainer;
      this._templateRef = _templateRef;
      this._iterableDiffers = _iterableDiffers;
      this._cdr = _cdr;
    }
    Object.defineProperty(NgFor.prototype, "ngForOf", {
      set: function(value) {
        this._ngForOf = value;
        if (isBlank(this._differ) && isPresent(value)) {
          try {
            this._differ = this._iterableDiffers.find(value).create(this._cdr, this._ngForTrackBy);
          } catch (e) {
            throw new BaseException("Cannot find a differ supporting object '" + value + "' of type '" + getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFor.prototype, "ngForTemplate", {
      set: function(value) {
        if (isPresent(value)) {
          this._templateRef = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFor.prototype, "ngForTrackBy", {
      set: function(value) {
        this._ngForTrackBy = value;
      },
      enumerable: true,
      configurable: true
    });
    NgFor.prototype.ngDoCheck = function() {
      if (isPresent(this._differ)) {
        var changes = this._differ.diff(this._ngForOf);
        if (isPresent(changes))
          this._applyChanges(changes);
      }
    };
    NgFor.prototype._applyChanges = function(changes) {
      var _this = this;
      var recordViewTuples = [];
      changes.forEachRemovedItem(function(removedRecord) {
        return recordViewTuples.push(new RecordViewTuple(removedRecord, null));
      });
      changes.forEachMovedItem(function(movedRecord) {
        return recordViewTuples.push(new RecordViewTuple(movedRecord, null));
      });
      var insertTuples = this._bulkRemove(recordViewTuples);
      changes.forEachAddedItem(function(addedRecord) {
        return insertTuples.push(new RecordViewTuple(addedRecord, null));
      });
      this._bulkInsert(insertTuples);
      for (var i = 0; i < insertTuples.length; i++) {
        this._perViewChange(insertTuples[i].view, insertTuples[i].record);
      }
      for (var i = 0,
          ilen = this._viewContainer.length; i < ilen; i++) {
        var viewRef = this._viewContainer.get(i);
        viewRef.context.index = i;
        viewRef.context.count = ilen;
      }
      changes.forEachIdentityChange(function(record) {
        var viewRef = _this._viewContainer.get(record.currentIndex);
        viewRef.context.$implicit = record.item;
      });
    };
    NgFor.prototype._perViewChange = function(view, record) {
      view.context.$implicit = record.item;
    };
    NgFor.prototype._bulkRemove = function(tuples) {
      tuples.sort(function(a, b) {
        return a.record.previousIndex - b.record.previousIndex;
      });
      var movedTuples = [];
      for (var i = tuples.length - 1; i >= 0; i--) {
        var tuple = tuples[i];
        if (isPresent(tuple.record.currentIndex)) {
          tuple.view = this._viewContainer.detach(tuple.record.previousIndex);
          movedTuples.push(tuple);
        } else {
          this._viewContainer.remove(tuple.record.previousIndex);
        }
      }
      return movedTuples;
    };
    NgFor.prototype._bulkInsert = function(tuples) {
      tuples.sort(function(a, b) {
        return a.record.currentIndex - b.record.currentIndex;
      });
      for (var i = 0; i < tuples.length; i++) {
        var tuple = tuples[i];
        if (isPresent(tuple.view)) {
          this._viewContainer.insert(tuple.view, tuple.record.currentIndex);
        } else {
          tuple.view = this._viewContainer.createEmbeddedView(this._templateRef, new NgForRow(null, null, null), tuple.record.currentIndex);
        }
      }
      return tuples;
    };
    return NgFor;
  }());
  NgFor.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngFor][ngForOf]',
      inputs: ['ngForTrackBy', 'ngForOf', 'ngForTemplate']
    }]
  }];
  NgFor.ctorParameters = [{type: _angular_core.ViewContainerRef}, {type: _angular_core.TemplateRef}, {type: _angular_core.IterableDiffers}, {type: _angular_core.ChangeDetectorRef}];
  var RecordViewTuple = (function() {
    function RecordViewTuple(record, view) {
      this.record = record;
      this.view = view;
    }
    return RecordViewTuple;
  }());
  var NgIf = (function() {
    function NgIf(_viewContainer, _templateRef) {
      this._viewContainer = _viewContainer;
      this._templateRef = _templateRef;
      this._prevCondition = null;
    }
    Object.defineProperty(NgIf.prototype, "ngIf", {
      set: function(newCondition) {
        if (newCondition && (isBlank(this._prevCondition) || !this._prevCondition)) {
          this._prevCondition = true;
          this._viewContainer.createEmbeddedView(this._templateRef);
        } else if (!newCondition && (isBlank(this._prevCondition) || this._prevCondition)) {
          this._prevCondition = false;
          this._viewContainer.clear();
        }
      },
      enumerable: true,
      configurable: true
    });
    return NgIf;
  }());
  NgIf.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngIf]',
      inputs: ['ngIf']
    }]
  }];
  NgIf.ctorParameters = [{type: _angular_core.ViewContainerRef}, {type: _angular_core.TemplateRef}];
  var NgTemplateOutlet = (function() {
    function NgTemplateOutlet(_viewContainerRef) {
      this._viewContainerRef = _viewContainerRef;
    }
    Object.defineProperty(NgTemplateOutlet.prototype, "ngTemplateOutlet", {
      set: function(templateRef) {
        if (isPresent(this._insertedViewRef)) {
          this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._insertedViewRef));
        }
        if (isPresent(templateRef)) {
          this._insertedViewRef = this._viewContainerRef.createEmbeddedView(templateRef);
        }
      },
      enumerable: true,
      configurable: true
    });
    return NgTemplateOutlet;
  }());
  NgTemplateOutlet.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngTemplateOutlet]'}]
  }];
  NgTemplateOutlet.ctorParameters = [{type: _angular_core.ViewContainerRef}];
  NgTemplateOutlet.propDecorators = {'ngTemplateOutlet': [{type: _angular_core.Input}]};
  var NgStyle = (function() {
    function NgStyle(_differs, _ngEl, _renderer) {
      this._differs = _differs;
      this._ngEl = _ngEl;
      this._renderer = _renderer;
    }
    Object.defineProperty(NgStyle.prototype, "rawStyle", {
      set: function(v) {
        this._rawStyle = v;
        if (isBlank(this._differ) && isPresent(v)) {
          this._differ = this._differs.find(this._rawStyle).create(null);
        }
      },
      enumerable: true,
      configurable: true
    });
    NgStyle.prototype.ngDoCheck = function() {
      if (isPresent(this._differ)) {
        var changes = this._differ.diff(this._rawStyle);
        if (isPresent(changes)) {
          this._applyChanges(changes);
        }
      }
    };
    NgStyle.prototype._applyChanges = function(changes) {
      var _this = this;
      changes.forEachAddedItem(function(record) {
        _this._setStyle(record.key, record.currentValue);
      });
      changes.forEachChangedItem(function(record) {
        _this._setStyle(record.key, record.currentValue);
      });
      changes.forEachRemovedItem(function(record) {
        _this._setStyle(record.key, null);
      });
    };
    NgStyle.prototype._setStyle = function(name, val) {
      this._renderer.setElementStyle(this._ngEl.nativeElement, name, val);
    };
    return NgStyle;
  }());
  NgStyle.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngStyle]',
      inputs: ['rawStyle: ngStyle']
    }]
  }];
  NgStyle.ctorParameters = [{type: _angular_core.KeyValueDiffers}, {type: _angular_core.ElementRef}, {type: _angular_core.Renderer}];
  var _WHEN_DEFAULT = new Object();
  var SwitchView = (function() {
    function SwitchView(_viewContainerRef, _templateRef) {
      this._viewContainerRef = _viewContainerRef;
      this._templateRef = _templateRef;
    }
    SwitchView.prototype.create = function() {
      this._viewContainerRef.createEmbeddedView(this._templateRef);
    };
    SwitchView.prototype.destroy = function() {
      this._viewContainerRef.clear();
    };
    return SwitchView;
  }());
  var NgSwitch = (function() {
    function NgSwitch() {
      this._useDefault = false;
      this._valueViews = new Map$1();
      this._activeViews = [];
    }
    Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
      set: function(value) {
        this._emptyAllActiveViews();
        this._useDefault = false;
        var views = this._valueViews.get(value);
        if (isBlank(views)) {
          this._useDefault = true;
          views = normalizeBlank(this._valueViews.get(_WHEN_DEFAULT));
        }
        this._activateViews(views);
        this._switchValue = value;
      },
      enumerable: true,
      configurable: true
    });
    NgSwitch.prototype._onWhenValueChanged = function(oldWhen, newWhen, view) {
      this._deregisterView(oldWhen, view);
      this._registerView(newWhen, view);
      if (oldWhen === this._switchValue) {
        view.destroy();
        ListWrapper.remove(this._activeViews, view);
      } else if (newWhen === this._switchValue) {
        if (this._useDefault) {
          this._useDefault = false;
          this._emptyAllActiveViews();
        }
        view.create();
        this._activeViews.push(view);
      }
      if (this._activeViews.length === 0 && !this._useDefault) {
        this._useDefault = true;
        this._activateViews(this._valueViews.get(_WHEN_DEFAULT));
      }
    };
    NgSwitch.prototype._emptyAllActiveViews = function() {
      var activeContainers = this._activeViews;
      for (var i = 0; i < activeContainers.length; i++) {
        activeContainers[i].destroy();
      }
      this._activeViews = [];
    };
    NgSwitch.prototype._activateViews = function(views) {
      if (isPresent(views)) {
        for (var i = 0; i < views.length; i++) {
          views[i].create();
        }
        this._activeViews = views;
      }
    };
    NgSwitch.prototype._registerView = function(value, view) {
      var views = this._valueViews.get(value);
      if (isBlank(views)) {
        views = [];
        this._valueViews.set(value, views);
      }
      views.push(view);
    };
    NgSwitch.prototype._deregisterView = function(value, view) {
      if (value === _WHEN_DEFAULT)
        return;
      var views = this._valueViews.get(value);
      if (views.length == 1) {
        this._valueViews.delete(value);
      } else {
        ListWrapper.remove(views, view);
      }
    };
    return NgSwitch;
  }());
  NgSwitch.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngSwitch]',
      inputs: ['ngSwitch']
    }]
  }];
  var NgSwitchWhen = (function() {
    function NgSwitchWhen(viewContainer, templateRef, ngSwitch) {
      this._value = _WHEN_DEFAULT;
      this._switch = ngSwitch;
      this._view = new SwitchView(viewContainer, templateRef);
    }
    Object.defineProperty(NgSwitchWhen.prototype, "ngSwitchWhen", {
      set: function(value) {
        this._switch._onWhenValueChanged(this._value, value, this._view);
        this._value = value;
      },
      enumerable: true,
      configurable: true
    });
    return NgSwitchWhen;
  }());
  NgSwitchWhen.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngSwitchWhen]',
      inputs: ['ngSwitchWhen']
    }]
  }];
  NgSwitchWhen.ctorParameters = [{type: _angular_core.ViewContainerRef}, {type: _angular_core.TemplateRef}, {
    type: NgSwitch,
    decorators: [{type: _angular_core.Host}]
  }];
  var NgSwitchDefault = (function() {
    function NgSwitchDefault(viewContainer, templateRef, sswitch) {
      sswitch._registerView(_WHEN_DEFAULT, new SwitchView(viewContainer, templateRef));
    }
    return NgSwitchDefault;
  }());
  NgSwitchDefault.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngSwitchDefault]'}]
  }];
  NgSwitchDefault.ctorParameters = [{type: _angular_core.ViewContainerRef}, {type: _angular_core.TemplateRef}, {
    type: NgSwitch,
    decorators: [{type: _angular_core.Host}]
  }];
  var _CATEGORY_DEFAULT = 'other';
  var NgLocalization = (function() {
    function NgLocalization() {}
    return NgLocalization;
  }());
  var NgPluralCase = (function() {
    function NgPluralCase(value, template, viewContainer) {
      this.value = value;
      this._view = new SwitchView(viewContainer, template);
    }
    return NgPluralCase;
  }());
  NgPluralCase.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngPluralCase]'}]
  }];
  NgPluralCase.ctorParameters = [{
    type: undefined,
    decorators: [{
      type: _angular_core.Attribute,
      args: ['ngPluralCase']
    }]
  }, {type: _angular_core.TemplateRef}, {type: _angular_core.ViewContainerRef}];
  var NgPlural = (function() {
    function NgPlural(_localization) {
      this._localization = _localization;
      this._caseViews = new Map$1();
      this.cases = null;
    }
    Object.defineProperty(NgPlural.prototype, "ngPlural", {
      set: function(value) {
        this._switchValue = value;
        this._updateView();
      },
      enumerable: true,
      configurable: true
    });
    NgPlural.prototype.ngAfterContentInit = function() {
      var _this = this;
      this.cases.forEach(function(pluralCase) {
        _this._caseViews.set(_this._formatValue(pluralCase), pluralCase._view);
      });
      this._updateView();
    };
    NgPlural.prototype._updateView = function() {
      this._clearViews();
      var view = this._caseViews.get(this._switchValue);
      if (!isPresent(view))
        view = this._getCategoryView(this._switchValue);
      this._activateView(view);
    };
    NgPlural.prototype._clearViews = function() {
      if (isPresent(this._activeView))
        this._activeView.destroy();
    };
    NgPlural.prototype._activateView = function(view) {
      if (!isPresent(view))
        return;
      this._activeView = view;
      this._activeView.create();
    };
    NgPlural.prototype._getCategoryView = function(value) {
      var category = this._localization.getPluralCategory(value);
      var categoryView = this._caseViews.get(category);
      return isPresent(categoryView) ? categoryView : this._caseViews.get(_CATEGORY_DEFAULT);
    };
    NgPlural.prototype._isValueView = function(pluralCase) {
      return pluralCase.value[0] === "=";
    };
    NgPlural.prototype._formatValue = function(pluralCase) {
      return this._isValueView(pluralCase) ? this._stripValue(pluralCase.value) : pluralCase.value;
    };
    NgPlural.prototype._stripValue = function(value) {
      return NumberWrapper.parseInt(value.substring(1), 10);
    };
    return NgPlural;
  }());
  NgPlural.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngPlural]'}]
  }];
  NgPlural.ctorParameters = [{type: NgLocalization}];
  NgPlural.propDecorators = {
    'cases': [{
      type: _angular_core.ContentChildren,
      args: [NgPluralCase]
    }],
    'ngPlural': [{type: _angular_core.Input}]
  };
  var workaround_empty_observable_list_diff;
  var CORE_DIRECTIVES = [NgClass, NgFor, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgPlural, NgPluralCase];
  var VALID = "VALID";
  var INVALID = "INVALID";
  var PENDING = "PENDING";
  function _find(control, path) {
    if (isBlank(path))
      return null;
    if (!(path instanceof Array)) {
      path = path.split("/");
    }
    if (path instanceof Array && ListWrapper.isEmpty(path))
      return null;
    return path.reduce(function(v, name) {
      if (v instanceof ControlGroup) {
        return isPresent(v.controls[name]) ? v.controls[name] : null;
      } else if (v instanceof ControlArray) {
        var index = name;
        return isPresent(v.at(index)) ? v.at(index) : null;
      } else {
        return null;
      }
    }, control);
  }
  function toObservable(r) {
    return PromiseWrapper.isPromise(r) ? ObservableWrapper.fromPromise(r) : r;
  }
  var AbstractControl = (function() {
    function AbstractControl(validator, asyncValidator) {
      this.validator = validator;
      this.asyncValidator = asyncValidator;
      this._pristine = true;
      this._touched = false;
    }
    Object.defineProperty(AbstractControl.prototype, "value", {
      get: function() {
        return this._value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "status", {
      get: function() {
        return this._status;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valid", {
      get: function() {
        return this._status === VALID;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "errors", {
      get: function() {
        return this._errors;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "pristine", {
      get: function() {
        return this._pristine;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "dirty", {
      get: function() {
        return !this.pristine;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "touched", {
      get: function() {
        return this._touched;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "untouched", {
      get: function() {
        return !this._touched;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valueChanges", {
      get: function() {
        return this._valueChanges;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "statusChanges", {
      get: function() {
        return this._statusChanges;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "pending", {
      get: function() {
        return this._status == PENDING;
      },
      enumerable: true,
      configurable: true
    });
    AbstractControl.prototype.markAsTouched = function() {
      this._touched = true;
    };
    AbstractControl.prototype.markAsDirty = function(_a) {
      var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
      onlySelf = normalizeBool(onlySelf);
      this._pristine = false;
      if (isPresent(this._parent) && !onlySelf) {
        this._parent.markAsDirty({onlySelf: onlySelf});
      }
    };
    AbstractControl.prototype.markAsPending = function(_a) {
      var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
      onlySelf = normalizeBool(onlySelf);
      this._status = PENDING;
      if (isPresent(this._parent) && !onlySelf) {
        this._parent.markAsPending({onlySelf: onlySelf});
      }
    };
    AbstractControl.prototype.setParent = function(parent) {
      this._parent = parent;
    };
    AbstractControl.prototype.updateValueAndValidity = function(_a) {
      var _b = _a === void 0 ? {} : _a,
          onlySelf = _b.onlySelf,
          emitEvent = _b.emitEvent;
      onlySelf = normalizeBool(onlySelf);
      emitEvent = isPresent(emitEvent) ? emitEvent : true;
      this._updateValue();
      this._errors = this._runValidator();
      this._status = this._calculateStatus();
      if (this._status == VALID || this._status == PENDING) {
        this._runAsyncValidator(emitEvent);
      }
      if (emitEvent) {
        ObservableWrapper.callEmit(this._valueChanges, this._value);
        ObservableWrapper.callEmit(this._statusChanges, this._status);
      }
      if (isPresent(this._parent) && !onlySelf) {
        this._parent.updateValueAndValidity({
          onlySelf: onlySelf,
          emitEvent: emitEvent
        });
      }
    };
    AbstractControl.prototype._runValidator = function() {
      return isPresent(this.validator) ? this.validator(this) : null;
    };
    AbstractControl.prototype._runAsyncValidator = function(emitEvent) {
      var _this = this;
      if (isPresent(this.asyncValidator)) {
        this._status = PENDING;
        this._cancelExistingSubscription();
        var obs = toObservable(this.asyncValidator(this));
        this._asyncValidationSubscription = ObservableWrapper.subscribe(obs, function(res) {
          return _this.setErrors(res, {emitEvent: emitEvent});
        });
      }
    };
    AbstractControl.prototype._cancelExistingSubscription = function() {
      if (isPresent(this._asyncValidationSubscription)) {
        ObservableWrapper.dispose(this._asyncValidationSubscription);
      }
    };
    AbstractControl.prototype.setErrors = function(errors, _a) {
      var emitEvent = (_a === void 0 ? {} : _a).emitEvent;
      emitEvent = isPresent(emitEvent) ? emitEvent : true;
      this._errors = errors;
      this._status = this._calculateStatus();
      if (emitEvent) {
        ObservableWrapper.callEmit(this._statusChanges, this._status);
      }
      if (isPresent(this._parent)) {
        this._parent._updateControlsErrors();
      }
    };
    AbstractControl.prototype.find = function(path) {
      return _find(this, path);
    };
    AbstractControl.prototype.getError = function(errorCode, path) {
      if (path === void 0) {
        path = null;
      }
      var control = isPresent(path) && !ListWrapper.isEmpty(path) ? this.find(path) : this;
      if (isPresent(control) && isPresent(control._errors)) {
        return StringMapWrapper.get(control._errors, errorCode);
      } else {
        return null;
      }
    };
    AbstractControl.prototype.hasError = function(errorCode, path) {
      if (path === void 0) {
        path = null;
      }
      return isPresent(this.getError(errorCode, path));
    };
    Object.defineProperty(AbstractControl.prototype, "root", {
      get: function() {
        var x = this;
        while (isPresent(x._parent)) {
          x = x._parent;
        }
        return x;
      },
      enumerable: true,
      configurable: true
    });
    AbstractControl.prototype._updateControlsErrors = function() {
      this._status = this._calculateStatus();
      if (isPresent(this._parent)) {
        this._parent._updateControlsErrors();
      }
    };
    AbstractControl.prototype._initObservables = function() {
      this._valueChanges = new EventEmitter();
      this._statusChanges = new EventEmitter();
    };
    AbstractControl.prototype._calculateStatus = function() {
      if (isPresent(this._errors))
        return INVALID;
      if (this._anyControlsHaveStatus(PENDING))
        return PENDING;
      if (this._anyControlsHaveStatus(INVALID))
        return INVALID;
      return VALID;
    };
    return AbstractControl;
  }());
  var Control = (function(_super) {
    __extends(Control, _super);
    function Control(value, validator, asyncValidator) {
      if (value === void 0) {
        value = null;
      }
      if (validator === void 0) {
        validator = null;
      }
      if (asyncValidator === void 0) {
        asyncValidator = null;
      }
      _super.call(this, validator, asyncValidator);
      this._value = value;
      this.updateValueAndValidity({
        onlySelf: true,
        emitEvent: false
      });
      this._initObservables();
    }
    Control.prototype.updateValue = function(value, _a) {
      var _b = _a === void 0 ? {} : _a,
          onlySelf = _b.onlySelf,
          emitEvent = _b.emitEvent,
          emitModelToViewChange = _b.emitModelToViewChange;
      emitModelToViewChange = isPresent(emitModelToViewChange) ? emitModelToViewChange : true;
      this._value = value;
      if (isPresent(this._onChange) && emitModelToViewChange)
        this._onChange(this._value);
      this.updateValueAndValidity({
        onlySelf: onlySelf,
        emitEvent: emitEvent
      });
    };
    Control.prototype._updateValue = function() {};
    Control.prototype._anyControlsHaveStatus = function(status) {
      return false;
    };
    Control.prototype.registerOnChange = function(fn) {
      this._onChange = fn;
    };
    return Control;
  }(AbstractControl));
  var ControlGroup = (function(_super) {
    __extends(ControlGroup, _super);
    function ControlGroup(controls, optionals, validator, asyncValidator) {
      if (optionals === void 0) {
        optionals = null;
      }
      if (validator === void 0) {
        validator = null;
      }
      if (asyncValidator === void 0) {
        asyncValidator = null;
      }
      _super.call(this, validator, asyncValidator);
      this.controls = controls;
      this._optionals = isPresent(optionals) ? optionals : {};
      this._initObservables();
      this._setParentForControls();
      this.updateValueAndValidity({
        onlySelf: true,
        emitEvent: false
      });
    }
    ControlGroup.prototype.addControl = function(name, control) {
      this.controls[name] = control;
      control.setParent(this);
    };
    ControlGroup.prototype.removeControl = function(name) {
      StringMapWrapper.delete(this.controls, name);
    };
    ControlGroup.prototype.include = function(controlName) {
      StringMapWrapper.set(this._optionals, controlName, true);
      this.updateValueAndValidity();
    };
    ControlGroup.prototype.exclude = function(controlName) {
      StringMapWrapper.set(this._optionals, controlName, false);
      this.updateValueAndValidity();
    };
    ControlGroup.prototype.contains = function(controlName) {
      var c = StringMapWrapper.contains(this.controls, controlName);
      return c && this._included(controlName);
    };
    ControlGroup.prototype._setParentForControls = function() {
      var _this = this;
      StringMapWrapper.forEach(this.controls, function(control, name) {
        control.setParent(_this);
      });
    };
    ControlGroup.prototype._updateValue = function() {
      this._value = this._reduceValue();
    };
    ControlGroup.prototype._anyControlsHaveStatus = function(status) {
      var _this = this;
      var res = false;
      StringMapWrapper.forEach(this.controls, function(control, name) {
        res = res || (_this.contains(name) && control.status == status);
      });
      return res;
    };
    ControlGroup.prototype._reduceValue = function() {
      return this._reduceChildren({}, function(acc, control, name) {
        acc[name] = control.value;
        return acc;
      });
    };
    ControlGroup.prototype._reduceChildren = function(initValue, fn) {
      var _this = this;
      var res = initValue;
      StringMapWrapper.forEach(this.controls, function(control, name) {
        if (_this._included(name)) {
          res = fn(res, control, name);
        }
      });
      return res;
    };
    ControlGroup.prototype._included = function(controlName) {
      var isOptional = StringMapWrapper.contains(this._optionals, controlName);
      return !isOptional || StringMapWrapper.get(this._optionals, controlName);
    };
    return ControlGroup;
  }(AbstractControl));
  var ControlArray = (function(_super) {
    __extends(ControlArray, _super);
    function ControlArray(controls, validator, asyncValidator) {
      if (validator === void 0) {
        validator = null;
      }
      if (asyncValidator === void 0) {
        asyncValidator = null;
      }
      _super.call(this, validator, asyncValidator);
      this.controls = controls;
      this._initObservables();
      this._setParentForControls();
      this.updateValueAndValidity({
        onlySelf: true,
        emitEvent: false
      });
    }
    ControlArray.prototype.at = function(index) {
      return this.controls[index];
    };
    ControlArray.prototype.push = function(control) {
      this.controls.push(control);
      control.setParent(this);
      this.updateValueAndValidity();
    };
    ControlArray.prototype.insert = function(index, control) {
      ListWrapper.insert(this.controls, index, control);
      control.setParent(this);
      this.updateValueAndValidity();
    };
    ControlArray.prototype.removeAt = function(index) {
      ListWrapper.removeAt(this.controls, index);
      this.updateValueAndValidity();
    };
    Object.defineProperty(ControlArray.prototype, "length", {
      get: function() {
        return this.controls.length;
      },
      enumerable: true,
      configurable: true
    });
    ControlArray.prototype._updateValue = function() {
      this._value = this.controls.map(function(control) {
        return control.value;
      });
    };
    ControlArray.prototype._anyControlsHaveStatus = function(status) {
      return this.controls.some(function(c) {
        return c.status == status;
      });
    };
    ControlArray.prototype._setParentForControls = function() {
      var _this = this;
      this.controls.forEach(function(control) {
        control.setParent(_this);
      });
    };
    return ControlArray;
  }(AbstractControl));
  var AbstractControlDirective = (function() {
    function AbstractControlDirective() {}
    Object.defineProperty(AbstractControlDirective.prototype, "control", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "value", {
      get: function() {
        return isPresent(this.control) ? this.control.value : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "valid", {
      get: function() {
        return isPresent(this.control) ? this.control.valid : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "errors", {
      get: function() {
        return isPresent(this.control) ? this.control.errors : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
      get: function() {
        return isPresent(this.control) ? this.control.pristine : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
      get: function() {
        return isPresent(this.control) ? this.control.dirty : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "touched", {
      get: function() {
        return isPresent(this.control) ? this.control.touched : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
      get: function() {
        return isPresent(this.control) ? this.control.untouched : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "path", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return AbstractControlDirective;
  }());
  var ControlContainer = (function(_super) {
    __extends(ControlContainer, _super);
    function ControlContainer() {
      _super.apply(this, arguments);
    }
    Object.defineProperty(ControlContainer.prototype, "formDirective", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ControlContainer.prototype, "path", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return ControlContainer;
  }(AbstractControlDirective));
  var NgControl = (function(_super) {
    __extends(NgControl, _super);
    function NgControl() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
      }
      _super.apply(this, args);
      this.name = null;
      this.valueAccessor = null;
    }
    Object.defineProperty(NgControl.prototype, "validator", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControl.prototype, "asyncValidator", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return NgControl;
  }(AbstractControlDirective));
  var NG_VALUE_ACCESSOR = new _angular_core.OpaqueToken("NgValueAccessor");
  var NG_VALIDATORS = new _angular_core.OpaqueToken("NgValidators");
  var NG_ASYNC_VALIDATORS = new _angular_core.OpaqueToken("NgAsyncValidators");
  var Validators = (function() {
    function Validators() {}
    Validators.required = function(control) {
      return isBlank(control.value) || (isString(control.value) && control.value == "") ? {"required": true} : null;
    };
    Validators.minLength = function(minLength) {
      return function(control) {
        if (isPresent(Validators.required(control)))
          return null;
        var v = control.value;
        return v.length < minLength ? {"minlength": {
            "requiredLength": minLength,
            "actualLength": v.length
          }} : null;
      };
    };
    Validators.maxLength = function(maxLength) {
      return function(control) {
        if (isPresent(Validators.required(control)))
          return null;
        var v = control.value;
        return v.length > maxLength ? {"maxlength": {
            "requiredLength": maxLength,
            "actualLength": v.length
          }} : null;
      };
    };
    Validators.pattern = function(pattern) {
      return function(control) {
        if (isPresent(Validators.required(control)))
          return null;
        var regex = new RegExp("^" + pattern + "$");
        var v = control.value;
        return regex.test(v) ? null : {"pattern": {
            "requiredPattern": "^" + pattern + "$",
            "actualValue": v
          }};
      };
    };
    Validators.nullValidator = function(c) {
      return null;
    };
    Validators.compose = function(validators) {
      if (isBlank(validators))
        return null;
      var presentValidators = validators.filter(isPresent);
      if (presentValidators.length == 0)
        return null;
      return function(control) {
        return _mergeErrors(_executeValidators(control, presentValidators));
      };
    };
    Validators.composeAsync = function(validators) {
      if (isBlank(validators))
        return null;
      var presentValidators = validators.filter(isPresent);
      if (presentValidators.length == 0)
        return null;
      return function(control) {
        var promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
        return PromiseWrapper.all(promises).then(_mergeErrors);
      };
    };
    return Validators;
  }());
  function _convertToPromise(obj) {
    return PromiseWrapper.isPromise(obj) ? obj : ObservableWrapper.toPromise(obj);
  }
  function _executeValidators(control, validators) {
    return validators.map(function(v) {
      return v(control);
    });
  }
  function _executeAsyncValidators(control, validators) {
    return validators.map(function(v) {
      return v(control);
    });
  }
  function _mergeErrors(arrayOfErrors) {
    var res = arrayOfErrors.reduce(function(res, errors) {
      return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
    }, {});
    return StringMapWrapper.isEmpty(res) ? null : res;
  }
  var DEFAULT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: _angular_core.forwardRef(function() {
      return DefaultValueAccessor;
    }),
    multi: true
  };
  var DefaultValueAccessor = (function() {
    function DefaultValueAccessor(_renderer, _elementRef) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      this.onChange = function(_) {};
      this.onTouched = function() {};
    }
    DefaultValueAccessor.prototype.writeValue = function(value) {
      var normalizedValue = isBlank(value) ? '' : value;
      this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
    };
    DefaultValueAccessor.prototype.registerOnChange = function(fn) {
      this.onChange = fn;
    };
    DefaultValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    return DefaultValueAccessor;
  }());
  DefaultValueAccessor.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: 'input:not([type=checkbox])[ngControl],textarea[ngControl],input:not([type=checkbox])[ngFormControl],textarea[ngFormControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
      host: {
        '(input)': 'onChange($event.target.value)',
        '(blur)': 'onTouched()'
      },
      bindings: [DEFAULT_VALUE_ACCESSOR]
    }]
  }];
  DefaultValueAccessor.ctorParameters = [{type: _angular_core.Renderer}, {type: _angular_core.ElementRef}];
  var NUMBER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: _angular_core.forwardRef(function() {
      return NumberValueAccessor;
    }),
    multi: true
  };
  var NumberValueAccessor = (function() {
    function NumberValueAccessor(_renderer, _elementRef) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      this.onChange = function(_) {};
      this.onTouched = function() {};
    }
    NumberValueAccessor.prototype.writeValue = function(value) {
      this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', value);
    };
    NumberValueAccessor.prototype.registerOnChange = function(fn) {
      this.onChange = function(value) {
        fn(value == '' ? null : NumberWrapper.parseFloat(value));
      };
    };
    NumberValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    return NumberValueAccessor;
  }());
  NumberValueAccessor.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: 'input[type=number][ngControl],input[type=number][ngFormControl],input[type=number][ngModel]',
      host: {
        '(change)': 'onChange($event.target.value)',
        '(input)': 'onChange($event.target.value)',
        '(blur)': 'onTouched()'
      },
      bindings: [NUMBER_VALUE_ACCESSOR]
    }]
  }];
  NumberValueAccessor.ctorParameters = [{type: _angular_core.Renderer}, {type: _angular_core.ElementRef}];
  var CHECKBOX_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: _angular_core.forwardRef(function() {
      return CheckboxControlValueAccessor;
    }),
    multi: true
  };
  var CheckboxControlValueAccessor = (function() {
    function CheckboxControlValueAccessor(_renderer, _elementRef) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      this.onChange = function(_) {};
      this.onTouched = function() {};
    }
    CheckboxControlValueAccessor.prototype.writeValue = function(value) {
      this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
    };
    CheckboxControlValueAccessor.prototype.registerOnChange = function(fn) {
      this.onChange = fn;
    };
    CheckboxControlValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    return CheckboxControlValueAccessor;
  }());
  CheckboxControlValueAccessor.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: 'input[type=checkbox][ngControl],input[type=checkbox][ngFormControl],input[type=checkbox][ngModel]',
      host: {
        '(change)': 'onChange($event.target.checked)',
        '(blur)': 'onTouched()'
      },
      providers: [CHECKBOX_VALUE_ACCESSOR]
    }]
  }];
  CheckboxControlValueAccessor.ctorParameters = [{type: _angular_core.Renderer}, {type: _angular_core.ElementRef}];
  var SELECT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: _angular_core.forwardRef(function() {
      return SelectControlValueAccessor;
    }),
    multi: true
  };
  function _buildValueString(id, value) {
    if (isBlank(id))
      return "" + value;
    if (!isPrimitive(value))
      value = "Object";
    return StringWrapper.slice(id + ": " + value, 0, 50);
  }
  function _extractId(valueString) {
    return valueString.split(":")[0];
  }
  var SelectControlValueAccessor = (function() {
    function SelectControlValueAccessor(_renderer, _elementRef) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      this._optionMap = new Map();
      this._idCounter = 0;
      this.onChange = function(_) {};
      this.onTouched = function() {};
    }
    SelectControlValueAccessor.prototype.writeValue = function(value) {
      this.value = value;
      var valueString = _buildValueString(this._getOptionId(value), value);
      this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
    };
    SelectControlValueAccessor.prototype.registerOnChange = function(fn) {
      var _this = this;
      this.onChange = function(valueString) {
        fn(_this._getOptionValue(valueString));
      };
    };
    SelectControlValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    SelectControlValueAccessor.prototype._registerOption = function() {
      return (this._idCounter++).toString();
    };
    SelectControlValueAccessor.prototype._getOptionId = function(value) {
      for (var _i = 0,
          _a = MapWrapper.keys(this._optionMap); _i < _a.length; _i++) {
        var id = _a[_i];
        if (looseIdentical(this._optionMap.get(id), value))
          return id;
      }
      return null;
    };
    SelectControlValueAccessor.prototype._getOptionValue = function(valueString) {
      var value = this._optionMap.get(_extractId(valueString));
      return isPresent(value) ? value : valueString;
    };
    return SelectControlValueAccessor;
  }());
  SelectControlValueAccessor.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: 'select[ngControl],select[ngFormControl],select[ngModel]',
      host: {
        '(change)': 'onChange($event.target.value)',
        '(blur)': 'onTouched()'
      },
      providers: [SELECT_VALUE_ACCESSOR]
    }]
  }];
  SelectControlValueAccessor.ctorParameters = [{type: _angular_core.Renderer}, {type: _angular_core.ElementRef}];
  var NgSelectOption = (function() {
    function NgSelectOption(_element, _renderer, _select) {
      this._element = _element;
      this._renderer = _renderer;
      this._select = _select;
      if (isPresent(this._select))
        this.id = this._select._registerOption();
    }
    Object.defineProperty(NgSelectOption.prototype, "ngValue", {
      set: function(value) {
        if (this._select == null)
          return;
        this._select._optionMap.set(this.id, value);
        this._setElementValue(_buildValueString(this.id, value));
        this._select.writeValue(this._select.value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgSelectOption.prototype, "value", {
      set: function(value) {
        this._setElementValue(value);
        if (isPresent(this._select))
          this._select.writeValue(this._select.value);
      },
      enumerable: true,
      configurable: true
    });
    NgSelectOption.prototype._setElementValue = function(value) {
      this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
    };
    NgSelectOption.prototype.ngOnDestroy = function() {
      if (isPresent(this._select)) {
        this._select._optionMap.delete(this.id);
        this._select.writeValue(this._select.value);
      }
    };
    return NgSelectOption;
  }());
  NgSelectOption.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: 'option'}]
  }];
  NgSelectOption.ctorParameters = [{type: _angular_core.ElementRef}, {type: _angular_core.Renderer}, {
    type: SelectControlValueAccessor,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Host}]
  }];
  NgSelectOption.propDecorators = {
    'ngValue': [{
      type: _angular_core.Input,
      args: ['ngValue']
    }],
    'value': [{
      type: _angular_core.Input,
      args: ['value']
    }]
  };
  var RADIO_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: _angular_core.forwardRef(function() {
      return RadioControlValueAccessor;
    }),
    multi: true
  };
  var RadioControlRegistry = (function() {
    function RadioControlRegistry() {
      this._accessors = [];
    }
    RadioControlRegistry.prototype.add = function(control, accessor) {
      this._accessors.push([control, accessor]);
    };
    RadioControlRegistry.prototype.remove = function(accessor) {
      var indexToRemove = -1;
      for (var i = 0; i < this._accessors.length; ++i) {
        if (this._accessors[i][1] === accessor) {
          indexToRemove = i;
        }
      }
      ListWrapper.removeAt(this._accessors, indexToRemove);
    };
    RadioControlRegistry.prototype.select = function(accessor) {
      this._accessors.forEach(function(c) {
        if (c[0].control.root === accessor._control.control.root && c[1] !== accessor) {
          c[1].fireUncheck();
        }
      });
    };
    return RadioControlRegistry;
  }());
  RadioControlRegistry.decorators = [{type: _angular_core.Injectable}];
  var RadioButtonState = (function() {
    function RadioButtonState(checked, value) {
      this.checked = checked;
      this.value = value;
    }
    return RadioButtonState;
  }());
  var RadioControlValueAccessor = (function() {
    function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      this._registry = _registry;
      this._injector = _injector;
      this.onChange = function() {};
      this.onTouched = function() {};
    }
    RadioControlValueAccessor.prototype.ngOnInit = function() {
      this._control = this._injector.get(NgControl);
      this._registry.add(this._control, this);
    };
    RadioControlValueAccessor.prototype.ngOnDestroy = function() {
      this._registry.remove(this);
    };
    RadioControlValueAccessor.prototype.writeValue = function(value) {
      this._state = value;
      if (isPresent(value) && value.checked) {
        this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', true);
      }
    };
    RadioControlValueAccessor.prototype.registerOnChange = function(fn) {
      var _this = this;
      this._fn = fn;
      this.onChange = function() {
        fn(new RadioButtonState(true, _this._state.value));
        _this._registry.select(_this);
      };
    };
    RadioControlValueAccessor.prototype.fireUncheck = function() {
      this._fn(new RadioButtonState(false, this._state.value));
    };
    RadioControlValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    return RadioControlValueAccessor;
  }());
  RadioControlValueAccessor.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: 'input[type=radio][ngControl],input[type=radio][ngFormControl],input[type=radio][ngModel]',
      host: {
        '(change)': 'onChange()',
        '(blur)': 'onTouched()'
      },
      providers: [RADIO_VALUE_ACCESSOR]
    }]
  }];
  RadioControlValueAccessor.ctorParameters = [{type: _angular_core.Renderer}, {type: _angular_core.ElementRef}, {type: RadioControlRegistry}, {type: _angular_core.Injector}];
  RadioControlValueAccessor.propDecorators = {'name': [{type: _angular_core.Input}]};
  function normalizeValidator(validator) {
    if (validator.validate !== undefined) {
      return function(c) {
        return validator.validate(c);
      };
    } else {
      return validator;
    }
  }
  function normalizeAsyncValidator(validator) {
    if (validator.validate !== undefined) {
      return function(c) {
        return Promise.resolve(validator.validate(c));
      };
    } else {
      return validator;
    }
  }
  function controlPath(name, parent) {
    var p = ListWrapper.clone(parent.path);
    p.push(name);
    return p;
  }
  function setUpControl(control, dir) {
    if (isBlank(control))
      _throwError(dir, "Cannot find control");
    if (isBlank(dir.valueAccessor))
      _throwError(dir, "No value accessor for");
    control.validator = Validators.compose([control.validator, dir.validator]);
    control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
    dir.valueAccessor.writeValue(control.value);
    dir.valueAccessor.registerOnChange(function(newValue) {
      dir.viewToModelUpdate(newValue);
      control.updateValue(newValue, {emitModelToViewChange: false});
      control.markAsDirty();
    });
    control.registerOnChange(function(newValue) {
      return dir.valueAccessor.writeValue(newValue);
    });
    dir.valueAccessor.registerOnTouched(function() {
      return control.markAsTouched();
    });
  }
  function setUpControlGroup(control, dir) {
    if (isBlank(control))
      _throwError(dir, "Cannot find control");
    control.validator = Validators.compose([control.validator, dir.validator]);
    control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
  }
  function _throwError(dir, message) {
    var path = dir.path.join(" -> ");
    throw new BaseException(message + " '" + path + "'");
  }
  function composeValidators(validators) {
    return isPresent(validators) ? Validators.compose(validators.map(normalizeValidator)) : null;
  }
  function composeAsyncValidators(validators) {
    return isPresent(validators) ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) : null;
  }
  function isPropertyUpdated(changes, viewModel) {
    if (!StringMapWrapper.contains(changes, "model"))
      return false;
    var change = changes["model"];
    if (change.isFirstChange())
      return true;
    return !looseIdentical(viewModel, change.currentValue);
  }
  function selectValueAccessor(dir, valueAccessors) {
    if (isBlank(valueAccessors))
      return null;
    var defaultAccessor;
    var builtinAccessor;
    var customAccessor;
    valueAccessors.forEach(function(v) {
      if (hasConstructor(v, DefaultValueAccessor)) {
        defaultAccessor = v;
      } else if (hasConstructor(v, CheckboxControlValueAccessor) || hasConstructor(v, NumberValueAccessor) || hasConstructor(v, SelectControlValueAccessor) || hasConstructor(v, RadioControlValueAccessor)) {
        if (isPresent(builtinAccessor))
          _throwError(dir, "More than one built-in value accessor matches");
        builtinAccessor = v;
      } else {
        if (isPresent(customAccessor))
          _throwError(dir, "More than one custom value accessor matches");
        customAccessor = v;
      }
    });
    if (isPresent(customAccessor))
      return customAccessor;
    if (isPresent(builtinAccessor))
      return builtinAccessor;
    if (isPresent(defaultAccessor))
      return defaultAccessor;
    _throwError(dir, "No valid value accessor for");
    return null;
  }
  var controlNameBinding = {
    provide: NgControl,
    useExisting: _angular_core.forwardRef(function() {
      return NgControlName;
    })
  };
  var NgControlName = (function(_super) {
    __extends(NgControlName, _super);
    function NgControlName(_parent, _validators, _asyncValidators, valueAccessors) {
      _super.call(this);
      this._parent = _parent;
      this._validators = _validators;
      this._asyncValidators = _asyncValidators;
      this.update = new EventEmitter();
      this._added = false;
      this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    NgControlName.prototype.ngOnChanges = function(changes) {
      if (!this._added) {
        this.formDirective.addControl(this);
        this._added = true;
      }
      if (isPropertyUpdated(changes, this.viewModel)) {
        this.viewModel = this.model;
        this.formDirective.updateModel(this, this.model);
      }
    };
    NgControlName.prototype.ngOnDestroy = function() {
      this.formDirective.removeControl(this);
    };
    NgControlName.prototype.viewToModelUpdate = function(newValue) {
      this.viewModel = newValue;
      ObservableWrapper.callEmit(this.update, newValue);
    };
    Object.defineProperty(NgControlName.prototype, "path", {
      get: function() {
        return controlPath(this.name, this._parent);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "formDirective", {
      get: function() {
        return this._parent.formDirective;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "validator", {
      get: function() {
        return composeValidators(this._validators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "asyncValidator", {
      get: function() {
        return composeAsyncValidators(this._asyncValidators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "control", {
      get: function() {
        return this.formDirective.getControl(this);
      },
      enumerable: true,
      configurable: true
    });
    return NgControlName;
  }(NgControl));
  NgControlName.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngControl]',
      bindings: [controlNameBinding],
      inputs: ['name: ngControl', 'model: ngModel'],
      outputs: ['update: ngModelChange'],
      exportAs: 'ngForm'
    }]
  }];
  NgControlName.ctorParameters = [{
    type: ControlContainer,
    decorators: [{type: _angular_core.Host}, {type: _angular_core.SkipSelf}]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }];
  var formControlBinding = {
    provide: NgControl,
    useExisting: _angular_core.forwardRef(function() {
      return NgFormControl;
    })
  };
  var NgFormControl = (function(_super) {
    __extends(NgFormControl, _super);
    function NgFormControl(_validators, _asyncValidators, valueAccessors) {
      _super.call(this);
      this._validators = _validators;
      this._asyncValidators = _asyncValidators;
      this.update = new EventEmitter();
      this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    NgFormControl.prototype.ngOnChanges = function(changes) {
      if (this._isControlChanged(changes)) {
        setUpControl(this.form, this);
        this.form.updateValueAndValidity({emitEvent: false});
      }
      if (isPropertyUpdated(changes, this.viewModel)) {
        this.form.updateValue(this.model);
        this.viewModel = this.model;
      }
    };
    Object.defineProperty(NgFormControl.prototype, "path", {
      get: function() {
        return [];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "validator", {
      get: function() {
        return composeValidators(this._validators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "asyncValidator", {
      get: function() {
        return composeAsyncValidators(this._asyncValidators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "control", {
      get: function() {
        return this.form;
      },
      enumerable: true,
      configurable: true
    });
    NgFormControl.prototype.viewToModelUpdate = function(newValue) {
      this.viewModel = newValue;
      ObservableWrapper.callEmit(this.update, newValue);
    };
    NgFormControl.prototype._isControlChanged = function(changes) {
      return StringMapWrapper.contains(changes, "form");
    };
    return NgFormControl;
  }(NgControl));
  NgFormControl.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngFormControl]',
      bindings: [formControlBinding],
      inputs: ['form: ngFormControl', 'model: ngModel'],
      outputs: ['update: ngModelChange'],
      exportAs: 'ngForm'
    }]
  }];
  NgFormControl.ctorParameters = [{
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }];
  var formControlBinding$1 = {
    provide: NgControl,
    useExisting: _angular_core.forwardRef(function() {
      return NgModel;
    })
  };
  var NgModel = (function(_super) {
    __extends(NgModel, _super);
    function NgModel(_validators, _asyncValidators, valueAccessors) {
      _super.call(this);
      this._validators = _validators;
      this._asyncValidators = _asyncValidators;
      this._control = new Control();
      this._added = false;
      this.update = new EventEmitter();
      this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    NgModel.prototype.ngOnChanges = function(changes) {
      if (!this._added) {
        setUpControl(this._control, this);
        this._control.updateValueAndValidity({emitEvent: false});
        this._added = true;
      }
      if (isPropertyUpdated(changes, this.viewModel)) {
        this._control.updateValue(this.model);
        this.viewModel = this.model;
      }
    };
    Object.defineProperty(NgModel.prototype, "control", {
      get: function() {
        return this._control;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModel.prototype, "path", {
      get: function() {
        return [];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModel.prototype, "validator", {
      get: function() {
        return composeValidators(this._validators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModel.prototype, "asyncValidator", {
      get: function() {
        return composeAsyncValidators(this._asyncValidators);
      },
      enumerable: true,
      configurable: true
    });
    NgModel.prototype.viewToModelUpdate = function(newValue) {
      this.viewModel = newValue;
      ObservableWrapper.callEmit(this.update, newValue);
    };
    return NgModel;
  }(NgControl));
  NgModel.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngModel]:not([ngControl]):not([ngFormControl])',
      bindings: [formControlBinding$1],
      inputs: ['model: ngModel'],
      outputs: ['update: ngModelChange'],
      exportAs: 'ngForm'
    }]
  }];
  NgModel.ctorParameters = [{
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }];
  var controlGroupProvider = {
    provide: ControlContainer,
    useExisting: _angular_core.forwardRef(function() {
      return NgControlGroup;
    })
  };
  var NgControlGroup = (function(_super) {
    __extends(NgControlGroup, _super);
    function NgControlGroup(parent, _validators, _asyncValidators) {
      _super.call(this);
      this._validators = _validators;
      this._asyncValidators = _asyncValidators;
      this._parent = parent;
    }
    NgControlGroup.prototype.ngOnInit = function() {
      this.formDirective.addControlGroup(this);
    };
    NgControlGroup.prototype.ngOnDestroy = function() {
      this.formDirective.removeControlGroup(this);
    };
    Object.defineProperty(NgControlGroup.prototype, "control", {
      get: function() {
        return this.formDirective.getControlGroup(this);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "path", {
      get: function() {
        return controlPath(this.name, this._parent);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "formDirective", {
      get: function() {
        return this._parent.formDirective;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "validator", {
      get: function() {
        return composeValidators(this._validators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "asyncValidator", {
      get: function() {
        return composeAsyncValidators(this._asyncValidators);
      },
      enumerable: true,
      configurable: true
    });
    return NgControlGroup;
  }(ControlContainer));
  NgControlGroup.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngControlGroup]',
      providers: [controlGroupProvider],
      inputs: ['name: ngControlGroup'],
      exportAs: 'ngForm'
    }]
  }];
  NgControlGroup.ctorParameters = [{
    type: ControlContainer,
    decorators: [{type: _angular_core.Host}, {type: _angular_core.SkipSelf}]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }];
  var formDirectiveProvider = {
    provide: ControlContainer,
    useExisting: _angular_core.forwardRef(function() {
      return NgFormModel;
    })
  };
  var NgFormModel = (function(_super) {
    __extends(NgFormModel, _super);
    function NgFormModel(_validators, _asyncValidators) {
      _super.call(this);
      this._validators = _validators;
      this._asyncValidators = _asyncValidators;
      this.form = null;
      this.directives = [];
      this.ngSubmit = new EventEmitter();
    }
    NgFormModel.prototype.ngOnChanges = function(changes) {
      this._checkFormPresent();
      if (StringMapWrapper.contains(changes, "form")) {
        var sync = composeValidators(this._validators);
        this.form.validator = Validators.compose([this.form.validator, sync]);
        var async = composeAsyncValidators(this._asyncValidators);
        this.form.asyncValidator = Validators.composeAsync([this.form.asyncValidator, async]);
        this.form.updateValueAndValidity({
          onlySelf: true,
          emitEvent: false
        });
      }
      this._updateDomValue();
    };
    Object.defineProperty(NgFormModel.prototype, "formDirective", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "control", {
      get: function() {
        return this.form;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "path", {
      get: function() {
        return [];
      },
      enumerable: true,
      configurable: true
    });
    NgFormModel.prototype.addControl = function(dir) {
      var ctrl = this.form.find(dir.path);
      setUpControl(ctrl, dir);
      ctrl.updateValueAndValidity({emitEvent: false});
      this.directives.push(dir);
    };
    NgFormModel.prototype.getControl = function(dir) {
      return this.form.find(dir.path);
    };
    NgFormModel.prototype.removeControl = function(dir) {
      ListWrapper.remove(this.directives, dir);
    };
    NgFormModel.prototype.addControlGroup = function(dir) {
      var ctrl = this.form.find(dir.path);
      setUpControlGroup(ctrl, dir);
      ctrl.updateValueAndValidity({emitEvent: false});
    };
    NgFormModel.prototype.removeControlGroup = function(dir) {};
    NgFormModel.prototype.getControlGroup = function(dir) {
      return this.form.find(dir.path);
    };
    NgFormModel.prototype.updateModel = function(dir, value) {
      var ctrl = this.form.find(dir.path);
      ctrl.updateValue(value);
    };
    NgFormModel.prototype.onSubmit = function() {
      ObservableWrapper.callEmit(this.ngSubmit, null);
      return false;
    };
    NgFormModel.prototype._updateDomValue = function() {
      var _this = this;
      this.directives.forEach(function(dir) {
        var ctrl = _this.form.find(dir.path);
        dir.valueAccessor.writeValue(ctrl.value);
      });
    };
    NgFormModel.prototype._checkFormPresent = function() {
      if (isBlank(this.form)) {
        throw new BaseException("ngFormModel expects a form. Please pass one in. Example: <form [ngFormModel]=\"myCoolForm\">");
      }
    };
    return NgFormModel;
  }(ControlContainer));
  NgFormModel.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngFormModel]',
      bindings: [formDirectiveProvider],
      inputs: ['form: ngFormModel'],
      host: {'(submit)': 'onSubmit()'},
      outputs: ['ngSubmit'],
      exportAs: 'ngForm'
    }]
  }];
  NgFormModel.ctorParameters = [{
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }];
  var formDirectiveProvider$1 = {
    provide: ControlContainer,
    useExisting: _angular_core.forwardRef(function() {
      return NgForm;
    })
  };
  var NgForm = (function(_super) {
    __extends(NgForm, _super);
    function NgForm(validators, asyncValidators) {
      _super.call(this);
      this.ngSubmit = new EventEmitter();
      this.form = new ControlGroup({}, null, composeValidators(validators), composeAsyncValidators(asyncValidators));
    }
    Object.defineProperty(NgForm.prototype, "formDirective", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForm.prototype, "control", {
      get: function() {
        return this.form;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForm.prototype, "path", {
      get: function() {
        return [];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForm.prototype, "controls", {
      get: function() {
        return this.form.controls;
      },
      enumerable: true,
      configurable: true
    });
    NgForm.prototype.addControl = function(dir) {
      var _this = this;
      PromiseWrapper.scheduleMicrotask(function() {
        var container = _this._findContainer(dir.path);
        var ctrl = new Control();
        setUpControl(ctrl, dir);
        container.addControl(dir.name, ctrl);
        ctrl.updateValueAndValidity({emitEvent: false});
      });
    };
    NgForm.prototype.getControl = function(dir) {
      return this.form.find(dir.path);
    };
    NgForm.prototype.removeControl = function(dir) {
      var _this = this;
      PromiseWrapper.scheduleMicrotask(function() {
        var container = _this._findContainer(dir.path);
        if (isPresent(container)) {
          container.removeControl(dir.name);
          container.updateValueAndValidity({emitEvent: false});
        }
      });
    };
    NgForm.prototype.addControlGroup = function(dir) {
      var _this = this;
      PromiseWrapper.scheduleMicrotask(function() {
        var container = _this._findContainer(dir.path);
        var group = new ControlGroup({});
        setUpControlGroup(group, dir);
        container.addControl(dir.name, group);
        group.updateValueAndValidity({emitEvent: false});
      });
    };
    NgForm.prototype.removeControlGroup = function(dir) {
      var _this = this;
      PromiseWrapper.scheduleMicrotask(function() {
        var container = _this._findContainer(dir.path);
        if (isPresent(container)) {
          container.removeControl(dir.name);
          container.updateValueAndValidity({emitEvent: false});
        }
      });
    };
    NgForm.prototype.getControlGroup = function(dir) {
      return this.form.find(dir.path);
    };
    NgForm.prototype.updateModel = function(dir, value) {
      var _this = this;
      PromiseWrapper.scheduleMicrotask(function() {
        var ctrl = _this.form.find(dir.path);
        ctrl.updateValue(value);
      });
    };
    NgForm.prototype.onSubmit = function() {
      ObservableWrapper.callEmit(this.ngSubmit, null);
      return false;
    };
    NgForm.prototype._findContainer = function(path) {
      path.pop();
      return ListWrapper.isEmpty(path) ? this.form : this.form.find(path);
    };
    return NgForm;
  }(ControlContainer));
  NgForm.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: 'form:not([ngNoForm]):not([ngFormModel]),ngForm,[ngForm]',
      bindings: [formDirectiveProvider$1],
      host: {'(submit)': 'onSubmit()'},
      outputs: ['ngSubmit'],
      exportAs: 'ngForm'
    }]
  }];
  NgForm.ctorParameters = [{
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {type: _angular_core.Self}, {
      type: _angular_core.Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }];
  var NgControlStatus = (function() {
    function NgControlStatus(cd) {
      this._cd = cd;
    }
    Object.defineProperty(NgControlStatus.prototype, "ngClassUntouched", {
      get: function() {
        return isPresent(this._cd.control) ? this._cd.control.untouched : false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassTouched", {
      get: function() {
        return isPresent(this._cd.control) ? this._cd.control.touched : false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassPristine", {
      get: function() {
        return isPresent(this._cd.control) ? this._cd.control.pristine : false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassDirty", {
      get: function() {
        return isPresent(this._cd.control) ? this._cd.control.dirty : false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassValid", {
      get: function() {
        return isPresent(this._cd.control) ? this._cd.control.valid : false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassInvalid", {
      get: function() {
        return isPresent(this._cd.control) ? !this._cd.control.valid : false;
      },
      enumerable: true,
      configurable: true
    });
    return NgControlStatus;
  }());
  NgControlStatus.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[ngControl],[ngModel],[ngFormControl]',
      host: {
        '[class.ng-untouched]': 'ngClassUntouched',
        '[class.ng-touched]': 'ngClassTouched',
        '[class.ng-pristine]': 'ngClassPristine',
        '[class.ng-dirty]': 'ngClassDirty',
        '[class.ng-valid]': 'ngClassValid',
        '[class.ng-invalid]': 'ngClassInvalid'
      }
    }]
  }];
  NgControlStatus.ctorParameters = [{
    type: NgControl,
    decorators: [{type: _angular_core.Self}]
  }];
  var REQUIRED = Validators.required;
  var REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useValue: REQUIRED,
    multi: true
  };
  var RequiredValidator = (function() {
    function RequiredValidator() {}
    return RequiredValidator;
  }());
  RequiredValidator.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[required][ngControl],[required][ngFormControl],[required][ngModel]',
      providers: [REQUIRED_VALIDATOR]
    }]
  }];
  var MIN_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: _angular_core.forwardRef(function() {
      return MinLengthValidator;
    }),
    multi: true
  };
  var MinLengthValidator = (function() {
    function MinLengthValidator(minLength) {
      this._validator = Validators.minLength(NumberWrapper.parseInt(minLength, 10));
    }
    MinLengthValidator.prototype.validate = function(c) {
      return this._validator(c);
    };
    return MinLengthValidator;
  }());
  MinLengthValidator.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[minlength][ngControl],[minlength][ngFormControl],[minlength][ngModel]',
      providers: [MIN_LENGTH_VALIDATOR]
    }]
  }];
  MinLengthValidator.ctorParameters = [{
    type: undefined,
    decorators: [{
      type: _angular_core.Attribute,
      args: ["minlength"]
    }]
  }];
  var MAX_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: _angular_core.forwardRef(function() {
      return MaxLengthValidator;
    }),
    multi: true
  };
  var MaxLengthValidator = (function() {
    function MaxLengthValidator(maxLength) {
      this._validator = Validators.maxLength(NumberWrapper.parseInt(maxLength, 10));
    }
    MaxLengthValidator.prototype.validate = function(c) {
      return this._validator(c);
    };
    return MaxLengthValidator;
  }());
  MaxLengthValidator.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[maxlength][ngControl],[maxlength][ngFormControl],[maxlength][ngModel]',
      providers: [MAX_LENGTH_VALIDATOR]
    }]
  }];
  MaxLengthValidator.ctorParameters = [{
    type: undefined,
    decorators: [{
      type: _angular_core.Attribute,
      args: ["maxlength"]
    }]
  }];
  var PATTERN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: _angular_core.forwardRef(function() {
      return PatternValidator;
    }),
    multi: true
  };
  var PatternValidator = (function() {
    function PatternValidator(pattern) {
      this._validator = Validators.pattern(pattern);
    }
    PatternValidator.prototype.validate = function(c) {
      return this._validator(c);
    };
    return PatternValidator;
  }());
  PatternValidator.decorators = [{
    type: _angular_core.Directive,
    args: [{
      selector: '[pattern][ngControl],[pattern][ngFormControl],[pattern][ngModel]',
      providers: [PATTERN_VALIDATOR]
    }]
  }];
  PatternValidator.ctorParameters = [{
    type: undefined,
    decorators: [{
      type: _angular_core.Attribute,
      args: ["pattern"]
    }]
  }];
  var FORM_DIRECTIVES = [NgControlName, NgControlGroup, NgFormControl, NgModel, NgFormModel, NgForm, NgSelectOption, DefaultValueAccessor, NumberValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, RadioControlValueAccessor, NgControlStatus, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator];
  var FormBuilder = (function() {
    function FormBuilder() {}
    FormBuilder.prototype.group = function(controlsConfig, extra) {
      if (extra === void 0) {
        extra = null;
      }
      var controls = this._reduceControls(controlsConfig);
      var optionals = (isPresent(extra) ? StringMapWrapper.get(extra, "optionals") : null);
      var validator = isPresent(extra) ? StringMapWrapper.get(extra, "validator") : null;
      var asyncValidator = isPresent(extra) ? StringMapWrapper.get(extra, "asyncValidator") : null;
      return new ControlGroup(controls, optionals, validator, asyncValidator);
    };
    FormBuilder.prototype.control = function(value, validator, asyncValidator) {
      if (validator === void 0) {
        validator = null;
      }
      if (asyncValidator === void 0) {
        asyncValidator = null;
      }
      return new Control(value, validator, asyncValidator);
    };
    FormBuilder.prototype.array = function(controlsConfig, validator, asyncValidator) {
      var _this = this;
      if (validator === void 0) {
        validator = null;
      }
      if (asyncValidator === void 0) {
        asyncValidator = null;
      }
      var controls = controlsConfig.map(function(c) {
        return _this._createControl(c);
      });
      return new ControlArray(controls, validator, asyncValidator);
    };
    FormBuilder.prototype._reduceControls = function(controlsConfig) {
      var _this = this;
      var controls = {};
      StringMapWrapper.forEach(controlsConfig, function(controlConfig, controlName) {
        controls[controlName] = _this._createControl(controlConfig);
      });
      return controls;
    };
    FormBuilder.prototype._createControl = function(controlConfig) {
      if (controlConfig instanceof Control || controlConfig instanceof ControlGroup || controlConfig instanceof ControlArray) {
        return controlConfig;
      } else if (isArray(controlConfig)) {
        var value = controlConfig[0];
        var validator = controlConfig.length > 1 ? controlConfig[1] : null;
        var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
        return this.control(value, validator, asyncValidator);
      } else {
        return this.control(controlConfig);
      }
    };
    return FormBuilder;
  }());
  FormBuilder.decorators = [{type: _angular_core.Injectable}];
  var FORM_PROVIDERS = [FormBuilder, RadioControlRegistry];
  var FORM_BINDINGS = FORM_PROVIDERS;
  var COMMON_DIRECTIVES = [CORE_DIRECTIVES, FORM_DIRECTIVES];
  var PlatformLocation = (function() {
    function PlatformLocation() {}
    Object.defineProperty(PlatformLocation.prototype, "pathname", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PlatformLocation.prototype, "search", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PlatformLocation.prototype, "hash", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return PlatformLocation;
  }());
  var LocationStrategy = (function() {
    function LocationStrategy() {}
    return LocationStrategy;
  }());
  var APP_BASE_HREF = new _angular_core.OpaqueToken('appBaseHref');
  var Location = (function() {
    function Location(platformStrategy) {
      var _this = this;
      this.platformStrategy = platformStrategy;
      this._subject = new EventEmitter();
      var browserBaseHref = this.platformStrategy.getBaseHref();
      this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
      this.platformStrategy.onPopState(function(ev) {
        ObservableWrapper.callEmit(_this._subject, {
          'url': _this.path(),
          'pop': true,
          'type': ev.type
        });
      });
    }
    Location.prototype.path = function() {
      return this.normalize(this.platformStrategy.path());
    };
    Location.prototype.normalize = function(url) {
      return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
    };
    Location.prototype.prepareExternalUrl = function(url) {
      if (url.length > 0 && !url.startsWith('/')) {
        url = '/' + url;
      }
      return this.platformStrategy.prepareExternalUrl(url);
    };
    Location.prototype.go = function(path, query) {
      if (query === void 0) {
        query = '';
      }
      this.platformStrategy.pushState(null, '', path, query);
    };
    Location.prototype.replaceState = function(path, query) {
      if (query === void 0) {
        query = '';
      }
      this.platformStrategy.replaceState(null, '', path, query);
    };
    Location.prototype.forward = function() {
      this.platformStrategy.forward();
    };
    Location.prototype.back = function() {
      this.platformStrategy.back();
    };
    Location.prototype.subscribe = function(onNext, onThrow, onReturn) {
      if (onThrow === void 0) {
        onThrow = null;
      }
      if (onReturn === void 0) {
        onReturn = null;
      }
      return ObservableWrapper.subscribe(this._subject, onNext, onThrow, onReturn);
    };
    Location.normalizeQueryParams = function(params) {
      return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;
    };
    Location.joinWithSlash = function(start, end) {
      if (start.length == 0) {
        return end;
      }
      if (end.length == 0) {
        return start;
      }
      var slashes = 0;
      if (start.endsWith('/')) {
        slashes++;
      }
      if (end.startsWith('/')) {
        slashes++;
      }
      if (slashes == 2) {
        return start + end.substring(1);
      }
      if (slashes == 1) {
        return start + end;
      }
      return start + '/' + end;
    };
    Location.stripTrailingSlash = function(url) {
      if (/\/$/g.test(url)) {
        url = url.substring(0, url.length - 1);
      }
      return url;
    };
    return Location;
  }());
  Location.decorators = [{type: _angular_core.Injectable}];
  Location.ctorParameters = [{type: LocationStrategy}];
  function _stripBaseHref(baseHref, url) {
    if (baseHref.length > 0 && url.startsWith(baseHref)) {
      return url.substring(baseHref.length);
    }
    return url;
  }
  function _stripIndexHtml(url) {
    if (/\/index.html$/g.test(url)) {
      return url.substring(0, url.length - 11);
    }
    return url;
  }
  var HashLocationStrategy = (function(_super) {
    __extends(HashLocationStrategy, _super);
    function HashLocationStrategy(_platformLocation, _baseHref) {
      _super.call(this);
      this._platformLocation = _platformLocation;
      this._baseHref = '';
      if (isPresent(_baseHref)) {
        this._baseHref = _baseHref;
      }
    }
    HashLocationStrategy.prototype.onPopState = function(fn) {
      this._platformLocation.onPopState(fn);
      this._platformLocation.onHashChange(fn);
    };
    HashLocationStrategy.prototype.getBaseHref = function() {
      return this._baseHref;
    };
    HashLocationStrategy.prototype.path = function() {
      var path = this._platformLocation.hash;
      if (!isPresent(path))
        path = '#';
      return (path.length > 0 ? path.substring(1) : path);
    };
    HashLocationStrategy.prototype.prepareExternalUrl = function(internal) {
      var url = Location.joinWithSlash(this._baseHref, internal);
      return url.length > 0 ? ('#' + url) : url;
    };
    HashLocationStrategy.prototype.pushState = function(state, title, path, queryParams) {
      var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
      if (url.length == 0) {
        url = this._platformLocation.pathname;
      }
      this._platformLocation.pushState(state, title, url);
    };
    HashLocationStrategy.prototype.replaceState = function(state, title, path, queryParams) {
      var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
      if (url.length == 0) {
        url = this._platformLocation.pathname;
      }
      this._platformLocation.replaceState(state, title, url);
    };
    HashLocationStrategy.prototype.forward = function() {
      this._platformLocation.forward();
    };
    HashLocationStrategy.prototype.back = function() {
      this._platformLocation.back();
    };
    return HashLocationStrategy;
  }(LocationStrategy));
  HashLocationStrategy.decorators = [{type: _angular_core.Injectable}];
  HashLocationStrategy.ctorParameters = [{type: PlatformLocation}, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {
      type: _angular_core.Inject,
      args: [APP_BASE_HREF]
    }]
  }];
  var PathLocationStrategy = (function(_super) {
    __extends(PathLocationStrategy, _super);
    function PathLocationStrategy(_platformLocation, href) {
      _super.call(this);
      this._platformLocation = _platformLocation;
      if (isBlank(href)) {
        href = this._platformLocation.getBaseHrefFromDOM();
      }
      if (isBlank(href)) {
        throw new BaseException("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
      }
      this._baseHref = href;
    }
    PathLocationStrategy.prototype.onPopState = function(fn) {
      this._platformLocation.onPopState(fn);
      this._platformLocation.onHashChange(fn);
    };
    PathLocationStrategy.prototype.getBaseHref = function() {
      return this._baseHref;
    };
    PathLocationStrategy.prototype.prepareExternalUrl = function(internal) {
      return Location.joinWithSlash(this._baseHref, internal);
    };
    PathLocationStrategy.prototype.path = function() {
      return this._platformLocation.pathname + Location.normalizeQueryParams(this._platformLocation.search);
    };
    PathLocationStrategy.prototype.pushState = function(state, title, url, queryParams) {
      var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
      this._platformLocation.pushState(state, title, externalUrl);
    };
    PathLocationStrategy.prototype.replaceState = function(state, title, url, queryParams) {
      var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
      this._platformLocation.replaceState(state, title, externalUrl);
    };
    PathLocationStrategy.prototype.forward = function() {
      this._platformLocation.forward();
    };
    PathLocationStrategy.prototype.back = function() {
      this._platformLocation.back();
    };
    return PathLocationStrategy;
  }(LocationStrategy));
  PathLocationStrategy.decorators = [{type: _angular_core.Injectable}];
  PathLocationStrategy.ctorParameters = [{type: PlatformLocation}, {
    type: undefined,
    decorators: [{type: _angular_core.Optional}, {
      type: _angular_core.Inject,
      args: [APP_BASE_HREF]
    }]
  }];
  exports.AsyncPipe = AsyncPipe;
  exports.DatePipe = DatePipe;
  exports.JsonPipe = JsonPipe;
  exports.SlicePipe = SlicePipe;
  exports.LowerCasePipe = LowerCasePipe;
  exports.NumberPipe = NumberPipe;
  exports.DecimalPipe = DecimalPipe;
  exports.PercentPipe = PercentPipe;
  exports.CurrencyPipe = CurrencyPipe;
  exports.UpperCasePipe = UpperCasePipe;
  exports.ReplacePipe = ReplacePipe;
  exports.I18nPluralPipe = I18nPluralPipe;
  exports.I18nSelectPipe = I18nSelectPipe;
  exports.COMMON_PIPES = COMMON_PIPES;
  exports.NgClass = NgClass;
  exports.NgFor = NgFor;
  exports.NgIf = NgIf;
  exports.NgTemplateOutlet = NgTemplateOutlet;
  exports.NgStyle = NgStyle;
  exports.NgSwitch = NgSwitch;
  exports.NgSwitchWhen = NgSwitchWhen;
  exports.NgSwitchDefault = NgSwitchDefault;
  exports.NgPlural = NgPlural;
  exports.NgPluralCase = NgPluralCase;
  exports.NgLocalization = NgLocalization;
  exports.CORE_DIRECTIVES = CORE_DIRECTIVES;
  exports.workaround_empty_observable_list_diff = workaround_empty_observable_list_diff;
  exports.FORM_PROVIDERS = FORM_PROVIDERS;
  exports.FORM_BINDINGS = FORM_BINDINGS;
  exports.AbstractControl = AbstractControl;
  exports.Control = Control;
  exports.ControlGroup = ControlGroup;
  exports.ControlArray = ControlArray;
  exports.AbstractControlDirective = AbstractControlDirective;
  exports.ControlContainer = ControlContainer;
  exports.NgControlName = NgControlName;
  exports.NgFormControl = NgFormControl;
  exports.NgModel = NgModel;
  exports.NgControl = NgControl;
  exports.NgControlGroup = NgControlGroup;
  exports.NgFormModel = NgFormModel;
  exports.NgForm = NgForm;
  exports.NG_VALUE_ACCESSOR = NG_VALUE_ACCESSOR;
  exports.DefaultValueAccessor = DefaultValueAccessor;
  exports.NgControlStatus = NgControlStatus;
  exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;
  exports.NgSelectOption = NgSelectOption;
  exports.SelectControlValueAccessor = SelectControlValueAccessor;
  exports.FORM_DIRECTIVES = FORM_DIRECTIVES;
  exports.RadioButtonState = RadioButtonState;
  exports.NG_VALIDATORS = NG_VALIDATORS;
  exports.NG_ASYNC_VALIDATORS = NG_ASYNC_VALIDATORS;
  exports.Validators = Validators;
  exports.RequiredValidator = RequiredValidator;
  exports.MinLengthValidator = MinLengthValidator;
  exports.MaxLengthValidator = MaxLengthValidator;
  exports.PatternValidator = PatternValidator;
  exports.FormBuilder = FormBuilder;
  exports.COMMON_DIRECTIVES = COMMON_DIRECTIVES;
  exports.PlatformLocation = PlatformLocation;
  exports.LocationStrategy = LocationStrategy;
  exports.APP_BASE_HREF = APP_BASE_HREF;
  exports.HashLocationStrategy = HashLocationStrategy;
  exports.PathLocationStrategy = PathLocationStrategy;
  exports.Location = Location;
}));

})();
(function() {
var define = $__System.amdDefine;
var __extends = (this && this.__extends) || function(d, b) {
  for (var p in b)
    if (b.hasOwnProperty(p))
      d[p] = b[p];
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) : typeof define === 'function' && define.amd ? define("9", ["exports", "3", "8"], factory) : (factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}), global.ng.core, global.ng.common));
}(this, function(exports, _angular_core, _angular_common) {
  'use strict';
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  var IS_DART = false;
  var global$1 = globalScope;
  var Date = global$1.Date;
  var _devMode = true;
  function assertionsEnabled() {
    return _devMode;
  }
  global$1.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  function isString(obj) {
    return typeof obj === "string";
  }
  function isFunction(obj) {
    return typeof obj === "function";
  }
  function isArray(obj) {
    return Array.isArray(obj);
  }
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.name) {
      return token.name;
    }
    if (token.overriddenName) {
      return token.overriddenName;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  var StringWrapper = (function() {
    function StringWrapper() {}
    StringWrapper.fromCharCode = function(code) {
      return String.fromCharCode(code);
    };
    StringWrapper.charCodeAt = function(s, index) {
      return s.charCodeAt(index);
    };
    StringWrapper.split = function(s, regExp) {
      return s.split(regExp);
    };
    StringWrapper.equals = function(s, s2) {
      return s === s2;
    };
    StringWrapper.stripLeft = function(s, charVal) {
      if (s && s.length) {
        var pos = 0;
        for (var i = 0; i < s.length; i++) {
          if (s[i] != charVal)
            break;
          pos++;
        }
        s = s.substring(pos);
      }
      return s;
    };
    StringWrapper.stripRight = function(s, charVal) {
      if (s && s.length) {
        var pos = s.length;
        for (var i = s.length - 1; i >= 0; i--) {
          if (s[i] != charVal)
            break;
          pos--;
        }
        s = s.substring(0, pos);
      }
      return s;
    };
    StringWrapper.replace = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.slice = function(s, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function(s, from, cb) {
      return s.replace(from, function() {
        var matches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          matches[_i - 0] = arguments[_i];
        }
        matches.splice(-2, 2);
        return cb(matches);
      });
    };
    StringWrapper.contains = function(s, substr) {
      return s.indexOf(substr) != -1;
    };
    StringWrapper.compare = function(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    return StringWrapper;
  }());
  var NumberParseError = (function(_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
      _super.call(this);
      this.message = message;
    }
    NumberParseError.prototype.toString = function() {
      return this.message;
    };
    return NumberParseError;
  }(Error));
  var NumberWrapper = (function() {
    function NumberWrapper() {}
    NumberWrapper.toFixed = function(n, fractionDigits) {
      return n.toFixed(fractionDigits);
    };
    NumberWrapper.equal = function(a, b) {
      return a === b;
    };
    NumberWrapper.parseIntAutoRadix = function(text) {
      var result = parseInt(text);
      if (isNaN(result)) {
        throw new NumberParseError("Invalid integer literal when parsing " + text);
      }
      return result;
    };
    NumberWrapper.parseInt = function(text, radix) {
      if (radix == 10) {
        if (/^(\-|\+)?[0-9]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else if (radix == 16) {
        if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else {
        var result = parseInt(text, radix);
        if (!isNaN(result)) {
          return result;
        }
      }
      throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " + radix);
    };
    NumberWrapper.parseFloat = function(text) {
      return parseFloat(text);
    };
    Object.defineProperty(NumberWrapper, "NaN", {
      get: function() {
        return NaN;
      },
      enumerable: true,
      configurable: true
    });
    NumberWrapper.isNaN = function(value) {
      return isNaN(value);
    };
    NumberWrapper.isInteger = function(value) {
      return Number.isInteger(value);
    };
    return NumberWrapper;
  }());
  var RegExpWrapper = (function() {
    function RegExpWrapper() {}
    RegExpWrapper.create = function(regExpStr, flags) {
      if (flags === void 0) {
        flags = '';
      }
      flags = flags.replace(/g/g, '');
      return new global$1.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function(regExp, input) {
      regExp.lastIndex = 0;
      return regExp.exec(input);
    };
    RegExpWrapper.test = function(regExp, input) {
      regExp.lastIndex = 0;
      return regExp.test(input);
    };
    RegExpWrapper.matcher = function(regExp, input) {
      regExp.lastIndex = 0;
      return {
        re: regExp,
        input: input
      };
    };
    RegExpWrapper.replaceAll = function(regExp, input, replace) {
      var c = regExp.exec(input);
      var res = '';
      regExp.lastIndex = 0;
      var prev = 0;
      while (c) {
        res += input.substring(prev, c.index);
        res += replace(c);
        prev = c.index + c[0].length;
        regExp.lastIndex = prev;
        c = regExp.exec(input);
      }
      res += input.substring(prev);
      return res;
    };
    return RegExpWrapper;
  }());
  var Json = (function() {
    function Json() {}
    Json.parse = function(s) {
      return global$1.JSON.parse(s);
    };
    Json.stringify = function(data) {
      return global$1.JSON.stringify(data, null, 2);
    };
    return Json;
  }());
  var DateWrapper = (function() {
    function DateWrapper() {}
    DateWrapper.create = function(year, month, day, hour, minutes, seconds, milliseconds) {
      if (month === void 0) {
        month = 1;
      }
      if (day === void 0) {
        day = 1;
      }
      if (hour === void 0) {
        hour = 0;
      }
      if (minutes === void 0) {
        minutes = 0;
      }
      if (seconds === void 0) {
        seconds = 0;
      }
      if (milliseconds === void 0) {
        milliseconds = 0;
      }
      return new Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function(str) {
      return new Date(str);
    };
    DateWrapper.fromMillis = function(ms) {
      return new Date(ms);
    };
    DateWrapper.toMillis = function(date) {
      return date.getTime();
    };
    DateWrapper.now = function() {
      return new Date();
    };
    DateWrapper.toJson = function(date) {
      return date.toJSON();
    };
    return DateWrapper;
  }());
  function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
      var name = parts.shift();
      if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
        obj = obj[name];
      } else {
        obj = obj[name] = {};
      }
    }
    if (obj === undefined || obj === null) {
      obj = {};
    }
    obj[parts.shift()] = value;
  }
  var wtfInit = _angular_core.__core_private__.wtfInit;
  var DebugDomRootRenderer = _angular_core.__core_private__.DebugDomRootRenderer;
  var SecurityContext = _angular_core.__core_private__.SecurityContext;
  var SanitizationService = _angular_core.__core_private__.SanitizationService;
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
  function sanitizeUrl(url) {
    if (String(url).match(SAFE_URL_PATTERN))
      return url;
    return 'unsafe:' + url;
  }
  var SAFE_STYLE_VALUE = /^([-,."'%_!# a-zA-Z0-9]+|(?:rgb|hsl)a?\([0-9.%, ]+\))$/;
  function hasBalancedQuotes(value) {
    var outsideSingle = true;
    var outsideDouble = true;
    for (var i = 0; i < value.length; i++) {
      var c = value.charAt(i);
      if (c === '\'' && outsideDouble) {
        outsideSingle = !outsideSingle;
      } else if (c === '"' && outsideSingle) {
        outsideDouble = !outsideDouble;
      }
    }
    return outsideSingle && outsideDouble;
  }
  function sanitizeStyle(value) {
    if (String(value).match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value))
      return value;
    return 'unsafe';
  }
  var DomSanitizationService = (function() {
    function DomSanitizationService() {}
    return DomSanitizationService;
  }());
  var DomSanitizationServiceImpl = (function(_super) {
    __extends(DomSanitizationServiceImpl, _super);
    function DomSanitizationServiceImpl() {
      _super.apply(this, arguments);
    }
    DomSanitizationServiceImpl.prototype.sanitize = function(ctx, value) {
      if (value == null)
        return null;
      switch (ctx) {
        case SecurityContext.NONE:
          return value;
        case SecurityContext.HTML:
          if (value instanceof SafeHtmlImpl)
            return value.changingThisBreaksApplicationSecurity;
          this.checkNotSafeValue(value, 'HTML');
          return this.sanitizeHtml(String(value));
        case SecurityContext.STYLE:
          if (value instanceof SafeStyleImpl)
            return value.changingThisBreaksApplicationSecurity;
          this.checkNotSafeValue(value, 'Style');
          return sanitizeStyle(value);
        case SecurityContext.SCRIPT:
          if (value instanceof SafeScriptImpl)
            return value.changingThisBreaksApplicationSecurity;
          this.checkNotSafeValue(value, 'Script');
          throw new Error('unsafe value used in a script context');
        case SecurityContext.URL:
          if (value instanceof SafeUrlImpl)
            return value.changingThisBreaksApplicationSecurity;
          this.checkNotSafeValue(value, 'URL');
          return sanitizeUrl(String(value));
        case SecurityContext.RESOURCE_URL:
          if (value instanceof SafeResourceUrlImpl) {
            return value.changingThisBreaksApplicationSecurity;
          }
          this.checkNotSafeValue(value, 'ResourceURL');
          throw new Error('unsafe value used in a resource URL context');
        default:
          throw new Error("Unexpected SecurityContext " + ctx);
      }
    };
    DomSanitizationServiceImpl.prototype.checkNotSafeValue = function(value, expectedType) {
      if (value instanceof SafeValueImpl) {
        throw new Error('Required a safe ' + expectedType + ', got a ' + value.getTypeName());
      }
    };
    DomSanitizationServiceImpl.prototype.sanitizeHtml = function(value) {
      return value;
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustHtml = function(value) {
      return new SafeHtmlImpl(value);
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustStyle = function(value) {
      return new SafeStyleImpl(value);
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustScript = function(value) {
      return new SafeScriptImpl(value);
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustUrl = function(value) {
      return new SafeUrlImpl(value);
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustResourceUrl = function(value) {
      return new SafeResourceUrlImpl(value);
    };
    return DomSanitizationServiceImpl;
  }(DomSanitizationService));
  DomSanitizationServiceImpl.decorators = [{type: _angular_core.Injectable}];
  var SafeValueImpl = (function() {
    function SafeValueImpl(changingThisBreaksApplicationSecurity) {
      this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
    }
    return SafeValueImpl;
  }());
  var SafeHtmlImpl = (function(_super) {
    __extends(SafeHtmlImpl, _super);
    function SafeHtmlImpl() {
      _super.apply(this, arguments);
    }
    SafeHtmlImpl.prototype.getTypeName = function() {
      return 'HTML';
    };
    return SafeHtmlImpl;
  }(SafeValueImpl));
  var SafeStyleImpl = (function(_super) {
    __extends(SafeStyleImpl, _super);
    function SafeStyleImpl() {
      _super.apply(this, arguments);
    }
    SafeStyleImpl.prototype.getTypeName = function() {
      return 'Style';
    };
    return SafeStyleImpl;
  }(SafeValueImpl));
  var SafeScriptImpl = (function(_super) {
    __extends(SafeScriptImpl, _super);
    function SafeScriptImpl() {
      _super.apply(this, arguments);
    }
    SafeScriptImpl.prototype.getTypeName = function() {
      return 'Script';
    };
    return SafeScriptImpl;
  }(SafeValueImpl));
  var SafeUrlImpl = (function(_super) {
    __extends(SafeUrlImpl, _super);
    function SafeUrlImpl() {
      _super.apply(this, arguments);
    }
    SafeUrlImpl.prototype.getTypeName = function() {
      return 'URL';
    };
    return SafeUrlImpl;
  }(SafeValueImpl));
  var SafeResourceUrlImpl = (function(_super) {
    __extends(SafeResourceUrlImpl, _super);
    function SafeResourceUrlImpl() {
      _super.apply(this, arguments);
    }
    SafeResourceUrlImpl.prototype.getTypeName = function() {
      return 'ResourceURL';
    };
    return SafeResourceUrlImpl;
  }(SafeValueImpl));
  var Map$1 = global$1.Map;
  var Set$1 = global$1.Set;
  var createMapFromPairs = (function() {
    try {
      if (new Map$1([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new Map$1(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new Map$1();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new Map$1(new Map$1())) {
        return function createMapFromMap(m) {
          return new Map$1(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new Map$1();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new Map$1()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new Map$1()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var StringMapWrapper = (function() {
    function StringMapWrapper() {}
    StringMapWrapper.create = function() {
      return {};
    };
    StringMapWrapper.contains = function(map, key) {
      return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function(map, key) {
      return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function(map, key, value) {
      map[key] = value;
    };
    StringMapWrapper.keys = function(map) {
      return Object.keys(map);
    };
    StringMapWrapper.values = function(map) {
      return Object.keys(map).reduce(function(r, a) {
        r.push(map[a]);
        return r;
      }, []);
    };
    StringMapWrapper.isEmpty = function(map) {
      for (var prop in map) {
        return false;
      }
      return true;
    };
    StringMapWrapper.delete = function(map, key) {
      delete map[key];
    };
    StringMapWrapper.forEach = function(map, callback) {
      for (var prop in map) {
        if (map.hasOwnProperty(prop)) {
          callback(map[prop], prop);
        }
      }
    };
    StringMapWrapper.merge = function(m1, m2) {
      var m = {};
      for (var attr in m1) {
        if (m1.hasOwnProperty(attr)) {
          m[attr] = m1[attr];
        }
      }
      for (var attr in m2) {
        if (m2.hasOwnProperty(attr)) {
          m[attr] = m2[attr];
        }
      }
      return m;
    };
    StringMapWrapper.equals = function(m1, m2) {
      var k1 = Object.keys(m1);
      var k2 = Object.keys(m2);
      if (k1.length != k2.length) {
        return false;
      }
      var key;
      for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (m1[key] !== m2[key]) {
          return false;
        }
      }
      return true;
    };
    return StringMapWrapper;
  }());
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  function _flattenArray(source, target) {
    if (isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  var createSetFromList = (function() {
    var test = new Set$1([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new Set$1(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new Set$1(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var SetWrapper = (function() {
    function SetWrapper() {}
    SetWrapper.createFromList = function(lst) {
      return createSetFromList(lst);
    };
    SetWrapper.has = function(s, key) {
      return s.has(key);
    };
    SetWrapper.delete = function(m, k) {
      m.delete(k);
    };
    return SetWrapper;
  }());
  var _DOM = null;
  function getDOM() {
    return _DOM;
  }
  function setDOM(adapter) {
    _DOM = adapter;
  }
  function setRootDomAdapter(adapter) {
    if (isBlank(_DOM)) {
      _DOM = adapter;
    }
  }
  var DomAdapter = (function() {
    function DomAdapter() {
      this.xhrType = null;
    }
    DomAdapter.prototype.getXHR = function() {
      return this.xhrType;
    };
    Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
      get: function() {
        return this._attrToPropMap;
      },
      set: function(value) {
        this._attrToPropMap = value;
      },
      enumerable: true,
      configurable: true
    });
    ;
    ;
    return DomAdapter;
  }());
  var GenericBrowserDomAdapter = (function(_super) {
    __extends(GenericBrowserDomAdapter, _super);
    function GenericBrowserDomAdapter() {
      var _this = this;
      _super.call(this);
      this._animationPrefix = null;
      this._transitionEnd = null;
      try {
        var element = this.createElement('div', this.defaultDoc());
        if (isPresent(this.getStyle(element, 'animationName'))) {
          this._animationPrefix = '';
        } else {
          var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
          for (var i = 0; i < domPrefixes.length; i++) {
            if (isPresent(this.getStyle(element, domPrefixes[i] + 'AnimationName'))) {
              this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
              break;
            }
          }
        }
        var transEndEventNames = {
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          OTransition: 'oTransitionEnd otransitionend',
          transition: 'transitionend'
        };
        StringMapWrapper.forEach(transEndEventNames, function(value, key) {
          if (isPresent(_this.getStyle(element, key))) {
            _this._transitionEnd = value;
          }
        });
      } catch (e) {
        this._animationPrefix = null;
        this._transitionEnd = null;
      }
    }
    GenericBrowserDomAdapter.prototype.getDistributedNodes = function(el) {
      return el.getDistributedNodes();
    };
    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function(el, baseUrl, href) {
      el.href = href == null ? baseUrl : baseUrl + '/../' + href;
    };
    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function() {
      return true;
    };
    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function() {
      return isFunction(this.defaultDoc().body.createShadowRoot);
    };
    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function() {
      return isPresent(this._animationPrefix) ? this._animationPrefix : "";
    };
    GenericBrowserDomAdapter.prototype.getTransitionEnd = function() {
      return isPresent(this._transitionEnd) ? this._transitionEnd : "";
    };
    GenericBrowserDomAdapter.prototype.supportsAnimation = function() {
      return isPresent(this._animationPrefix) && isPresent(this._transitionEnd);
    };
    return GenericBrowserDomAdapter;
  }(DomAdapter));
  var _attrToPropMap = {
    'class': 'className',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex'
  };
  var DOM_KEY_LOCATION_NUMPAD = 3;
  var _keyMap = {
    '\b': 'Backspace',
    '\t': 'Tab',
    '\x7F': 'Delete',
    '\x1B': 'Escape',
    'Del': 'Delete',
    'Esc': 'Escape',
    'Left': 'ArrowLeft',
    'Right': 'ArrowRight',
    'Up': 'ArrowUp',
    'Down': 'ArrowDown',
    'Menu': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'Win': 'OS'
  };
  var _chromeNumKeyPadMap = {
    'A': '1',
    'B': '2',
    'C': '3',
    'D': '4',
    'E': '5',
    'F': '6',
    'G': '7',
    'H': '8',
    'I': '9',
    'J': '*',
    'K': '+',
    'M': '-',
    'N': '.',
    'O': '/',
    '\x60': '0',
    '\x90': 'NumLock'
  };
  var BrowserDomAdapter = (function(_super) {
    __extends(BrowserDomAdapter, _super);
    function BrowserDomAdapter() {
      _super.apply(this, arguments);
    }
    BrowserDomAdapter.prototype.parse = function(templateHtml) {
      throw new Error("parse not implemented");
    };
    BrowserDomAdapter.makeCurrent = function() {
      setRootDomAdapter(new BrowserDomAdapter());
    };
    BrowserDomAdapter.prototype.hasProperty = function(element, name) {
      return name in element;
    };
    BrowserDomAdapter.prototype.setProperty = function(el, name, value) {
      el[name] = value;
    };
    BrowserDomAdapter.prototype.getProperty = function(el, name) {
      return el[name];
    };
    BrowserDomAdapter.prototype.invoke = function(el, methodName, args) {
      el[methodName].apply(el, args);
    };
    BrowserDomAdapter.prototype.logError = function(error) {
      if (window.console.error) {
        window.console.error(error);
      } else {
        window.console.log(error);
      }
    };
    BrowserDomAdapter.prototype.log = function(error) {
      window.console.log(error);
    };
    BrowserDomAdapter.prototype.logGroup = function(error) {
      if (window.console.group) {
        window.console.group(error);
        this.logError(error);
      } else {
        window.console.log(error);
      }
    };
    BrowserDomAdapter.prototype.logGroupEnd = function() {
      if (window.console.groupEnd) {
        window.console.groupEnd();
      }
    };
    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
      get: function() {
        return _attrToPropMap;
      },
      enumerable: true,
      configurable: true
    });
    BrowserDomAdapter.prototype.query = function(selector) {
      return document.querySelector(selector);
    };
    BrowserDomAdapter.prototype.querySelector = function(el, selector) {
      return el.querySelector(selector);
    };
    BrowserDomAdapter.prototype.querySelectorAll = function(el, selector) {
      return el.querySelectorAll(selector);
    };
    BrowserDomAdapter.prototype.on = function(el, evt, listener) {
      el.addEventListener(evt, listener, false);
    };
    BrowserDomAdapter.prototype.onAndCancel = function(el, evt, listener) {
      el.addEventListener(evt, listener, false);
      return function() {
        el.removeEventListener(evt, listener, false);
      };
    };
    BrowserDomAdapter.prototype.dispatchEvent = function(el, evt) {
      el.dispatchEvent(evt);
    };
    BrowserDomAdapter.prototype.createMouseEvent = function(eventType) {
      var evt = document.createEvent('MouseEvent');
      evt.initEvent(eventType, true, true);
      return evt;
    };
    BrowserDomAdapter.prototype.createEvent = function(eventType) {
      var evt = document.createEvent('Event');
      evt.initEvent(eventType, true, true);
      return evt;
    };
    BrowserDomAdapter.prototype.preventDefault = function(evt) {
      evt.preventDefault();
      evt.returnValue = false;
    };
    BrowserDomAdapter.prototype.isPrevented = function(evt) {
      return evt.defaultPrevented || isPresent(evt.returnValue) && !evt.returnValue;
    };
    BrowserDomAdapter.prototype.getInnerHTML = function(el) {
      return el.innerHTML;
    };
    BrowserDomAdapter.prototype.getOuterHTML = function(el) {
      return el.outerHTML;
    };
    BrowserDomAdapter.prototype.nodeName = function(node) {
      return node.nodeName;
    };
    BrowserDomAdapter.prototype.nodeValue = function(node) {
      return node.nodeValue;
    };
    BrowserDomAdapter.prototype.type = function(node) {
      return node.type;
    };
    BrowserDomAdapter.prototype.content = function(node) {
      if (this.hasProperty(node, "content")) {
        return node.content;
      } else {
        return node;
      }
    };
    BrowserDomAdapter.prototype.firstChild = function(el) {
      return el.firstChild;
    };
    BrowserDomAdapter.prototype.nextSibling = function(el) {
      return el.nextSibling;
    };
    BrowserDomAdapter.prototype.parentElement = function(el) {
      return el.parentNode;
    };
    BrowserDomAdapter.prototype.childNodes = function(el) {
      return el.childNodes;
    };
    BrowserDomAdapter.prototype.childNodesAsList = function(el) {
      var childNodes = el.childNodes;
      var res = ListWrapper.createFixedSize(childNodes.length);
      for (var i = 0; i < childNodes.length; i++) {
        res[i] = childNodes[i];
      }
      return res;
    };
    BrowserDomAdapter.prototype.clearNodes = function(el) {
      while (el.firstChild) {
        el.removeChild(el.firstChild);
      }
    };
    BrowserDomAdapter.prototype.appendChild = function(el, node) {
      el.appendChild(node);
    };
    BrowserDomAdapter.prototype.removeChild = function(el, node) {
      el.removeChild(node);
    };
    BrowserDomAdapter.prototype.replaceChild = function(el, newChild, oldChild) {
      el.replaceChild(newChild, oldChild);
    };
    BrowserDomAdapter.prototype.remove = function(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
      return node;
    };
    BrowserDomAdapter.prototype.insertBefore = function(el, node) {
      el.parentNode.insertBefore(node, el);
    };
    BrowserDomAdapter.prototype.insertAllBefore = function(el, nodes) {
      nodes.forEach(function(n) {
        return el.parentNode.insertBefore(n, el);
      });
    };
    BrowserDomAdapter.prototype.insertAfter = function(el, node) {
      el.parentNode.insertBefore(node, el.nextSibling);
    };
    BrowserDomAdapter.prototype.setInnerHTML = function(el, value) {
      el.innerHTML = value;
    };
    BrowserDomAdapter.prototype.getText = function(el) {
      return el.textContent;
    };
    BrowserDomAdapter.prototype.setText = function(el, value) {
      el.textContent = value;
    };
    BrowserDomAdapter.prototype.getValue = function(el) {
      return el.value;
    };
    BrowserDomAdapter.prototype.setValue = function(el, value) {
      el.value = value;
    };
    BrowserDomAdapter.prototype.getChecked = function(el) {
      return el.checked;
    };
    BrowserDomAdapter.prototype.setChecked = function(el, value) {
      el.checked = value;
    };
    BrowserDomAdapter.prototype.createComment = function(text) {
      return document.createComment(text);
    };
    BrowserDomAdapter.prototype.createTemplate = function(html) {
      var t = document.createElement('template');
      t.innerHTML = html;
      return t;
    };
    BrowserDomAdapter.prototype.createElement = function(tagName, doc) {
      if (doc === void 0) {
        doc = document;
      }
      return doc.createElement(tagName);
    };
    BrowserDomAdapter.prototype.createElementNS = function(ns, tagName, doc) {
      if (doc === void 0) {
        doc = document;
      }
      return doc.createElementNS(ns, tagName);
    };
    BrowserDomAdapter.prototype.createTextNode = function(text, doc) {
      if (doc === void 0) {
        doc = document;
      }
      return doc.createTextNode(text);
    };
    BrowserDomAdapter.prototype.createScriptTag = function(attrName, attrValue, doc) {
      if (doc === void 0) {
        doc = document;
      }
      var el = doc.createElement('SCRIPT');
      el.setAttribute(attrName, attrValue);
      return el;
    };
    BrowserDomAdapter.prototype.createStyleElement = function(css, doc) {
      if (doc === void 0) {
        doc = document;
      }
      var style = doc.createElement('style');
      this.appendChild(style, this.createTextNode(css));
      return style;
    };
    BrowserDomAdapter.prototype.createShadowRoot = function(el) {
      return el.createShadowRoot();
    };
    BrowserDomAdapter.prototype.getShadowRoot = function(el) {
      return el.shadowRoot;
    };
    BrowserDomAdapter.prototype.getHost = function(el) {
      return el.host;
    };
    BrowserDomAdapter.prototype.clone = function(node) {
      return node.cloneNode(true);
    };
    BrowserDomAdapter.prototype.getElementsByClassName = function(element, name) {
      return element.getElementsByClassName(name);
    };
    BrowserDomAdapter.prototype.getElementsByTagName = function(element, name) {
      return element.getElementsByTagName(name);
    };
    BrowserDomAdapter.prototype.classList = function(element) {
      return Array.prototype.slice.call(element.classList, 0);
    };
    BrowserDomAdapter.prototype.addClass = function(element, className) {
      element.classList.add(className);
    };
    BrowserDomAdapter.prototype.removeClass = function(element, className) {
      element.classList.remove(className);
    };
    BrowserDomAdapter.prototype.hasClass = function(element, className) {
      return element.classList.contains(className);
    };
    BrowserDomAdapter.prototype.setStyle = function(element, styleName, styleValue) {
      element.style[styleName] = styleValue;
    };
    BrowserDomAdapter.prototype.removeStyle = function(element, stylename) {
      element.style[stylename] = null;
    };
    BrowserDomAdapter.prototype.getStyle = function(element, stylename) {
      return element.style[stylename];
    };
    BrowserDomAdapter.prototype.hasStyle = function(element, styleName, styleValue) {
      if (styleValue === void 0) {
        styleValue = null;
      }
      var value = this.getStyle(element, styleName) || '';
      return styleValue ? value == styleValue : value.length > 0;
    };
    BrowserDomAdapter.prototype.tagName = function(element) {
      return element.tagName;
    };
    BrowserDomAdapter.prototype.attributeMap = function(element) {
      var res = new Map();
      var elAttrs = element.attributes;
      for (var i = 0; i < elAttrs.length; i++) {
        var attrib = elAttrs[i];
        res.set(attrib.name, attrib.value);
      }
      return res;
    };
    BrowserDomAdapter.prototype.hasAttribute = function(element, attribute) {
      return element.hasAttribute(attribute);
    };
    BrowserDomAdapter.prototype.hasAttributeNS = function(element, ns, attribute) {
      return element.hasAttributeNS(ns, attribute);
    };
    BrowserDomAdapter.prototype.getAttribute = function(element, attribute) {
      return element.getAttribute(attribute);
    };
    BrowserDomAdapter.prototype.getAttributeNS = function(element, ns, name) {
      return element.getAttributeNS(ns, name);
    };
    BrowserDomAdapter.prototype.setAttribute = function(element, name, value) {
      element.setAttribute(name, value);
    };
    BrowserDomAdapter.prototype.setAttributeNS = function(element, ns, name, value) {
      element.setAttributeNS(ns, name, value);
    };
    BrowserDomAdapter.prototype.removeAttribute = function(element, attribute) {
      element.removeAttribute(attribute);
    };
    BrowserDomAdapter.prototype.removeAttributeNS = function(element, ns, name) {
      element.removeAttributeNS(ns, name);
    };
    BrowserDomAdapter.prototype.templateAwareRoot = function(el) {
      return this.isTemplateElement(el) ? this.content(el) : el;
    };
    BrowserDomAdapter.prototype.createHtmlDocument = function() {
      return document.implementation.createHTMLDocument('fakeTitle');
    };
    BrowserDomAdapter.prototype.defaultDoc = function() {
      return document;
    };
    BrowserDomAdapter.prototype.getBoundingClientRect = function(el) {
      try {
        return el.getBoundingClientRect();
      } catch (e) {
        return {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
    };
    BrowserDomAdapter.prototype.getTitle = function() {
      return document.title;
    };
    BrowserDomAdapter.prototype.setTitle = function(newTitle) {
      document.title = newTitle || '';
    };
    BrowserDomAdapter.prototype.elementMatches = function(n, selector) {
      var matches = false;
      if (n instanceof HTMLElement) {
        if (n.matches) {
          matches = n.matches(selector);
        } else if (n.msMatchesSelector) {
          matches = n.msMatchesSelector(selector);
        } else if (n.webkitMatchesSelector) {
          matches = n.webkitMatchesSelector(selector);
        }
      }
      return matches;
    };
    BrowserDomAdapter.prototype.isTemplateElement = function(el) {
      return el instanceof HTMLElement && el.nodeName == "TEMPLATE";
    };
    BrowserDomAdapter.prototype.isTextNode = function(node) {
      return node.nodeType === Node.TEXT_NODE;
    };
    BrowserDomAdapter.prototype.isCommentNode = function(node) {
      return node.nodeType === Node.COMMENT_NODE;
    };
    BrowserDomAdapter.prototype.isElementNode = function(node) {
      return node.nodeType === Node.ELEMENT_NODE;
    };
    BrowserDomAdapter.prototype.hasShadowRoot = function(node) {
      return node instanceof HTMLElement && isPresent(node.shadowRoot);
    };
    BrowserDomAdapter.prototype.isShadowRoot = function(node) {
      return node instanceof DocumentFragment;
    };
    BrowserDomAdapter.prototype.importIntoDoc = function(node) {
      var toImport = node;
      if (this.isTemplateElement(node)) {
        toImport = this.content(node);
      }
      return document.importNode(toImport, true);
    };
    BrowserDomAdapter.prototype.adoptNode = function(node) {
      return document.adoptNode(node);
    };
    BrowserDomAdapter.prototype.getHref = function(el) {
      return el.href;
    };
    BrowserDomAdapter.prototype.getEventKey = function(event) {
      var key = event.key;
      if (isBlank(key)) {
        key = event.keyIdentifier;
        if (isBlank(key)) {
          return 'Unidentified';
        }
        if (key.startsWith('U+')) {
          key = String.fromCharCode(parseInt(key.substring(2), 16));
          if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
            key = _chromeNumKeyPadMap[key];
          }
        }
      }
      if (_keyMap.hasOwnProperty(key)) {
        key = _keyMap[key];
      }
      return key;
    };
    BrowserDomAdapter.prototype.getGlobalEventTarget = function(target) {
      if (target == "window") {
        return window;
      } else if (target == "document") {
        return document;
      } else if (target == "body") {
        return document.body;
      }
    };
    BrowserDomAdapter.prototype.getHistory = function() {
      return window.history;
    };
    BrowserDomAdapter.prototype.getLocation = function() {
      return window.location;
    };
    BrowserDomAdapter.prototype.getBaseHref = function() {
      var href = getBaseElementHref();
      if (isBlank(href)) {
        return null;
      }
      return relativePath(href);
    };
    BrowserDomAdapter.prototype.resetBaseElement = function() {
      baseElement = null;
    };
    BrowserDomAdapter.prototype.getUserAgent = function() {
      return window.navigator.userAgent;
    };
    BrowserDomAdapter.prototype.setData = function(element, name, value) {
      this.setAttribute(element, 'data-' + name, value);
    };
    BrowserDomAdapter.prototype.getData = function(element, name) {
      return this.getAttribute(element, 'data-' + name);
    };
    BrowserDomAdapter.prototype.getComputedStyle = function(element) {
      return getComputedStyle(element);
    };
    BrowserDomAdapter.prototype.setGlobalVar = function(path, value) {
      setValueOnPath(global$1, path, value);
    };
    BrowserDomAdapter.prototype.requestAnimationFrame = function(callback) {
      return window.requestAnimationFrame(callback);
    };
    BrowserDomAdapter.prototype.cancelAnimationFrame = function(id) {
      window.cancelAnimationFrame(id);
    };
    BrowserDomAdapter.prototype.performanceNow = function() {
      if (isPresent(window.performance) && isPresent(window.performance.now)) {
        return window.performance.now();
      } else {
        return DateWrapper.toMillis(DateWrapper.now());
      }
    };
    return BrowserDomAdapter;
  }(GenericBrowserDomAdapter));
  var baseElement = null;
  function getBaseElementHref() {
    if (isBlank(baseElement)) {
      baseElement = document.querySelector('base');
      if (isBlank(baseElement)) {
        return null;
      }
    }
    return baseElement.getAttribute('href');
  }
  var urlParsingNode = null;
  function relativePath(url) {
    if (isBlank(urlParsingNode)) {
      urlParsingNode = document.createElement("a");
    }
    urlParsingNode.setAttribute('href', url);
    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname;
  }
  var PublicTestability = (function() {
    function PublicTestability(testability) {
      this._testability = testability;
    }
    PublicTestability.prototype.isStable = function() {
      return this._testability.isStable();
    };
    PublicTestability.prototype.whenStable = function(callback) {
      this._testability.whenStable(callback);
    };
    PublicTestability.prototype.findBindings = function(using, provider, exactMatch) {
      return this.findProviders(using, provider, exactMatch);
    };
    PublicTestability.prototype.findProviders = function(using, provider, exactMatch) {
      return this._testability.findBindings(using, provider, exactMatch);
    };
    return PublicTestability;
  }());
  var BrowserGetTestability = (function() {
    function BrowserGetTestability() {}
    BrowserGetTestability.init = function() {
      _angular_core.setTestabilityGetter(new BrowserGetTestability());
    };
    BrowserGetTestability.prototype.addToWindow = function(registry) {
      global$1.getAngularTestability = function(elem, findInAncestors) {
        if (findInAncestors === void 0) {
          findInAncestors = true;
        }
        var testability = registry.findTestabilityInTree(elem, findInAncestors);
        if (testability == null) {
          throw new Error('Could not find testability for element.');
        }
        return new PublicTestability(testability);
      };
      global$1.getAllAngularTestabilities = function() {
        var testabilities = registry.getAllTestabilities();
        return testabilities.map(function(testability) {
          return new PublicTestability(testability);
        });
      };
      global$1.getAllAngularRootElements = function() {
        return registry.getAllRootElements();
      };
      var whenAllStable = function(callback) {
        var testabilities = global$1.getAllAngularTestabilities();
        var count = testabilities.length;
        var didWork = false;
        var decrement = function(didWork_) {
          didWork = didWork || didWork_;
          count--;
          if (count == 0) {
            callback(didWork);
          }
        };
        testabilities.forEach(function(testability) {
          testability.whenStable(decrement);
        });
      };
      if (!global$1.frameworkStabilizers) {
        global$1.frameworkStabilizers = ListWrapper.createGrowableSize(0);
      }
      global$1.frameworkStabilizers.push(whenAllStable);
    };
    BrowserGetTestability.prototype.findTestabilityInTree = function(registry, elem, findInAncestors) {
      if (elem == null) {
        return null;
      }
      var t = registry.getTestability(elem);
      if (isPresent(t)) {
        return t;
      } else if (!findInAncestors) {
        return null;
      }
      if (getDOM().isShadowRoot(elem)) {
        return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
      }
      return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
    };
    return BrowserGetTestability;
  }());
  var DOCUMENT = new _angular_core.OpaqueToken('DocumentToken');
  var BaseException = (function(_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
      if (message === void 0) {
        message = "--";
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function() {
      return this.message;
    };
    return BaseException;
  }(Error));
  var EVENT_MANAGER_PLUGINS = new _angular_core.OpaqueToken("EventManagerPlugins");
  var EventManager = (function() {
    function EventManager(plugins, _zone) {
      var _this = this;
      this._zone = _zone;
      plugins.forEach(function(p) {
        return p.manager = _this;
      });
      this._plugins = ListWrapper.reversed(plugins);
    }
    EventManager.prototype.addEventListener = function(element, eventName, handler) {
      var plugin = this._findPluginFor(eventName);
      return plugin.addEventListener(element, eventName, handler);
    };
    EventManager.prototype.addGlobalEventListener = function(target, eventName, handler) {
      var plugin = this._findPluginFor(eventName);
      return plugin.addGlobalEventListener(target, eventName, handler);
    };
    EventManager.prototype.getZone = function() {
      return this._zone;
    };
    EventManager.prototype._findPluginFor = function(eventName) {
      var plugins = this._plugins;
      for (var i = 0; i < plugins.length; i++) {
        var plugin = plugins[i];
        if (plugin.supports(eventName)) {
          return plugin;
        }
      }
      throw new BaseException("No event manager plugin found for event " + eventName);
    };
    return EventManager;
  }());
  EventManager.decorators = [{type: _angular_core.Injectable}];
  EventManager.ctorParameters = [{
    type: undefined,
    decorators: [{
      type: _angular_core.Inject,
      args: [EVENT_MANAGER_PLUGINS]
    }]
  }, {type: _angular_core.NgZone}];
  var EventManagerPlugin = (function() {
    function EventManagerPlugin() {}
    EventManagerPlugin.prototype.supports = function(eventName) {
      return false;
    };
    EventManagerPlugin.prototype.addEventListener = function(element, eventName, handler) {
      throw "not implemented";
    };
    EventManagerPlugin.prototype.addGlobalEventListener = function(element, eventName, handler) {
      throw "not implemented";
    };
    return EventManagerPlugin;
  }());
  var CssAnimationOptions = (function() {
    function CssAnimationOptions() {
      this.classesToAdd = [];
      this.classesToRemove = [];
      this.animationClasses = [];
    }
    return CssAnimationOptions;
  }());
  var Math$1 = global$1.Math;
  var CAMEL_CASE_REGEXP = /([A-Z])/g;
  function camelCaseToDashCase(input) {
    return StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function(m) {
      return '-' + m[1].toLowerCase();
    });
  }
  var Animation = (function() {
    function Animation(element, data, browserDetails) {
      var _this = this;
      this.element = element;
      this.data = data;
      this.browserDetails = browserDetails;
      this.callbacks = [];
      this.eventClearFunctions = [];
      this.completed = false;
      this._stringPrefix = '';
      this.startTime = DateWrapper.toMillis(DateWrapper.now());
      this._stringPrefix = getDOM().getAnimationPrefix();
      this.setup();
      this.wait(function(timestamp) {
        return _this.start();
      });
    }
    Object.defineProperty(Animation.prototype, "totalTime", {
      get: function() {
        var delay = this.computedDelay != null ? this.computedDelay : 0;
        var duration = this.computedDuration != null ? this.computedDuration : 0;
        return delay + duration;
      },
      enumerable: true,
      configurable: true
    });
    Animation.prototype.wait = function(callback) {
      this.browserDetails.raf(callback, 2);
    };
    Animation.prototype.setup = function() {
      if (this.data.fromStyles != null)
        this.applyStyles(this.data.fromStyles);
      if (this.data.duration != null)
        this.applyStyles({'transitionDuration': this.data.duration.toString() + 'ms'});
      if (this.data.delay != null)
        this.applyStyles({'transitionDelay': this.data.delay.toString() + 'ms'});
    };
    Animation.prototype.start = function() {
      this.addClasses(this.data.classesToAdd);
      this.addClasses(this.data.animationClasses);
      this.removeClasses(this.data.classesToRemove);
      if (this.data.toStyles != null)
        this.applyStyles(this.data.toStyles);
      var computedStyles = getDOM().getComputedStyle(this.element);
      this.computedDelay = Math$1.max(this.parseDurationString(computedStyles.getPropertyValue(this._stringPrefix + 'transition-delay')), this.parseDurationString(this.element.style.getPropertyValue(this._stringPrefix + 'transition-delay')));
      this.computedDuration = Math$1.max(this.parseDurationString(computedStyles.getPropertyValue(this._stringPrefix + 'transition-duration')), this.parseDurationString(this.element.style.getPropertyValue(this._stringPrefix + 'transition-duration')));
      this.addEvents();
    };
    Animation.prototype.applyStyles = function(styles) {
      var _this = this;
      StringMapWrapper.forEach(styles, function(value, key) {
        var dashCaseKey = camelCaseToDashCase(key);
        if (isPresent(getDOM().getStyle(_this.element, dashCaseKey))) {
          getDOM().setStyle(_this.element, dashCaseKey, value.toString());
        } else {
          getDOM().setStyle(_this.element, _this._stringPrefix + dashCaseKey, value.toString());
        }
      });
    };
    Animation.prototype.addClasses = function(classes) {
      for (var i = 0,
          len = classes.length; i < len; i++)
        getDOM().addClass(this.element, classes[i]);
    };
    Animation.prototype.removeClasses = function(classes) {
      for (var i = 0,
          len = classes.length; i < len; i++)
        getDOM().removeClass(this.element, classes[i]);
    };
    Animation.prototype.addEvents = function() {
      var _this = this;
      if (this.totalTime > 0) {
        this.eventClearFunctions.push(getDOM().onAndCancel(this.element, getDOM().getTransitionEnd(), function(event) {
          return _this.handleAnimationEvent(event);
        }));
      } else {
        this.handleAnimationCompleted();
      }
    };
    Animation.prototype.handleAnimationEvent = function(event) {
      var elapsedTime = Math$1.round(event.elapsedTime * 1000);
      if (!this.browserDetails.elapsedTimeIncludesDelay)
        elapsedTime += this.computedDelay;
      event.stopPropagation();
      if (elapsedTime >= this.totalTime)
        this.handleAnimationCompleted();
    };
    Animation.prototype.handleAnimationCompleted = function() {
      this.removeClasses(this.data.animationClasses);
      this.callbacks.forEach(function(callback) {
        return callback();
      });
      this.callbacks = [];
      this.eventClearFunctions.forEach(function(fn) {
        return fn();
      });
      this.eventClearFunctions = [];
      this.completed = true;
    };
    Animation.prototype.onComplete = function(callback) {
      if (this.completed) {
        callback();
      } else {
        this.callbacks.push(callback);
      }
      return this;
    };
    Animation.prototype.parseDurationString = function(duration) {
      var maxValue = 0;
      if (duration == null || duration.length < 2) {
        return maxValue;
      } else if (duration.substring(duration.length - 2) == 'ms') {
        var value = NumberWrapper.parseInt(this.stripLetters(duration), 10);
        if (value > maxValue)
          maxValue = value;
      } else if (duration.substring(duration.length - 1) == 's') {
        var ms = NumberWrapper.parseFloat(this.stripLetters(duration)) * 1000;
        var value = Math$1.floor(ms);
        if (value > maxValue)
          maxValue = value;
      }
      return maxValue;
    };
    Animation.prototype.stripLetters = function(str) {
      return StringWrapper.replaceAll(str, RegExpWrapper.create('[^0-9]+$', ''), '');
    };
    return Animation;
  }());
  var CssAnimationBuilder = (function() {
    function CssAnimationBuilder(browserDetails) {
      this.browserDetails = browserDetails;
      this.data = new CssAnimationOptions();
    }
    CssAnimationBuilder.prototype.addAnimationClass = function(className) {
      this.data.animationClasses.push(className);
      return this;
    };
    CssAnimationBuilder.prototype.addClass = function(className) {
      this.data.classesToAdd.push(className);
      return this;
    };
    CssAnimationBuilder.prototype.removeClass = function(className) {
      this.data.classesToRemove.push(className);
      return this;
    };
    CssAnimationBuilder.prototype.setDuration = function(duration) {
      this.data.duration = duration;
      return this;
    };
    CssAnimationBuilder.prototype.setDelay = function(delay) {
      this.data.delay = delay;
      return this;
    };
    CssAnimationBuilder.prototype.setStyles = function(from, to) {
      return this.setFromStyles(from).setToStyles(to);
    };
    CssAnimationBuilder.prototype.setFromStyles = function(from) {
      this.data.fromStyles = from;
      return this;
    };
    CssAnimationBuilder.prototype.setToStyles = function(to) {
      this.data.toStyles = to;
      return this;
    };
    CssAnimationBuilder.prototype.start = function(element) {
      return new Animation(element, this.data, this.browserDetails);
    };
    return CssAnimationBuilder;
  }());
  var BrowserDetails = (function() {
    function BrowserDetails() {
      this.elapsedTimeIncludesDelay = false;
      this.doesElapsedTimeIncludesDelay();
    }
    BrowserDetails.prototype.doesElapsedTimeIncludesDelay = function() {
      var _this = this;
      var div = getDOM().createElement('div');
      getDOM().setAttribute(div, 'style', "position: absolute; top: -9999px; left: -9999px; width: 1px;\n      height: 1px; transition: all 1ms linear 1ms;");
      this.raf(function(timestamp) {
        getDOM().on(div, 'transitionend', function(event) {
          var elapsed = Math$1.round(event.elapsedTime * 1000);
          _this.elapsedTimeIncludesDelay = elapsed == 2;
          getDOM().remove(div);
        });
        getDOM().setStyle(div, 'width', '2px');
      }, 2);
    };
    BrowserDetails.prototype.raf = function(callback, frames) {
      if (frames === void 0) {
        frames = 1;
      }
      var queue = new RafQueue(callback, frames);
      return function() {
        return queue.cancel();
      };
    };
    return BrowserDetails;
  }());
  BrowserDetails.decorators = [{type: _angular_core.Injectable}];
  BrowserDetails.ctorParameters = [];
  var RafQueue = (function() {
    function RafQueue(callback, frames) {
      this.callback = callback;
      this.frames = frames;
      this._raf();
    }
    RafQueue.prototype._raf = function() {
      var _this = this;
      this.currentFrameId = getDOM().requestAnimationFrame(function(timestamp) {
        return _this._nextFrame(timestamp);
      });
    };
    RafQueue.prototype._nextFrame = function(timestamp) {
      this.frames--;
      if (this.frames > 0) {
        this._raf();
      } else {
        this.callback(timestamp);
      }
    };
    RafQueue.prototype.cancel = function() {
      getDOM().cancelAnimationFrame(this.currentFrameId);
      this.currentFrameId = null;
    };
    return RafQueue;
  }());
  var AnimationBuilder = (function() {
    function AnimationBuilder(browserDetails) {
      this.browserDetails = browserDetails;
    }
    AnimationBuilder.prototype.css = function() {
      return new CssAnimationBuilder(this.browserDetails);
    };
    return AnimationBuilder;
  }());
  AnimationBuilder.decorators = [{type: _angular_core.Injectable}];
  AnimationBuilder.ctorParameters = [{type: BrowserDetails}];
  var SharedStylesHost = (function() {
    function SharedStylesHost() {
      this._styles = [];
      this._stylesSet = new Set();
    }
    SharedStylesHost.prototype.addStyles = function(styles) {
      var _this = this;
      var additions = [];
      styles.forEach(function(style) {
        if (!SetWrapper.has(_this._stylesSet, style)) {
          _this._stylesSet.add(style);
          _this._styles.push(style);
          additions.push(style);
        }
      });
      this.onStylesAdded(additions);
    };
    SharedStylesHost.prototype.onStylesAdded = function(additions) {};
    SharedStylesHost.prototype.getAllStyles = function() {
      return this._styles;
    };
    return SharedStylesHost;
  }());
  SharedStylesHost.decorators = [{type: _angular_core.Injectable}];
  SharedStylesHost.ctorParameters = [];
  var DomSharedStylesHost = (function(_super) {
    __extends(DomSharedStylesHost, _super);
    function DomSharedStylesHost(doc) {
      _super.call(this);
      this._hostNodes = new Set();
      this._hostNodes.add(doc.head);
    }
    DomSharedStylesHost.prototype._addStylesToHost = function(styles, host) {
      for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        getDOM().appendChild(host, getDOM().createStyleElement(style));
      }
    };
    DomSharedStylesHost.prototype.addHost = function(hostNode) {
      this._addStylesToHost(this._styles, hostNode);
      this._hostNodes.add(hostNode);
    };
    DomSharedStylesHost.prototype.removeHost = function(hostNode) {
      SetWrapper.delete(this._hostNodes, hostNode);
    };
    DomSharedStylesHost.prototype.onStylesAdded = function(additions) {
      var _this = this;
      this._hostNodes.forEach(function(hostNode) {
        _this._addStylesToHost(additions, hostNode);
      });
    };
    return DomSharedStylesHost;
  }(SharedStylesHost));
  DomSharedStylesHost.decorators = [{type: _angular_core.Injectable}];
  DomSharedStylesHost.ctorParameters = [{
    type: undefined,
    decorators: [{
      type: _angular_core.Inject,
      args: [DOCUMENT]
    }]
  }];
  var NAMESPACE_URIS = {
    'xlink': 'http://www.w3.org/1999/xlink',
    'svg': 'http://www.w3.org/2000/svg'
  };
  var TEMPLATE_COMMENT_TEXT = 'template bindings={}';
  var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/g;
  var DomRootRenderer = (function() {
    function DomRootRenderer(document, eventManager, sharedStylesHost, animate) {
      this.document = document;
      this.eventManager = eventManager;
      this.sharedStylesHost = sharedStylesHost;
      this.animate = animate;
      this._registeredComponents = new Map();
    }
    DomRootRenderer.prototype.renderComponent = function(componentProto) {
      var renderer = this._registeredComponents.get(componentProto.id);
      if (isBlank(renderer)) {
        renderer = new DomRenderer(this, componentProto);
        this._registeredComponents.set(componentProto.id, renderer);
      }
      return renderer;
    };
    return DomRootRenderer;
  }());
  var DomRootRenderer_ = (function(_super) {
    __extends(DomRootRenderer_, _super);
    function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animate) {
      _super.call(this, _document, _eventManager, sharedStylesHost, animate);
    }
    return DomRootRenderer_;
  }(DomRootRenderer));
  DomRootRenderer_.decorators = [{type: _angular_core.Injectable}];
  DomRootRenderer_.ctorParameters = [{
    type: undefined,
    decorators: [{
      type: _angular_core.Inject,
      args: [DOCUMENT]
    }]
  }, {type: EventManager}, {type: DomSharedStylesHost}, {type: AnimationBuilder}];
  var DomRenderer = (function() {
    function DomRenderer(_rootRenderer, componentProto) {
      this._rootRenderer = _rootRenderer;
      this.componentProto = componentProto;
      this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);
      if (componentProto.encapsulation !== _angular_core.ViewEncapsulation.Native) {
        this._rootRenderer.sharedStylesHost.addStyles(this._styles);
      }
      if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Emulated) {
        this._contentAttr = _shimContentAttribute(componentProto.id);
        this._hostAttr = _shimHostAttribute(componentProto.id);
      } else {
        this._contentAttr = null;
        this._hostAttr = null;
      }
    }
    DomRenderer.prototype.selectRootElement = function(selectorOrNode, debugInfo) {
      var el;
      if (isString(selectorOrNode)) {
        el = getDOM().querySelector(this._rootRenderer.document, selectorOrNode);
        if (isBlank(el)) {
          throw new BaseException("The selector \"" + selectorOrNode + "\" did not match any elements");
        }
      } else {
        el = selectorOrNode;
      }
      getDOM().clearNodes(el);
      return el;
    };
    DomRenderer.prototype.createElement = function(parent, name, debugInfo) {
      var nsAndName = splitNamespace(name);
      var el = isPresent(nsAndName[0]) ? getDOM().createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) : getDOM().createElement(nsAndName[1]);
      if (isPresent(this._contentAttr)) {
        getDOM().setAttribute(el, this._contentAttr, '');
      }
      if (isPresent(parent)) {
        getDOM().appendChild(parent, el);
      }
      return el;
    };
    DomRenderer.prototype.createViewRoot = function(hostElement) {
      var nodesParent;
      if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native) {
        nodesParent = getDOM().createShadowRoot(hostElement);
        this._rootRenderer.sharedStylesHost.addHost(nodesParent);
        for (var i = 0; i < this._styles.length; i++) {
          getDOM().appendChild(nodesParent, getDOM().createStyleElement(this._styles[i]));
        }
      } else {
        if (isPresent(this._hostAttr)) {
          getDOM().setAttribute(hostElement, this._hostAttr, '');
        }
        nodesParent = hostElement;
      }
      return nodesParent;
    };
    DomRenderer.prototype.createTemplateAnchor = function(parentElement, debugInfo) {
      var comment = getDOM().createComment(TEMPLATE_COMMENT_TEXT);
      if (isPresent(parentElement)) {
        getDOM().appendChild(parentElement, comment);
      }
      return comment;
    };
    DomRenderer.prototype.createText = function(parentElement, value, debugInfo) {
      var node = getDOM().createTextNode(value);
      if (isPresent(parentElement)) {
        getDOM().appendChild(parentElement, node);
      }
      return node;
    };
    DomRenderer.prototype.projectNodes = function(parentElement, nodes) {
      if (isBlank(parentElement))
        return;
      appendNodes(parentElement, nodes);
    };
    DomRenderer.prototype.attachViewAfter = function(node, viewRootNodes) {
      moveNodesAfterSibling(node, viewRootNodes);
      for (var i = 0; i < viewRootNodes.length; i++)
        this.animateNodeEnter(viewRootNodes[i]);
    };
    DomRenderer.prototype.detachView = function(viewRootNodes) {
      for (var i = 0; i < viewRootNodes.length; i++) {
        var node = viewRootNodes[i];
        getDOM().remove(node);
        this.animateNodeLeave(node);
      }
    };
    DomRenderer.prototype.destroyView = function(hostElement, viewAllNodes) {
      if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native && isPresent(hostElement)) {
        this._rootRenderer.sharedStylesHost.removeHost(getDOM().getShadowRoot(hostElement));
      }
    };
    DomRenderer.prototype.listen = function(renderElement, name, callback) {
      return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));
    };
    DomRenderer.prototype.listenGlobal = function(target, name, callback) {
      return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));
    };
    DomRenderer.prototype.setElementProperty = function(renderElement, propertyName, propertyValue) {
      getDOM().setProperty(renderElement, propertyName, propertyValue);
    };
    DomRenderer.prototype.setElementAttribute = function(renderElement, attributeName, attributeValue) {
      var attrNs;
      var nsAndName = splitNamespace(attributeName);
      if (isPresent(nsAndName[0])) {
        attributeName = nsAndName[0] + ':' + nsAndName[1];
        attrNs = NAMESPACE_URIS[nsAndName[0]];
      }
      if (isPresent(attributeValue)) {
        if (isPresent(attrNs)) {
          getDOM().setAttributeNS(renderElement, attrNs, attributeName, attributeValue);
        } else {
          getDOM().setAttribute(renderElement, attributeName, attributeValue);
        }
      } else {
        if (isPresent(attrNs)) {
          getDOM().removeAttributeNS(renderElement, attrNs, nsAndName[1]);
        } else {
          getDOM().removeAttribute(renderElement, attributeName);
        }
      }
    };
    DomRenderer.prototype.setBindingDebugInfo = function(renderElement, propertyName, propertyValue) {
      var dashCasedPropertyName = camelCaseToDashCase(propertyName);
      if (getDOM().isCommentNode(renderElement)) {
        var existingBindings = RegExpWrapper.firstMatch(TEMPLATE_BINDINGS_EXP, StringWrapper.replaceAll(getDOM().getText(renderElement), /\n/g, ''));
        var parsedBindings = Json.parse(existingBindings[1]);
        parsedBindings[dashCasedPropertyName] = propertyValue;
        getDOM().setText(renderElement, StringWrapper.replace(TEMPLATE_COMMENT_TEXT, '{}', Json.stringify(parsedBindings)));
      } else {
        this.setElementAttribute(renderElement, propertyName, propertyValue);
      }
    };
    DomRenderer.prototype.setElementClass = function(renderElement, className, isAdd) {
      if (isAdd) {
        getDOM().addClass(renderElement, className);
      } else {
        getDOM().removeClass(renderElement, className);
      }
    };
    DomRenderer.prototype.setElementStyle = function(renderElement, styleName, styleValue) {
      if (isPresent(styleValue)) {
        getDOM().setStyle(renderElement, styleName, stringify(styleValue));
      } else {
        getDOM().removeStyle(renderElement, styleName);
      }
    };
    DomRenderer.prototype.invokeElementMethod = function(renderElement, methodName, args) {
      getDOM().invoke(renderElement, methodName, args);
    };
    DomRenderer.prototype.setText = function(renderNode, text) {
      getDOM().setText(renderNode, text);
    };
    DomRenderer.prototype.animateNodeEnter = function(node) {
      if (getDOM().isElementNode(node) && getDOM().hasClass(node, 'ng-animate')) {
        getDOM().addClass(node, 'ng-enter');
        this._rootRenderer.animate.css().addAnimationClass('ng-enter-active').start(node).onComplete(function() {
          getDOM().removeClass(node, 'ng-enter');
        });
      }
    };
    DomRenderer.prototype.animateNodeLeave = function(node) {
      if (getDOM().isElementNode(node) && getDOM().hasClass(node, 'ng-animate')) {
        getDOM().addClass(node, 'ng-leave');
        this._rootRenderer.animate.css().addAnimationClass('ng-leave-active').start(node).onComplete(function() {
          getDOM().removeClass(node, 'ng-leave');
          getDOM().remove(node);
        });
      } else {
        getDOM().remove(node);
      }
    };
    return DomRenderer;
  }());
  function moveNodesAfterSibling(sibling, nodes) {
    var parent = getDOM().parentElement(sibling);
    if (nodes.length > 0 && isPresent(parent)) {
      var nextSibling = getDOM().nextSibling(sibling);
      if (isPresent(nextSibling)) {
        for (var i = 0; i < nodes.length; i++) {
          getDOM().insertBefore(nextSibling, nodes[i]);
        }
      } else {
        for (var i = 0; i < nodes.length; i++) {
          getDOM().appendChild(parent, nodes[i]);
        }
      }
    }
  }
  function appendNodes(parent, nodes) {
    for (var i = 0; i < nodes.length; i++) {
      getDOM().appendChild(parent, nodes[i]);
    }
  }
  function decoratePreventDefault(eventHandler) {
    return function(event) {
      var allowDefaultBehavior = eventHandler(event);
      if (allowDefaultBehavior === false) {
        getDOM().preventDefault(event);
      }
    };
  }
  var COMPONENT_REGEX = /%COMP%/g;
  var COMPONENT_VARIABLE = '%COMP%';
  var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
  var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
  function _shimContentAttribute(componentShortId) {
    return StringWrapper.replaceAll(CONTENT_ATTR, COMPONENT_REGEX, componentShortId);
  }
  function _shimHostAttribute(componentShortId) {
    return StringWrapper.replaceAll(HOST_ATTR, COMPONENT_REGEX, componentShortId);
  }
  function _flattenStyles(compId, styles, target) {
    for (var i = 0; i < styles.length; i++) {
      var style = styles[i];
      if (isArray(style)) {
        _flattenStyles(compId, style, target);
      } else {
        style = StringWrapper.replaceAll(style, COMPONENT_REGEX, compId);
        target.push(style);
      }
    }
    return target;
  }
  var NS_PREFIX_RE = /^@([^:]+):(.+)/g;
  function splitNamespace(name) {
    if (name[0] != '@') {
      return [null, name];
    }
    var match = RegExpWrapper.firstMatch(NS_PREFIX_RE, name);
    return [match[1], match[2]];
  }
  var modifierKeys = ['alt', 'control', 'meta', 'shift'];
  var modifierKeyGetters = {
    'alt': function(event) {
      return event.altKey;
    },
    'control': function(event) {
      return event.ctrlKey;
    },
    'meta': function(event) {
      return event.metaKey;
    },
    'shift': function(event) {
      return event.shiftKey;
    }
  };
  var KeyEventsPlugin = (function(_super) {
    __extends(KeyEventsPlugin, _super);
    function KeyEventsPlugin() {
      _super.call(this);
    }
    KeyEventsPlugin.prototype.supports = function(eventName) {
      return isPresent(KeyEventsPlugin.parseEventName(eventName));
    };
    KeyEventsPlugin.prototype.addEventListener = function(element, eventName, handler) {
      var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
      var outsideHandler = KeyEventsPlugin.eventCallback(element, StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
      return this.manager.getZone().runOutsideAngular(function() {
        return getDOM().onAndCancel(element, StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
      });
    };
    KeyEventsPlugin.parseEventName = function(eventName) {
      var parts = eventName.toLowerCase().split('.');
      var domEventName = parts.shift();
      if ((parts.length === 0) || !(StringWrapper.equals(domEventName, 'keydown') || StringWrapper.equals(domEventName, 'keyup'))) {
        return null;
      }
      var key = KeyEventsPlugin._normalizeKey(parts.pop());
      var fullKey = '';
      modifierKeys.forEach(function(modifierName) {
        if (ListWrapper.contains(parts, modifierName)) {
          ListWrapper.remove(parts, modifierName);
          fullKey += modifierName + '.';
        }
      });
      fullKey += key;
      if (parts.length != 0 || key.length === 0) {
        return null;
      }
      var result = StringMapWrapper.create();
      StringMapWrapper.set(result, 'domEventName', domEventName);
      StringMapWrapper.set(result, 'fullKey', fullKey);
      return result;
    };
    KeyEventsPlugin.getEventFullKey = function(event) {
      var fullKey = '';
      var key = getDOM().getEventKey(event);
      key = key.toLowerCase();
      if (StringWrapper.equals(key, ' ')) {
        key = 'space';
      } else if (StringWrapper.equals(key, '.')) {
        key = 'dot';
      }
      modifierKeys.forEach(function(modifierName) {
        if (modifierName != key) {
          var modifierGetter = StringMapWrapper.get(modifierKeyGetters, modifierName);
          if (modifierGetter(event)) {
            fullKey += modifierName + '.';
          }
        }
      });
      fullKey += key;
      return fullKey;
    };
    KeyEventsPlugin.eventCallback = function(element, fullKey, handler, zone) {
      return function(event) {
        if (StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
          zone.runGuarded(function() {
            return handler(event);
          });
        }
      };
    };
    KeyEventsPlugin._normalizeKey = function(keyName) {
      switch (keyName) {
        case 'esc':
          return 'escape';
        default:
          return keyName;
      }
    };
    return KeyEventsPlugin;
  }(EventManagerPlugin));
  KeyEventsPlugin.decorators = [{type: _angular_core.Injectable}];
  KeyEventsPlugin.ctorParameters = [];
  var CORE_TOKENS = {
    'ApplicationRef': _angular_core.ApplicationRef,
    'NgZone': _angular_core.NgZone
  };
  var INSPECT_GLOBAL_NAME = 'ng.probe';
  var CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';
  function inspectNativeElement(element) {
    return _angular_core.getDebugNode(element);
  }
  function _createConditionalRootRenderer(rootRenderer) {
    if (assertionsEnabled()) {
      return _createRootRenderer(rootRenderer);
    }
    return rootRenderer;
  }
  function _createRootRenderer(rootRenderer) {
    getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
    getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, CORE_TOKENS);
    return new DebugDomRootRenderer(rootRenderer);
  }
  var ELEMENT_PROBE_PROVIDERS = [{
    provide: _angular_core.RootRenderer,
    useFactory: _createConditionalRootRenderer,
    deps: [DomRootRenderer]
  }];
  var DomEventsPlugin = (function(_super) {
    __extends(DomEventsPlugin, _super);
    function DomEventsPlugin() {
      _super.apply(this, arguments);
    }
    DomEventsPlugin.prototype.supports = function(eventName) {
      return true;
    };
    DomEventsPlugin.prototype.addEventListener = function(element, eventName, handler) {
      var zone = this.manager.getZone();
      var outsideHandler = function(event) {
        return zone.runGuarded(function() {
          return handler(event);
        });
      };
      return this.manager.getZone().runOutsideAngular(function() {
        return getDOM().onAndCancel(element, eventName, outsideHandler);
      });
    };
    DomEventsPlugin.prototype.addGlobalEventListener = function(target, eventName, handler) {
      var element = getDOM().getGlobalEventTarget(target);
      var zone = this.manager.getZone();
      var outsideHandler = function(event) {
        return zone.runGuarded(function() {
          return handler(event);
        });
      };
      return this.manager.getZone().runOutsideAngular(function() {
        return getDOM().onAndCancel(element, eventName, outsideHandler);
      });
    };
    return DomEventsPlugin;
  }(EventManagerPlugin));
  DomEventsPlugin.decorators = [{type: _angular_core.Injectable}];
  var _eventNames = {
    'pan': true,
    'panstart': true,
    'panmove': true,
    'panend': true,
    'pancancel': true,
    'panleft': true,
    'panright': true,
    'panup': true,
    'pandown': true,
    'pinch': true,
    'pinchstart': true,
    'pinchmove': true,
    'pinchend': true,
    'pinchcancel': true,
    'pinchin': true,
    'pinchout': true,
    'press': true,
    'pressup': true,
    'rotate': true,
    'rotatestart': true,
    'rotatemove': true,
    'rotateend': true,
    'rotatecancel': true,
    'swipe': true,
    'swipeleft': true,
    'swiperight': true,
    'swipeup': true,
    'swipedown': true,
    'tap': true
  };
  var HammerGesturesPluginCommon = (function(_super) {
    __extends(HammerGesturesPluginCommon, _super);
    function HammerGesturesPluginCommon() {
      _super.call(this);
    }
    HammerGesturesPluginCommon.prototype.supports = function(eventName) {
      eventName = eventName.toLowerCase();
      return StringMapWrapper.contains(_eventNames, eventName);
    };
    return HammerGesturesPluginCommon;
  }(EventManagerPlugin));
  var HAMMER_GESTURE_CONFIG = new _angular_core.OpaqueToken("HammerGestureConfig");
  var HammerGestureConfig = (function() {
    function HammerGestureConfig() {
      this.events = [];
      this.overrides = {};
    }
    HammerGestureConfig.prototype.buildHammer = function(element) {
      var mc = new Hammer(element);
      mc.get('pinch').set({enable: true});
      mc.get('rotate').set({enable: true});
      for (var eventName in this.overrides) {
        mc.get(eventName).set(this.overrides[eventName]);
      }
      return mc;
    };
    return HammerGestureConfig;
  }());
  HammerGestureConfig.decorators = [{type: _angular_core.Injectable}];
  var HammerGesturesPlugin = (function(_super) {
    __extends(HammerGesturesPlugin, _super);
    function HammerGesturesPlugin(_config) {
      _super.call(this);
      this._config = _config;
    }
    HammerGesturesPlugin.prototype.supports = function(eventName) {
      if (!_super.prototype.supports.call(this, eventName) && !this.isCustomEvent(eventName))
        return false;
      if (!isPresent(window['Hammer'])) {
        throw new BaseException("Hammer.js is not loaded, can not bind " + eventName + " event");
      }
      return true;
    };
    HammerGesturesPlugin.prototype.addEventListener = function(element, eventName, handler) {
      var _this = this;
      var zone = this.manager.getZone();
      eventName = eventName.toLowerCase();
      return zone.runOutsideAngular(function() {
        var mc = _this._config.buildHammer(element);
        var callback = function(eventObj) {
          zone.runGuarded(function() {
            handler(eventObj);
          });
        };
        mc.on(eventName, callback);
        return function() {
          mc.off(eventName, callback);
        };
      });
    };
    HammerGesturesPlugin.prototype.isCustomEvent = function(eventName) {
      return this._config.events.indexOf(eventName) > -1;
    };
    return HammerGesturesPlugin;
  }(HammerGesturesPluginCommon));
  HammerGesturesPlugin.decorators = [{type: _angular_core.Injectable}];
  HammerGesturesPlugin.ctorParameters = [{
    type: HammerGestureConfig,
    decorators: [{
      type: _angular_core.Inject,
      args: [HAMMER_GESTURE_CONFIG]
    }]
  }];
  var Title = (function() {
    function Title() {}
    Title.prototype.getTitle = function() {
      return getDOM().getTitle();
    };
    Title.prototype.setTitle = function(newTitle) {
      getDOM().setTitle(newTitle);
    };
    return Title;
  }());
  var win = typeof window !== 'undefined' && window || {};
  var ChangeDetectionPerfRecord = (function() {
    function ChangeDetectionPerfRecord(msPerTick, numTicks) {
      this.msPerTick = msPerTick;
      this.numTicks = numTicks;
    }
    return ChangeDetectionPerfRecord;
  }());
  var AngularTools = (function() {
    function AngularTools(ref) {
      this.profiler = new AngularProfiler(ref);
    }
    return AngularTools;
  }());
  var AngularProfiler = (function() {
    function AngularProfiler(ref) {
      this.appRef = ref.injector.get(_angular_core.ApplicationRef);
    }
    AngularProfiler.prototype.timeChangeDetection = function(config) {
      var record = isPresent(config) && config['record'];
      var profileName = 'Change Detection';
      var isProfilerAvailable = isPresent(win.console.profile);
      if (record && isProfilerAvailable) {
        win.console.profile(profileName);
      }
      var start = getDOM().performanceNow();
      var numTicks = 0;
      while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {
        this.appRef.tick();
        numTicks++;
      }
      var end = getDOM().performanceNow();
      if (record && isProfilerAvailable) {
        win.console.profileEnd(profileName);
      }
      var msPerTick = (end - start) / numTicks;
      win.console.log("ran " + numTicks + " change detection cycles");
      win.console.log(NumberWrapper.toFixed(msPerTick, 2) + " ms per check");
      return new ChangeDetectionPerfRecord(msPerTick, numTicks);
    };
    return AngularProfiler;
  }());
  var context = global$1;
  function enableDebugTools(ref) {
    context.ng = new AngularTools(ref);
  }
  function disableDebugTools() {
    delete context.ng;
  }
  var By = (function() {
    function By() {}
    By.all = function() {
      return function(debugElement) {
        return true;
      };
    };
    By.css = function(selector) {
      return function(debugElement) {
        return isPresent(debugElement.nativeElement) ? getDOM().elementMatches(debugElement.nativeElement, selector) : false;
      };
    };
    By.directive = function(type) {
      return function(debugElement) {
        return debugElement.providerTokens.indexOf(type) !== -1;
      };
    };
    return By;
  }());
  var BROWSER_PLATFORM_MARKER = new _angular_core.OpaqueToken('BrowserPlatformMarker');
  var BROWSER_PROVIDERS = [{
    provide: BROWSER_PLATFORM_MARKER,
    useValue: true
  }, _angular_core.PLATFORM_COMMON_PROVIDERS, {
    provide: _angular_core.PLATFORM_INITIALIZER,
    useValue: initDomAdapter,
    multi: true
  }];
  function _exceptionHandler() {
    return new _angular_core.ExceptionHandler(getDOM(), !IS_DART);
  }
  function _document() {
    return getDOM().defaultDoc();
  }
  var BROWSER_SANITIZATION_PROVIDERS = [{
    provide: SanitizationService,
    useExisting: DomSanitizationService
  }, {
    provide: DomSanitizationService,
    useClass: DomSanitizationServiceImpl
  }];
  var BROWSER_APP_COMMON_PROVIDERS = [_angular_core.APPLICATION_COMMON_PROVIDERS, _angular_common.FORM_PROVIDERS, BROWSER_SANITIZATION_PROVIDERS, {
    provide: _angular_core.PLATFORM_PIPES,
    useValue: _angular_common.COMMON_PIPES,
    multi: true
  }, {
    provide: _angular_core.PLATFORM_DIRECTIVES,
    useValue: _angular_common.COMMON_DIRECTIVES,
    multi: true
  }, {
    provide: _angular_core.ExceptionHandler,
    useFactory: _exceptionHandler,
    deps: []
  }, {
    provide: DOCUMENT,
    useFactory: _document,
    deps: []
  }, {
    provide: EVENT_MANAGER_PLUGINS,
    useClass: DomEventsPlugin,
    multi: true
  }, {
    provide: EVENT_MANAGER_PLUGINS,
    useClass: KeyEventsPlugin,
    multi: true
  }, {
    provide: EVENT_MANAGER_PLUGINS,
    useClass: HammerGesturesPlugin,
    multi: true
  }, {
    provide: HAMMER_GESTURE_CONFIG,
    useClass: HammerGestureConfig
  }, {
    provide: DomRootRenderer,
    useClass: DomRootRenderer_
  }, {
    provide: _angular_core.RootRenderer,
    useExisting: DomRootRenderer
  }, {
    provide: SharedStylesHost,
    useExisting: DomSharedStylesHost
  }, DomSharedStylesHost, _angular_core.Testability, BrowserDetails, AnimationBuilder, EventManager, ELEMENT_PROBE_PROVIDERS];
  function initDomAdapter() {
    BrowserDomAdapter.makeCurrent();
    wtfInit();
    BrowserGetTestability.init();
  }
  exports.__platform_browser_private__;
  (function(__platform_browser_private__) {
    __platform_browser_private__.DomAdapter = DomAdapter;
    function getDOM$$() {
      return getDOM();
    }
    __platform_browser_private__.getDOM = getDOM$$;
    function setDOM$$(adapter) {
      return setDOM(adapter);
    }
    __platform_browser_private__.setDOM = setDOM$$;
    __platform_browser_private__.setRootDomAdapter = setRootDomAdapter;
    __platform_browser_private__.BrowserDomAdapter = BrowserDomAdapter;
    __platform_browser_private__.AnimationBuilder = AnimationBuilder;
    __platform_browser_private__.CssAnimationBuilder = CssAnimationBuilder;
    __platform_browser_private__.CssAnimationOptions = CssAnimationOptions;
    __platform_browser_private__.Animation = Animation;
    __platform_browser_private__.BrowserDetails = BrowserDetails;
  })(exports.__platform_browser_private__ || (exports.__platform_browser_private__ = {}));
  var BrowserPlatformLocation = (function(_super) {
    __extends(BrowserPlatformLocation, _super);
    function BrowserPlatformLocation() {
      _super.call(this);
      this._init();
    }
    BrowserPlatformLocation.prototype._init = function() {
      this._location = getDOM().getLocation();
      this._history = getDOM().getHistory();
    };
    Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
      get: function() {
        return this._location;
      },
      enumerable: true,
      configurable: true
    });
    BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function() {
      return getDOM().getBaseHref();
    };
    BrowserPlatformLocation.prototype.onPopState = function(fn) {
      getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);
    };
    BrowserPlatformLocation.prototype.onHashChange = function(fn) {
      getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);
    };
    Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
      get: function() {
        return this._location.pathname;
      },
      set: function(newPath) {
        this._location.pathname = newPath;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
      get: function() {
        return this._location.search;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
      get: function() {
        return this._location.hash;
      },
      enumerable: true,
      configurable: true
    });
    BrowserPlatformLocation.prototype.pushState = function(state, title, url) {
      this._history.pushState(state, title, url);
    };
    BrowserPlatformLocation.prototype.replaceState = function(state, title, url) {
      this._history.replaceState(state, title, url);
    };
    BrowserPlatformLocation.prototype.forward = function() {
      this._history.forward();
    };
    BrowserPlatformLocation.prototype.back = function() {
      this._history.back();
    };
    return BrowserPlatformLocation;
  }(_angular_common.PlatformLocation));
  BrowserPlatformLocation.decorators = [{type: _angular_core.Injectable}];
  BrowserPlatformLocation.ctorParameters = [];
  var BROWSER_APP_STATIC_PROVIDERS = BROWSER_APP_COMMON_PROVIDERS;
  function browserStaticPlatform() {
    if (isBlank(_angular_core.getPlatform())) {
      _angular_core.createPlatform(_angular_core.ReflectiveInjector.resolveAndCreate(BROWSER_PROVIDERS));
    }
    return _angular_core.assertPlatform(BROWSER_PLATFORM_MARKER);
  }
  function bootstrapStatic(appComponentType, customProviders, initReflector) {
    if (isPresent(initReflector)) {
      initReflector();
    }
    var appProviders = isPresent(customProviders) ? [BROWSER_APP_STATIC_PROVIDERS, customProviders] : BROWSER_APP_STATIC_PROVIDERS;
    var appInjector = _angular_core.ReflectiveInjector.resolveAndCreate(appProviders, browserStaticPlatform().injector);
    return _angular_core.coreLoadAndBootstrap(appInjector, appComponentType);
  }
  function browserPlatform() {
    if (isBlank(_angular_core.getPlatform())) {
      _angular_core.createPlatform(_angular_core.ReflectiveInjector.resolveAndCreate(BROWSER_PROVIDERS));
    }
    return _angular_core.assertPlatform(BROWSER_PLATFORM_MARKER);
  }
  exports.browserPlatform = browserPlatform;
  exports.DomEventsPlugin = DomEventsPlugin;
  exports.EventManager = EventManager;
  exports.EVENT_MANAGER_PLUGINS = EVENT_MANAGER_PLUGINS;
  exports.ELEMENT_PROBE_PROVIDERS = ELEMENT_PROBE_PROVIDERS;
  exports.BROWSER_APP_COMMON_PROVIDERS = BROWSER_APP_COMMON_PROVIDERS;
  exports.BROWSER_SANITIZATION_PROVIDERS = BROWSER_SANITIZATION_PROVIDERS;
  exports.BROWSER_PROVIDERS = BROWSER_PROVIDERS;
  exports.By = By;
  exports.Title = Title;
  exports.enableDebugTools = enableDebugTools;
  exports.disableDebugTools = disableDebugTools;
  exports.HAMMER_GESTURE_CONFIG = HAMMER_GESTURE_CONFIG;
  exports.HammerGestureConfig = HammerGestureConfig;
  exports.DOCUMENT = DOCUMENT;
  exports.DomSanitizationService = DomSanitizationService;
  exports.SecurityContext = SecurityContext;
  exports.bootstrapStatic = bootstrapStatic;
  exports.browserStaticPlatform = browserStaticPlatform;
  exports.BROWSER_APP_STATIC_PROVIDERS = BROWSER_APP_STATIC_PROVIDERS;
  exports.BrowserPlatformLocation = BrowserPlatformLocation;
}));

})();
(function() {
var define = $__System.amdDefine;
var __extends = (this && this.__extends) || function(d, b) {
  for (var p in b)
    if (b.hasOwnProperty(p))
      d[p] = b[p];
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/compiler'), require('@angular/platform-browser'), require('@angular/core')) : typeof define === 'function' && define.amd ? define("a", ["exports", "2", "9", "3"], factory) : (factory((global.ng = global.ng || {}, global.ng.platformBrowserDynamic = global.ng.platformBrowserDynamic || {}), global.ng.compiler, global.ng.platformBrowser, global.ng.core));
}(this, function(exports, _angular_compiler, _angular_platformBrowser, _angular_core) {
  'use strict';
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  var global$1 = globalScope;
  global$1.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  function isArray(obj) {
    return Array.isArray(obj);
  }
  var Map$1 = global$1.Map;
  var Set = global$1.Set;
  var createMapFromPairs = (function() {
    try {
      if (new Map$1([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new Map$1(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new Map$1();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new Map$1(new Map$1())) {
        return function createMapFromMap(m) {
          return new Map$1(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new Map$1();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new Map$1()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new Map$1()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  function _flattenArray(source, target) {
    if (isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  var createSetFromList = (function() {
    var test = new Set([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new Set(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new Set(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var BaseException = (function(_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
      if (message === void 0) {
        message = "--";
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function() {
      return this.message;
    };
    return BaseException;
  }(Error));
  var PromiseCompleter = (function() {
    function PromiseCompleter() {
      var _this = this;
      this.promise = new Promise(function(res, rej) {
        _this.resolve = res;
        _this.reject = rej;
      });
    }
    return PromiseCompleter;
  }());
  var PromiseWrapper = (function() {
    function PromiseWrapper() {}
    PromiseWrapper.resolve = function(obj) {
      return Promise.resolve(obj);
    };
    PromiseWrapper.reject = function(obj, _) {
      return Promise.reject(obj);
    };
    PromiseWrapper.catchError = function(promise, onError) {
      return promise.catch(onError);
    };
    PromiseWrapper.all = function(promises) {
      if (promises.length == 0)
        return Promise.resolve([]);
      return Promise.all(promises);
    };
    PromiseWrapper.then = function(promise, success, rejection) {
      return promise.then(success, rejection);
    };
    PromiseWrapper.wrap = function(computation) {
      return new Promise(function(res, rej) {
        try {
          res(computation());
        } catch (e) {
          rej(e);
        }
      });
    };
    PromiseWrapper.scheduleMicrotask = function(computation) {
      PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function(_) {});
    };
    PromiseWrapper.isPromise = function(obj) {
      return obj instanceof Promise;
    };
    PromiseWrapper.completer = function() {
      return new PromiseCompleter();
    };
    return PromiseWrapper;
  }());
  var CachedXHR = (function(_super) {
    __extends(CachedXHR, _super);
    function CachedXHR() {
      _super.call(this);
      this._cache = global$1.$templateCache;
      if (this._cache == null) {
        throw new BaseException('CachedXHR: Template cache was not found in $templateCache.');
      }
    }
    CachedXHR.prototype.get = function(url) {
      if (this._cache.hasOwnProperty(url)) {
        return PromiseWrapper.resolve(this._cache[url]);
      } else {
        return PromiseWrapper.reject('CachedXHR: Did not find cached template for ' + url, null);
      }
    };
    return CachedXHR;
  }(_angular_compiler.XHR));
  var XHRImpl = (function(_super) {
    __extends(XHRImpl, _super);
    function XHRImpl() {
      _super.apply(this, arguments);
    }
    XHRImpl.prototype.get = function(url) {
      var completer = PromiseWrapper.completer();
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.responseType = 'text';
      xhr.onload = function() {
        var response = isPresent(xhr.response) ? xhr.response : xhr.responseText;
        var status = xhr.status === 1223 ? 204 : xhr.status;
        if (status === 0) {
          status = response ? 200 : 0;
        }
        if (200 <= status && status <= 300) {
          completer.resolve(response);
        } else {
          completer.reject("Failed to load " + url, null);
        }
      };
      xhr.onerror = function() {
        completer.reject("Failed to load " + url, null);
      };
      xhr.send();
      return completer.promise;
    };
    return XHRImpl;
  }(_angular_compiler.XHR));
  var ReflectionCapabilities = _angular_core.__core_private__.ReflectionCapabilities;
  var CACHED_TEMPLATE_PROVIDER = [{
    provide: _angular_compiler.XHR,
    useClass: CachedXHR
  }];
  var BROWSER_APP_DYNAMIC_PROVIDERS = [_angular_platformBrowser.BROWSER_APP_COMMON_PROVIDERS, _angular_compiler.COMPILER_PROVIDERS, {
    provide: _angular_compiler.XHR,
    useClass: XHRImpl
  }];
  function bootstrap(appComponentType, customProviders) {
    _angular_core.reflector.reflectionCapabilities = new ReflectionCapabilities();
    var appInjector = _angular_core.ReflectiveInjector.resolveAndCreate([BROWSER_APP_DYNAMIC_PROVIDERS, isPresent(customProviders) ? customProviders : []], _angular_platformBrowser.browserPlatform().injector);
    return _angular_core.coreLoadAndBootstrap(appInjector, appComponentType);
  }
  exports.CACHED_TEMPLATE_PROVIDER = CACHED_TEMPLATE_PROVIDER;
  exports.BROWSER_APP_DYNAMIC_PROVIDERS = BROWSER_APP_DYNAMIC_PROVIDERS;
  exports.bootstrap = bootstrap;
}));

})();
$__System.registerDynamic("b", ["c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var Subscriber_1 = $__require('c');
  function map(project, thisArg) {
    if (typeof project !== 'function') {
      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
  }
  exports.map = map;
  var MapOperator = (function() {
    function MapOperator(project, thisArg) {
      this.project = project;
      this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function(subscriber, source) {
      return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
  }());
  var MapSubscriber = (function(_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
      _super.call(this, destination);
      this.project = project;
      this.count = 0;
      this.thisArg = thisArg || this;
    }
    MapSubscriber.prototype._next = function(value) {
      var result;
      try {
        result = this.project.call(this.thisArg, value, this.count++);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(result);
    };
    return MapSubscriber;
  }(Subscriber_1.Subscriber));
  return module.exports;
});

$__System.registerDynamic("d", ["7", "b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Observable_1 = $__require('7');
  var map_1 = $__require('b');
  Observable_1.Observable.prototype.map = map_1.map;
  return module.exports;
});

$__System.registerDynamic("e", ["3", "f", "d"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var core_1 = $__require('3');
  var http_1 = $__require('f');
  $__require('d');
  var LoadDataService = (function() {
    function LoadDataService(_http) {
      this._http = _http;
    }
    LoadDataService.prototype.loadAll = function() {
      return this._http.get('/hydraneData').map(function(res) {
        return res.json();
      });
    };
    LoadDataService = __decorate([core_1.Injectable(), __metadata('design:paramtypes', [http_1.Http])], LoadDataService);
    return LoadDataService;
  }());
  exports.LoadDataService = LoadDataService;
  return module.exports;
});

$__System.registerDynamic("10", ["3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var core_1 = $__require('3');
  var SearchComponent = (function() {
    function SearchComponent() {
      this.childChanged = new core_1.EventEmitter();
    }
    SearchComponent.prototype.codeChange = function(value) {
      this.childChanged.emit({continent: value});
    };
    SearchComponent.prototype.typeChange = function(value) {
      this.childChanged.emit({type: value});
    };
    SearchComponent.prototype.numChange = function(value) {
      this.childChanged.emit({num: value});
    };
    SearchComponent = __decorate([core_1.Component({
      selector: 'my-search',
      template: "\n    <div class='filter'>\n      <div class='inputGroup'>\n        <label>Continent</label>\n        <select (change)=\"codeChange($event.target.value)\">\n          <option value=\"ALL\">ALL</option>\n          <option *ngFor=\"#continent of continents\" value={{continent}}>{{continent}}</option>\n        </select>\n      </div>\n      <div class='inputGroup'>\n        <label>AreaInSqKm/Population</label>\n        <select (change)=\"typeChange($event.target.value)\">\n          <option value=\"ALL\">ALL</option>\n          <option value=\"areaInSqKm\">areaInSqKm</option>\n          <option value=\"population\">population</option>\n        </select>\n      </div>\n      <div class='inputGroup'>\n        <label>Pie Result</label>\n        <select (change)=\"numChange($event.target.value)\">\n          <option value=\"5\">5</option>\n          <option value=\"10\">10</option>\n          <option value=\"15\">15</option>\n          <option value=\"20\">20</option>\n        </select>\n      </div>\n    </div>\n    ",
      inputs: ['continents'],
      outputs: ['childChanged']
    }), __metadata('design:paramtypes', [])], SearchComponent);
    return SearchComponent;
  }());
  exports.SearchComponent = SearchComponent;
  return module.exports;
});

$__System.registerDynamic("11", ["3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var core_1 = $__require('3');
  var FilterPipe = (function() {
    function FilterPipe() {}
    FilterPipe.prototype.transform = function(pipeData, pipeModifier) {
      if (!pipeModifier || pipeModifier == 'ALL') {
        return pipeData;
      }
      return pipeData.filter(function(item) {
        var filtered = false;
        Object.keys(item).map(function(key) {
          item[key] == pipeModifier ? filtered = true : filtered;
        });
        return filtered;
      });
    };
    FilterPipe = __decorate([core_1.Pipe({name: 'search'}), __metadata('design:paramtypes', [])], FilterPipe);
    return FilterPipe;
  }());
  exports.FilterPipe = FilterPipe;
  return module.exports;
});

$__System.registerDynamic("12", ["3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var core_1 = $__require('3');
  var SortPipe = (function() {
    function SortPipe() {}
    SortPipe.prototype.transform = function(pipeData, pipeModifier) {
      if (!pipeModifier) {
        return pipeData;
      }
      return pipeData.sort(function(a, b) {
        return Number(a[pipeModifier]) - Number(b[pipeModifier]);
      });
    };
    SortPipe = __decorate([core_1.Pipe({name: 'sortBy'}), __metadata('design:paramtypes', [])], SortPipe);
    return SortPipe;
  }());
  exports.SortPipe = SortPipe;
  return module.exports;
});

$__System.registerDynamic("13", ["14", "3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var Highcharts_1 = $__require('14');
  var core_1 = $__require('3');
  var HighchartsService = (function() {
    function HighchartsService() {
      this.Highcharts = Highcharts_1.Highcharts;
    }
    HighchartsService = __decorate([core_1.Injectable(), __metadata('design:paramtypes', [])], HighchartsService);
    return HighchartsService;
  }());
  exports.HighchartsService = HighchartsService;
  return module.exports;
});

$__System.registerDynamic("15", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObj = function(x) {
    var type = typeof x;
    return x !== null && (type === 'object' || type === 'function');
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Sources cannot be null or undefined');
    }
    return Object(val);
  }
  function assignKey(to, from, key) {
    var val = from[key];
    if (val === undefined || val === null) {
      return;
    }
    if (hasOwnProperty.call(to, key)) {
      if (to[key] === undefined || to[key] === null) {
        throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
      }
    }
    if (!hasOwnProperty.call(to, key) || !isObj(val)) {
      to[key] = val;
    } else {
      to[key] = assign(Object(to[key]), from[key]);
    }
  }
  function assign(to, from) {
    if (to === from) {
      return to;
    }
    from = Object(from);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        assignKey(to, from, key);
      }
    }
    return to;
  }
  function deepAssign(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    target = toObject(target);
    for (var s = 0; s < args.length; s++) {
      assign(target, args[s]);
    }
    return target;
  }
  exports.deepAssign = deepAssign;
  return module.exports;
});

$__System.registerDynamic("16", ["15"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var deepAssign_1 = $__require('15');
  function initChart(highchartsService, userOpts, baseOpts, type) {
    if (!highchartsService.Highcharts[type]) {
      throw new Error(type + " is unknown chart type.");
    }
    var opts = deepAssign_1.deepAssign({}, baseOpts, userOpts);
    return new highchartsService.Highcharts[type](opts);
  }
  exports.initChart = initChart;
  return module.exports;
});

$__System.registerDynamic("17", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ChartEvent = (function() {
    function ChartEvent(event, context) {
      this.originalEvent = event;
      this.context = context;
    }
    return ChartEvent;
  }());
  exports.ChartEvent = ChartEvent;
  return module.exports;
});

$__System.registerDynamic("18", ["17"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ChartEvent_1 = $__require('17');
  var chartEvents = ['addSeries', 'afterPrint', 'beforePrint', 'drilldown', 'drillup', 'load', 'redraw', 'selection'];
  var seriesEvents = ['click', 'afterAnimate', 'checkboxClick', 'hide', 'legendItemClick', 'mouseOut', 'mouseOver', 'show'];
  var pointEvents = ['click', 'remove', 'select', 'unselect', 'mouseOut', 'mouseOver', 'update'];
  function createBaseOpts(chartCmp, seriesCmp, pointCmp, element) {
    var opts = {
      chart: {
        renderTo: element,
        events: {}
      },
      plotOptions: {series: {
          events: {},
          point: {events: {}}
        }}
    };
    chartEvents.forEach(function(eventName) {
      opts.chart.events[eventName] = opts.chart.events[eventName] || function(event) {
        chartCmp[eventName].emit(new ChartEvent_1.ChartEvent(event, this));
      };
    });
    if (seriesCmp) {
      seriesEvents.forEach(function(eventName) {
        opts.plotOptions.series.events[eventName] = opts.plotOptions.series.events[eventName] || function(event) {
          seriesCmp[eventName].emit(new ChartEvent_1.ChartEvent(event, this));
        };
      });
    }
    if (pointCmp) {
      pointEvents.forEach(function(eventName) {
        opts.plotOptions.series.point.events[eventName] = opts.plotOptions.series.point.events[eventName] || function(event) {
          pointCmp[eventName].emit(new ChartEvent_1.ChartEvent(event, this));
        };
      });
    }
    return opts;
  }
  exports.createBaseOpts = createBaseOpts;
  return module.exports;
});

$__System.registerDynamic("19", ["3", "1a", "13", "16", "18"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var core_1 = $__require('3');
  var ChartSeriesComponent_1 = $__require('1a');
  var HighchartsService_1 = $__require('13');
  var initChart_1 = $__require('16');
  var createBaseOpts_1 = $__require('18');
  var ChartComponent = (function() {
    function ChartComponent(element, highchartsService) {
      this.create = new core_1.EventEmitter();
      this.click = new core_1.EventEmitter();
      this.addSeries = new core_1.EventEmitter();
      this.afterPrint = new core_1.EventEmitter();
      this.beforePrint = new core_1.EventEmitter();
      this.drilldown = new core_1.EventEmitter();
      this.drillup = new core_1.EventEmitter();
      this.load = new core_1.EventEmitter();
      this.redraw = new core_1.EventEmitter();
      this.selection = new core_1.EventEmitter();
      this.type = 'Chart';
      this.element = element;
      this.highchartsService = highchartsService;
    }
    Object.defineProperty(ChartComponent.prototype, "options", {
      set: function(opts) {
        this.userOpts = opts;
        this.init();
      },
      enumerable: true,
      configurable: true
    });
    ;
    ChartComponent.prototype.init = function() {
      if (this.userOpts && this.baseOpts) {
        this.chart = initChart_1.initChart(this.highchartsService, this.userOpts, this.baseOpts, this.type);
        this.create.emit(this.chart);
      }
    };
    ChartComponent.prototype.ngAfterViewInit = function() {
      this.baseOpts = createBaseOpts_1.createBaseOpts(this, this.series, this.series ? this.series.point : null, this.element.nativeElement);
      this.init();
    };
    __decorate([core_1.ContentChild(ChartSeriesComponent_1.ChartSeriesComponent), __metadata('design:type', ChartSeriesComponent_1.ChartSeriesComponent)], ChartComponent.prototype, "series", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartComponent.prototype, "create", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartComponent.prototype, "click", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartComponent.prototype, "addSeries", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartComponent.prototype, "afterPrint", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartComponent.prototype, "beforePrint", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartComponent.prototype, "drilldown", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartComponent.prototype, "drillup", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartComponent.prototype, "load", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartComponent.prototype, "redraw", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartComponent.prototype, "selection", void 0);
    __decorate([core_1.Input(), __metadata('design:type', String)], ChartComponent.prototype, "type", void 0);
    __decorate([core_1.Input(), __metadata('design:type', Object), __metadata('design:paramtypes', [Object])], ChartComponent.prototype, "options", null);
    ChartComponent = __decorate([core_1.Component({
      selector: 'chart',
      template: '',
      providers: [HighchartsService_1.HighchartsService]
    }), __metadata('design:paramtypes', [core_1.ElementRef, HighchartsService_1.HighchartsService])], ChartComponent);
    return ChartComponent;
  }());
  exports.ChartComponent = ChartComponent;
  return module.exports;
});

$__System.registerDynamic("1a", ["3", "1b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var core_1 = $__require('3');
  var ChartPointComponent_1 = $__require('1b');
  var ChartSeriesComponent = (function() {
    function ChartSeriesComponent() {
      this.click = new core_1.EventEmitter();
      this.afterAnimate = new core_1.EventEmitter();
      this.checkboxClick = new core_1.EventEmitter();
      this.hide = new core_1.EventEmitter();
      this.legendItemClick = new core_1.EventEmitter();
      this.mouseOver = new core_1.EventEmitter();
      this.mouseOut = new core_1.EventEmitter();
      this.show = new core_1.EventEmitter();
    }
    __decorate([core_1.ContentChild(ChartPointComponent_1.ChartPointComponent), __metadata('design:type', ChartPointComponent_1.ChartPointComponent)], ChartSeriesComponent.prototype, "point", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartSeriesComponent.prototype, "click", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartSeriesComponent.prototype, "afterAnimate", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartSeriesComponent.prototype, "checkboxClick", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartSeriesComponent.prototype, "hide", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartSeriesComponent.prototype, "legendItemClick", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartSeriesComponent.prototype, "mouseOver", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartSeriesComponent.prototype, "mouseOut", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartSeriesComponent.prototype, "show", void 0);
    ChartSeriesComponent = __decorate([core_1.Directive({selector: 'series'}), __metadata('design:paramtypes', [])], ChartSeriesComponent);
    return ChartSeriesComponent;
  }());
  exports.ChartSeriesComponent = ChartSeriesComponent;
  return module.exports;
});

$__System.registerDynamic("1b", ["3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var core_1 = $__require('3');
  var ChartPointComponent = (function() {
    function ChartPointComponent() {
      this.click = new core_1.EventEmitter();
      this.remove = new core_1.EventEmitter();
      this.select = new core_1.EventEmitter();
      this.unselect = new core_1.EventEmitter();
      this.mouseOver = new core_1.EventEmitter();
      this.mouseOut = new core_1.EventEmitter();
      this.update = new core_1.EventEmitter();
    }
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartPointComponent.prototype, "click", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartPointComponent.prototype, "remove", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartPointComponent.prototype, "select", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartPointComponent.prototype, "unselect", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartPointComponent.prototype, "mouseOver", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartPointComponent.prototype, "mouseOut", void 0);
    __decorate([core_1.Output(), __metadata('design:type', Object)], ChartPointComponent.prototype, "update", void 0);
    ChartPointComponent = __decorate([core_1.Directive({selector: 'point'}), __metadata('design:paramtypes', [])], ChartPointComponent);
    return ChartPointComponent;
  }());
  exports.ChartPointComponent = ChartPointComponent;
  return module.exports;
});

$__System.registerDynamic("1c", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(D, aa) {
    typeof module === "object" && module.exports ? module.exports = D.document ? aa(D) : aa : D.Highcharts = aa(D);
  })(typeof window !== "undefined" ? window : this, function(D) {
    function aa(a, b) {
      var c = "Highcharts error #" + a + ": www.highcharts.com/errors/" + a;
      if (b)
        throw Error(c);
      D.console && console.log(c);
    }
    function pb(a, b, c) {
      this.options = b;
      this.elem = a;
      this.prop = c;
    }
    function E() {
      var a,
          b = arguments,
          c,
          d = {},
          e = function(a, b) {
            var c,
                d;
            typeof a !== "object" && (a = {});
            for (d in b)
              b.hasOwnProperty(d) && (c = b[d], a[d] = c && typeof c === "object" && Object.prototype.toString.call(c) !== "[object Array]" && d !== "renderTo" && typeof c.nodeType !== "number" ? e(a[d] || {}, c) : b[d]);
            return a;
          };
      b[0] === !0 && (d = b[1], b = Array.prototype.slice.call(b, 2));
      c = b.length;
      for (a = 0; a < c; a++)
        d = e(d, b[a]);
      return d;
    }
    function C(a, b) {
      return parseInt(a, b || 10);
    }
    function xa(a) {
      return typeof a === "string";
    }
    function Z(a) {
      return a && typeof a === "object";
    }
    function Ea(a) {
      return Object.prototype.toString.call(a) === "[object Array]";
    }
    function pa(a, b) {
      for (var c = a.length; c--; )
        if (a[c] === b) {
          a.splice(c, 1);
          break;
        }
    }
    function r(a) {
      return a !== y && a !== null;
    }
    function P(a, b, c) {
      var d,
          e;
      if (xa(b))
        r(c) ? a.setAttribute(b, c) : a && a.getAttribute && (e = a.getAttribute(b));
      else if (r(b) && Z(b))
        for (d in b)
          a.setAttribute(d, b[d]);
      return e;
    }
    function ta(a) {
      return Ea(a) ? a : [a];
    }
    function Pa(a, b, c) {
      if (b)
        return setTimeout(a, b, c);
      a.call(0, c);
    }
    function M(a, b) {
      if (ya && !fa && b && b.opacity !== y)
        b.filter = "alpha(opacity=" + b.opacity * 100 + ")";
      u(a.style, b);
    }
    function ba(a, b, c, d, e) {
      a = A.createElement(a);
      b && u(a, b);
      e && M(a, {
        padding: 0,
        border: "none",
        margin: 0
      });
      c && M(a, c);
      d && d.appendChild(a);
      return a;
    }
    function qa(a, b) {
      var c = function() {};
      c.prototype = new a;
      u(c.prototype, b);
      return c;
    }
    function Fa(a, b, c) {
      return Array((b || 2) + 1 - String(a).length).join(c || 0) + a;
    }
    function Ya(a) {
      return (Za && Za(a) || qb || 0) * 6E4;
    }
    function Ka(a, b) {
      for (var c = "{",
          d = !1,
          e,
          f,
          g,
          h,
          i,
          k = []; (c = a.indexOf(c)) !== -1; ) {
        e = a.slice(0, c);
        if (d) {
          f = e.split(":");
          g = f.shift().split(".");
          i = g.length;
          e = b;
          for (h = 0; h < i; h++)
            e = e[g[h]];
          if (f.length)
            f = f.join(":"), g = /\.([0-9])/, h = U.lang, i = void 0, /f$/.test(f) ? (i = (i = f.match(g)) ? i[1] : -1, e !== null && (e = x.numberFormat(e, i, h.decimalPoint, f.indexOf(",") > -1 ? h.thousandsSep : ""))) : e = Qa(f, e);
        }
        k.push(e);
        a = a.slice(c + 1);
        c = (d = !d) ? "}" : "{";
      }
      k.push(a);
      return k.join("");
    }
    function rb(a) {
      return Y.pow(10, V(Y.log(a) / Y.LN10));
    }
    function sb(a, b, c, d, e) {
      var f,
          g = a,
          c = o(c, 1);
      f = a / c;
      b || (b = [1, 2, 2.5, 5, 10], d === !1 && (c === 1 ? b = [1, 2, 5, 10] : c <= 0.1 && (b = [1 / c])));
      for (d = 0; d < b.length; d++)
        if (g = b[d], e && g * c >= a || !e && f <= (b[d] + (b[d + 1] || b[d])) / 2)
          break;
      g *= c;
      return g;
    }
    function hb(a, b) {
      var c = a.length,
          d,
          e;
      for (e = 0; e < c; e++)
        a[e].safeI = e;
      a.sort(function(a, c) {
        d = b(a, c);
        return d === 0 ? a.safeI - c.safeI : d;
      });
      for (e = 0; e < c; e++)
        delete a[e].safeI;
    }
    function La(a) {
      for (var b = a.length,
          c = a[0]; b--; )
        a[b] < c && (c = a[b]);
      return c;
    }
    function Ga(a) {
      for (var b = a.length,
          c = a[0]; b--; )
        a[b] > c && (c = a[b]);
      return c;
    }
    function Ra(a, b) {
      for (var c in a)
        a[c] && a[c] !== b && a[c].destroy && a[c].destroy(), delete a[c];
    }
    function Sa(a) {
      ib || (ib = ba(Ma));
      a && ib.appendChild(a);
      ib.innerHTML = "";
    }
    function ca(a, b) {
      return parseFloat(a.toPrecision(b || 14));
    }
    function Ta(a, b) {
      b.renderer.globalAnimation = o(a, b.animation);
    }
    function $a(a) {
      return Z(a) ? E(a) : {duration: a ? 500 : 0};
    }
    function Eb() {
      var a = U.global,
          b = a.useUTC,
          c = b ? "getUTC" : "get",
          d = b ? "setUTC" : "set";
      la = a.Date || D.Date;
      qb = b && a.timezoneOffset;
      Za = b && a.getTimezoneOffset;
      jb = function(a, c, d, h, i, k) {
        var j;
        b ? (j = la.UTC.apply(0, arguments), j += Ya(j)) : j = (new la(a, c, o(d, 1), o(h, 0), o(i, 0), o(k, 0))).getTime();
        return j;
      };
      tb = c + "Minutes";
      ub = c + "Hours";
      vb = c + "Day";
      Ua = c + "Date";
      ab = c + "Month";
      bb = c + "FullYear";
      Fb = d + "Milliseconds";
      Gb = d + "Seconds";
      Hb = d + "Minutes";
      Ib = d + "Hours";
      kb = d + "Date";
      wb = d + "Month";
      xb = d + "FullYear";
    }
    function ma(a) {
      if (!(this instanceof ma))
        return new ma(a);
      this.init(a);
    }
    function O() {}
    function Va(a, b, c, d) {
      this.axis = a;
      this.pos = b;
      this.type = c || "";
      this.isNew = !0;
      !c && !d && this.addLabel();
    }
    function Jb(a, b, c, d, e) {
      var f = a.chart.inverted;
      this.axis = a;
      this.isNegative = c;
      this.options = b;
      this.x = d;
      this.total = null;
      this.points = {};
      this.stack = e;
      this.rightCliff = this.leftCliff = 0;
      this.alignOptions = {
        align: b.align || (f ? c ? "left" : "right" : "center"),
        verticalAlign: b.verticalAlign || (f ? "middle" : c ? "bottom" : "top"),
        y: o(b.y, f ? 4 : c ? 14 : -6),
        x: o(b.x, f ? c ? -6 : 6 : 0)
      };
      this.textAlign = b.textAlign || (f ? c ? "right" : "left" : "center");
    }
    var y,
        A = D.document,
        Y = Math,
        B = Y.round,
        V = Y.floor,
        ua = Y.ceil,
        t = Y.max,
        F = Y.min,
        Q = Y.abs,
        W = Y.cos,
        da = Y.sin,
        ra = Y.PI,
        ja = ra * 2 / 360,
        za = D.navigator && D.navigator.userAgent || "",
        Kb = D.opera,
        ya = /(msie|trident|edge)/i.test(za) && !Kb,
        lb = A && A.documentMode === 8,
        mb = !ya && /AppleWebKit/.test(za),
        Na = /Firefox/.test(za),
        Lb = /(Mobile|Android|Windows Phone)/.test(za),
        Ha = "http://www.w3.org/2000/svg",
        fa = A && A.createElementNS && !!A.createElementNS(Ha, "svg").createSVGRect,
        Pb = Na && parseInt(za.split("Firefox/")[1], 10) < 4,
        ka = A && !fa && !ya && !!A.createElement("canvas").getContext,
        cb,
        db,
        Mb = {},
        yb = 0,
        ib,
        U,
        Qa,
        H,
        Aa = function() {},
        T = [],
        eb = 0,
        Ma = "div",
        Qb = /^[0-9]+$/,
        nb = ["plotTop", "marginRight", "marginBottom", "plotLeft"],
        la,
        jb,
        qb,
        Za,
        tb,
        ub,
        vb,
        Ua,
        ab,
        bb,
        Fb,
        Gb,
        Hb,
        Ib,
        kb,
        wb,
        xb,
        L = {},
        x;
    x = D.Highcharts ? aa(16, !0) : {win: D};
    x.seriesTypes = L;
    var Ia = [],
        na,
        sa,
        p,
        Ba,
        zb,
        Ca,
        N,
        X,
        I,
        Wa,
        Oa;
    pb.prototype = {
      dSetter: function() {
        var a = this.paths[0],
            b = this.paths[1],
            c = [],
            d = this.now,
            e = a.length,
            f;
        if (d === 1)
          c = this.toD;
        else if (e === b.length && d < 1)
          for (; e--; )
            f = parseFloat(a[e]), c[e] = isNaN(f) ? a[e] : d * parseFloat(b[e] - f) + f;
        else
          c = b;
        this.elem.attr("d", c);
      },
      update: function() {
        var a = this.elem,
            b = this.prop,
            c = this.now,
            d = this.options.step;
        if (this[b + "Setter"])
          this[b + "Setter"]();
        else
          a.attr ? a.element && a.attr(b, c) : a.style[b] = c + this.unit;
        d && d.call(a, c, this);
      },
      run: function(a, b, c) {
        var d = this,
            e = function(a) {
              return e.stopped ? !1 : d.step(a);
            },
            f;
        this.startTime = +new la;
        this.start = a;
        this.end = b;
        this.unit = c;
        this.now = this.start;
        this.pos = 0;
        e.elem = this.elem;
        if (e() && Ia.push(e) === 1)
          e.timerId = setInterval(function() {
            for (f = 0; f < Ia.length; f++)
              Ia[f]() || Ia.splice(f--, 1);
            Ia.length || clearInterval(e.timerId);
          }, 13);
      },
      step: function(a) {
        var b = +new la,
            c,
            d = this.options;
        c = this.elem;
        var e = d.complete,
            f = d.duration,
            g = d.curAnim,
            h;
        if (c.attr && !c.element)
          c = !1;
        else if (a || b >= f + this.startTime) {
          this.now = this.end;
          this.pos = 1;
          this.update();
          a = g[this.prop] = !0;
          for (h in g)
            g[h] !== !0 && (a = !1);
          a && e && e.call(c);
          c = !1;
        } else
          this.pos = d.easing((b - this.startTime) / f), this.now = this.start + (this.end - this.start) * this.pos, this.update(), c = !0;
        return c;
      },
      initPath: function(a, b, c) {
        var b = b || "",
            d = a.shift,
            e = b.indexOf("C") > -1,
            f = e ? 7 : 3,
            g,
            b = b.split(" "),
            c = [].concat(c),
            h = a.isArea,
            i = h ? 2 : 1,
            k = function(a) {
              for (g = a.length; g--; )
                (a[g] === "M" || a[g] === "L") && a.splice(g + 1, 0, a[g + 1], a[g + 2], a[g + 1], a[g + 2]);
            };
        e && (k(b), k(c));
        if (d <= c.length / f && b.length === c.length)
          for (; d--; )
            c = c.slice(0, f).concat(c), h && (c = c.concat(c.slice(c.length - f)));
        a.shift = 0;
        if (b.length)
          for (a = c.length; b.length < a; )
            d = b.slice().splice(b.length / i - f, f * i), e && (d[f - 6] = d[f - 2], d[f - 5] = d[f - 1]), [].splice.apply(b, [b.length / i, 0].concat(d));
        return [b, c];
      }
    };
    var u = x.extend = function(a, b) {
      var c;
      a || (a = {});
      for (c in b)
        a[c] = b[c];
      return a;
    },
        J = x.isNumber = function(a) {
          return typeof a === "number" && !isNaN(a);
        },
        o = x.pick = function() {
          var a = arguments,
              b,
              c,
              d = a.length;
          for (b = 0; b < d; b++)
            if (c = a[b], c !== y && c !== null)
              return c;
        },
        fb = x.wrap = function(a, b, c) {
          var d = a[b];
          a[b] = function() {
            var a = Array.prototype.slice.call(arguments);
            a.unshift(d);
            return c.apply(this, a);
          };
        };
    Qa = function(a, b, c) {
      if (!J(b))
        return U.lang.invalidDate || "";
      var a = o(a, "%Y-%m-%d %H:%M:%S"),
          d = new la(b - Ya(b)),
          e,
          f = d[ub](),
          g = d[vb](),
          h = d[Ua](),
          i = d[ab](),
          k = d[bb](),
          j = U.lang,
          l = j.weekdays,
          m = j.shortWeekdays,
          d = u({
            a: m ? m[g] : l[g].substr(0, 3),
            A: l[g],
            d: Fa(h),
            e: Fa(h, 2, " "),
            w: g,
            b: j.shortMonths[i],
            B: j.months[i],
            m: Fa(i + 1),
            y: k.toString().substr(2, 2),
            Y: k,
            H: Fa(f),
            k: f,
            I: Fa(f % 12 || 12),
            l: f % 12 || 12,
            M: Fa(d[tb]()),
            p: f < 12 ? "AM" : "PM",
            P: f < 12 ? "am" : "pm",
            S: Fa(d.getSeconds()),
            L: Fa(B(b % 1E3), 3)
          }, x.dateFormats);
      for (e in d)
        for (; a.indexOf("%" + e) !== -1; )
          a = a.replace("%" + e, typeof d[e] === "function" ? d[e](b) : d[e]);
      return c ? a.substr(0, 1).toUpperCase() + a.substr(1) : a;
    };
    H = {
      millisecond: 1,
      second: 1E3,
      minute: 6E4,
      hour: 36E5,
      day: 864E5,
      week: 6048E5,
      month: 24192E5,
      year: 314496E5
    };
    x.numberFormat = function(a, b, c, d) {
      var a = +a || 0,
          b = +b,
          e = U.lang,
          f = (a.toString().split(".")[1] || "").length,
          g,
          h,
          i = Math.abs(a);
      b === -1 ? b = Math.min(f, 20) : J(b) || (b = 2);
      g = String(C(i.toFixed(b)));
      h = g.length > 3 ? g.length % 3 : 0;
      c = o(c, e.decimalPoint);
      d = o(d, e.thousandsSep);
      a = a < 0 ? "-" : "";
      a += h ? g.substr(0, h) + d : "";
      a += g.substr(h).replace(/(\d{3})(?=\d)/g, "$1" + d);
      b && (d = Math.abs(i - g + Math.pow(10, -Math.max(b, f) - 1)), a += c + d.toFixed(b).slice(2));
      return a;
    };
    Math.easeInOutSine = function(a) {
      return -0.5 * (Math.cos(Math.PI * a) - 1);
    };
    na = function(a, b) {
      var c;
      if (b === "width")
        return Math.min(a.offsetWidth, a.scrollWidth) - na(a, "padding-left") - na(a, "padding-right");
      else if (b === "height")
        return Math.min(a.offsetHeight, a.scrollHeight) - na(a, "padding-top") - na(a, "padding-bottom");
      return (c = D.getComputedStyle(a, void 0)) && C(c.getPropertyValue(b));
    };
    sa = function(a, b) {
      return b.indexOf ? b.indexOf(a) : [].indexOf.call(b, a);
    };
    Ba = function(a, b) {
      return [].filter.call(a, b);
    };
    Ca = function(a, b) {
      for (var c = [],
          d = 0,
          e = a.length; d < e; d++)
        c[d] = b.call(a[d], a[d], d, a);
      return c;
    };
    zb = function(a) {
      var b = A.documentElement,
          a = a.getBoundingClientRect();
      return {
        top: a.top + (D.pageYOffset || b.scrollTop) - (b.clientTop || 0),
        left: a.left + (D.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
      };
    };
    Oa = function(a) {
      for (var b = Ia.length; b--; )
        if (Ia[b].elem === a)
          Ia[b].stopped = !0;
    };
    p = function(a, b) {
      return Array.prototype.forEach.call(a, b);
    };
    N = function(a, b, c) {
      function d(b) {
        b.target = b.srcElement || D;
        c.call(a, b);
      }
      var e = a.hcEvents = a.hcEvents || {};
      if (a.addEventListener)
        a.addEventListener(b, c, !1);
      else if (a.attachEvent) {
        if (!a.hcEventsIE)
          a.hcEventsIE = {};
        a.hcEventsIE[c.toString()] = d;
        a.attachEvent("on" + b, d);
      }
      e[b] || (e[b] = []);
      e[b].push(c);
    };
    X = function(a, b, c) {
      function d(b, c) {
        a.removeEventListener ? a.removeEventListener(b, c, !1) : a.attachEvent && (c = a.hcEventsIE[c.toString()], a.detachEvent("on" + b, c));
      }
      function e() {
        var c,
            e,
            f;
        if (a.nodeName)
          for (f in b ? (c = {}, c[b] = !0) : c = g, c)
            if (g[f])
              for (e = g[f].length; e--; )
                d(f, g[f][e]);
      }
      var f,
          g = a.hcEvents,
          h;
      if (g)
        b ? (f = g[b] || [], c ? (h = sa(c, f), h > -1 && (f.splice(h, 1), g[b] = f), d(b, c)) : (e(), g[b] = [])) : (e(), a.hcEvents = {});
    };
    I = function(a, b, c, d) {
      var e;
      e = a.hcEvents;
      var f,
          g,
          c = c || {};
      if (A.createEvent && (a.dispatchEvent || a.fireEvent))
        e = A.createEvent("Events"), e.initEvent(b, !0, !0), e.target = a, u(e, c), a.dispatchEvent ? a.dispatchEvent(e) : a.fireEvent(b, e);
      else if (e) {
        e = e[b] || [];
        f = e.length;
        if (!c.preventDefault)
          c.preventDefault = function() {
            c.defaultPrevented = !0;
          };
        c.target = a;
        if (!c.type)
          c.type = b;
        for (b = 0; b < f; b++)
          g = e[b], g.call(a, c) === !1 && c.preventDefault();
      }
      d && !c.defaultPrevented && d(c);
    };
    Wa = function(a, b, c) {
      var d,
          e = "",
          f,
          g,
          h;
      Z(c) || (d = arguments, c = {
        duration: d[2],
        easing: d[3],
        complete: d[4]
      });
      if (!J(c.duration))
        c.duration = 400;
      c.easing = typeof c.easing === "function" ? c.easing : Math[c.easing] || Math.easeInOutSine;
      c.curAnim = E(b);
      for (h in b)
        g = new pb(a, c, h), f = null, h === "d" ? (g.paths = g.initPath(a, a.d, b.d), g.toD = b.d, d = 0, f = 1) : a.attr ? d = a.attr(h) : (d = parseFloat(na(a, h)) || 0, h !== "opacity" && (e = "px")), f || (f = b[h]), f.match && f.match("px") && (f = f.replace(/px/g, "")), g.run(d, f, e);
    };
    if (D.jQuery)
      D.jQuery.fn.highcharts = function() {
        var a = [].slice.call(arguments);
        if (this[0])
          return a[0] ? (new (x[xa(a[0]) ? a.shift() : "Chart"])(this[0], a[0], a[1]), this) : T[P(this[0], "data-highcharts-chart")];
      };
    A && !A.defaultView && (na = function(a, b) {
      var c;
      c = {
        width: "clientWidth",
        height: "clientHeight"
      }[b];
      if (a.style[b])
        return C(a.style[b]);
      b === "opacity" && (b = "filter");
      if (c)
        return a.style.zoom = 1, Math.max(a[c] - 2 * na(a, "padding"), 0);
      c = a.currentStyle[b.replace(/\-(\w)/g, function(a, b) {
        return b.toUpperCase();
      })];
      b === "filter" && (c = c.replace(/alpha\(opacity=([0-9]+)\)/, function(a, b) {
        return b / 100;
      }));
      return c === "" ? 1 : C(c);
    });
    Array.prototype.forEach || (p = function(a, b) {
      for (var c = 0,
          d = a.length; c < d; c++)
        if (b.call(a[c], a[c], c, a) === !1)
          return c;
    });
    Array.prototype.indexOf || (sa = function(a, b) {
      var c,
          d = 0;
      if (b)
        for (c = b.length; d < c; d++)
          if (b[d] === a)
            return d;
      return -1;
    });
    Array.prototype.filter || (Ba = function(a, b) {
      for (var c = [],
          d = 0,
          e = a.length; d < e; d++)
        b(a[d], d) && c.push(a[d]);
      return c;
    });
    x.Fx = pb;
    x.inArray = sa;
    x.each = p;
    x.grep = Ba;
    x.offset = zb;
    x.map = Ca;
    x.addEvent = N;
    x.removeEvent = X;
    x.fireEvent = I;
    x.animate = Wa;
    x.animObject = $a;
    x.stop = Oa;
    U = {
      colors: "#7cb5ec,#434348,#90ed7d,#f7a35c,#8085e9,#f15c80,#e4d354,#2b908f,#f45b5b,#91e8e1".split(","),
      symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
      lang: {
        loading: "Loading...",
        months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
        shortMonths: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
        weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
        decimalPoint: ".",
        numericSymbols: "k,M,G,T,P,E".split(","),
        resetZoom: "Reset zoom",
        resetZoomTitle: "Reset zoom level 1:1",
        thousandsSep: " "
      },
      global: {
        useUTC: !0,
        canvasToolsURL: "http://code.highcharts.com/modules/canvas-tools.js",
        VMLRadialGradientURL: "http://code.highcharts.com/4.2.5/gfx/vml-radial-gradient.png"
      },
      chart: {
        borderColor: "#4572A7",
        borderRadius: 0,
        defaultSeriesType: "line",
        ignoreHiddenSeries: !0,
        spacing: [10, 10, 15, 10],
        backgroundColor: "#FFFFFF",
        plotBorderColor: "#C0C0C0",
        resetZoomButton: {
          theme: {zIndex: 20},
          position: {
            align: "right",
            x: -10,
            y: 10
          }
        }
      },
      title: {
        text: "Chart title",
        align: "center",
        margin: 15,
        style: {
          color: "#333333",
          fontSize: "18px"
        },
        widthAdjust: -44
      },
      subtitle: {
        text: "",
        align: "center",
        style: {color: "#555555"},
        widthAdjust: -44
      },
      plotOptions: {line: {
          allowPointSelect: !1,
          showCheckbox: !1,
          animation: {duration: 1E3},
          events: {},
          lineWidth: 2,
          marker: {
            lineWidth: 0,
            radius: 4,
            lineColor: "#FFFFFF",
            states: {
              hover: {
                enabled: !0,
                lineWidthPlus: 1,
                radiusPlus: 2
              },
              select: {
                fillColor: "#FFFFFF",
                lineColor: "#000000",
                lineWidth: 2
              }
            }
          },
          point: {events: {}},
          dataLabels: {
            align: "center",
            formatter: function() {
              return this.y === null ? "" : x.numberFormat(this.y, -1);
            },
            style: {
              color: "contrast",
              fontSize: "11px",
              fontWeight: "bold",
              textShadow: "0 0 6px contrast, 0 0 3px contrast"
            },
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            padding: 5
          },
          cropThreshold: 300,
          pointRange: 0,
          softThreshold: !0,
          states: {
            hover: {
              lineWidthPlus: 1,
              marker: {},
              halo: {
                size: 10,
                opacity: 0.25
              }
            },
            select: {marker: {}}
          },
          stickyTracking: !0,
          turboThreshold: 1E3
        }},
      labels: {style: {
          position: "absolute",
          color: "#3E576F"
        }},
      legend: {
        enabled: !0,
        align: "center",
        layout: "horizontal",
        labelFormatter: function() {
          return this.name;
        },
        borderColor: "#909090",
        borderRadius: 0,
        navigation: {
          activeColor: "#274b6d",
          inactiveColor: "#CCC"
        },
        shadow: !1,
        itemStyle: {
          color: "#333333",
          fontSize: "12px",
          fontWeight: "bold"
        },
        itemHoverStyle: {color: "#000"},
        itemHiddenStyle: {color: "#CCC"},
        itemCheckboxStyle: {
          position: "absolute",
          width: "13px",
          height: "13px"
        },
        symbolPadding: 5,
        verticalAlign: "bottom",
        x: 0,
        y: 0,
        title: {style: {fontWeight: "bold"}}
      },
      loading: {
        labelStyle: {
          fontWeight: "bold",
          position: "relative",
          top: "45%"
        },
        style: {
          position: "absolute",
          backgroundColor: "white",
          opacity: 0.5,
          textAlign: "center"
        }
      },
      tooltip: {
        enabled: !0,
        animation: fa,
        backgroundColor: "rgba(249, 249, 249, .85)",
        borderWidth: 1,
        borderRadius: 3,
        dateTimeLabelFormats: {
          millisecond: "%A, %b %e, %H:%M:%S.%L",
          second: "%A, %b %e, %H:%M:%S",
          minute: "%A, %b %e, %H:%M",
          hour: "%A, %b %e, %H:%M",
          day: "%A, %b %e, %Y",
          week: "Week from %A, %b %e, %Y",
          month: "%B %Y",
          year: "%Y"
        },
        footerFormat: "",
        headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
        pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
        shadow: !0,
        snap: Lb ? 25 : 10,
        style: {
          color: "#333333",
          cursor: "default",
          fontSize: "12px",
          padding: "8px",
          pointerEvents: "none",
          whiteSpace: "nowrap"
        }
      },
      credits: {
        enabled: !0,
        text: "Highcharts.com",
        href: "http://www.highcharts.com",
        position: {
          align: "right",
          x: -10,
          verticalAlign: "bottom",
          y: -5
        },
        style: {
          cursor: "pointer",
          color: "#909090",
          fontSize: "9px"
        }
      }
    };
    var ea = U.plotOptions,
        ga = ea.line;
    Eb();
    ma.prototype = {
      parsers: [{
        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        parse: function(a) {
          return [C(a[1]), C(a[2]), C(a[3]), parseFloat(a[4], 10)];
        }
      }, {
        regex: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
        parse: function(a) {
          return [C(a[1], 16), C(a[2], 16), C(a[3], 16), 1];
        }
      }, {
        regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
        parse: function(a) {
          return [C(a[1]), C(a[2]), C(a[3]), 1];
        }
      }],
      init: function(a) {
        var b,
            c,
            d,
            e;
        if ((this.input = a) && a.stops)
          this.stops = Ca(a.stops, function(a) {
            return new ma(a[1]);
          });
        else
          for (d = this.parsers.length; d-- && !c; )
            e = this.parsers[d], (b = e.regex.exec(a)) && (c = e.parse(b));
        this.rgba = c || [];
      },
      get: function(a) {
        var b = this.input,
            c = this.rgba,
            d;
        this.stops ? (d = E(b), d.stops = [].concat(d.stops), p(this.stops, function(b, c) {
          d.stops[c] = [d.stops[c][0], b.get(a)];
        })) : d = c && J(c[0]) ? a === "rgb" || !a && c[3] === 1 ? "rgb(" + c[0] + "," + c[1] + "," + c[2] + ")" : a === "a" ? c[3] : "rgba(" + c.join(",") + ")" : b;
        return d;
      },
      brighten: function(a) {
        var b,
            c = this.rgba;
        if (this.stops)
          p(this.stops, function(b) {
            b.brighten(a);
          });
        else if (J(a) && a !== 0)
          for (b = 0; b < 3; b++)
            c[b] += C(a * 255), c[b] < 0 && (c[b] = 0), c[b] > 255 && (c[b] = 255);
        return this;
      },
      setOpacity: function(a) {
        this.rgba[3] = a;
        return this;
      }
    };
    O.prototype = {
      opacity: 1,
      textProps: "direction,fontSize,fontWeight,fontFamily,fontStyle,color,lineHeight,width,textDecoration,textOverflow,textShadow".split(","),
      init: function(a, b) {
        this.element = b === "span" ? ba(b) : A.createElementNS(Ha, b);
        this.renderer = a;
      },
      animate: function(a, b, c) {
        b = o(b, this.renderer.globalAnimation, !0);
        Oa(this);
        if (b) {
          if (c)
            b.complete = c;
          Wa(this, a, b);
        } else
          this.attr(a, null, c);
        return this;
      },
      colorGradient: function(a, b, c) {
        var d = this.renderer,
            e,
            f,
            g,
            h,
            i,
            k,
            j,
            l,
            m,
            n,
            q,
            z = [],
            s;
        a.linearGradient ? f = "linearGradient" : a.radialGradient && (f = "radialGradient");
        if (f) {
          g = a[f];
          i = d.gradients;
          j = a.stops;
          n = c.radialReference;
          Ea(g) && (a[f] = g = {
            x1: g[0],
            y1: g[1],
            x2: g[2],
            y2: g[3],
            gradientUnits: "userSpaceOnUse"
          });
          f === "radialGradient" && n && !r(g.gradientUnits) && (h = g, g = E(g, d.getRadialAttr(n, h), {gradientUnits: "userSpaceOnUse"}));
          for (q in g)
            q !== "id" && z.push(q, g[q]);
          for (q in j)
            z.push(j[q]);
          z = z.join(",");
          i[z] ? n = i[z].attr("id") : (g.id = n = "highcharts-" + yb++, i[z] = k = d.createElement(f).attr(g).add(d.defs), k.radAttr = h, k.stops = [], p(j, function(a) {
            a[1].indexOf("rgba") === 0 ? (e = ma(a[1]), l = e.get("rgb"), m = e.get("a")) : (l = a[1], m = 1);
            a = d.createElement("stop").attr({
              offset: a[0],
              "stop-color": l,
              "stop-opacity": m
            }).add(k);
            k.stops.push(a);
          }));
          s = "url(" + d.url + "#" + n + ")";
          c.setAttribute(b, s);
          c.gradient = z;
          a.toString = function() {
            return s;
          };
        }
      },
      applyTextShadow: function(a) {
        var b = this.element,
            c,
            d = a.indexOf("contrast") !== -1,
            e = {},
            f = this.renderer.forExport,
            g = f || b.style.textShadow !== y && !ya;
        if (d)
          e.textShadow = a = a.replace(/contrast/g, this.renderer.getContrast(b.style.fill));
        if (mb || f)
          e.textRendering = "geometricPrecision";
        g ? this.css(e) : (this.fakeTS = !0, this.ySetter = this.xSetter, c = [].slice.call(b.getElementsByTagName("tspan")), p(a.split(/\s?,\s?/g), function(a) {
          var d = b.firstChild,
              e,
              f,
              a = a.split(" ");
          e = a[a.length - 1];
          (f = a[a.length - 2]) && p(c, function(a, c) {
            var g;
            c === 0 && (a.setAttribute("x", b.getAttribute("x")), c = b.getAttribute("y"), a.setAttribute("y", c || 0), c === null && b.setAttribute("y", 0));
            g = a.cloneNode(1);
            P(g, {
              "class": "highcharts-text-shadow",
              fill: e,
              stroke: e,
              "stroke-opacity": 1 / t(C(f), 3),
              "stroke-width": f,
              "stroke-linejoin": "round"
            });
            b.insertBefore(g, d);
          });
        }));
      },
      attr: function(a, b, c) {
        var d,
            e = this.element,
            f,
            g = this,
            h;
        typeof a === "string" && b !== y && (d = a, a = {}, a[d] = b);
        if (typeof a === "string")
          g = (this[a + "Getter"] || this._defaultGetter).call(this, a, e);
        else {
          for (d in a) {
            b = a[d];
            h = !1;
            this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(d) && (f || (this.symbolAttr(a), f = !0), h = !0);
            if (this.rotation && (d === "x" || d === "y"))
              this.doTransform = !0;
            h || (h = this[d + "Setter"] || this._defaultSetter, h.call(this, b, d, e), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(d) && this.updateShadows(d, b, h));
          }
          if (this.doTransform)
            this.updateTransform(), this.doTransform = !1;
        }
        c && c();
        return g;
      },
      updateShadows: function(a, b, c) {
        for (var d = this.shadows,
            e = d.length; e--; )
          c.call(d[e], a === "height" ? Math.max(b - (d[e].cutHeight || 0), 0) : a === "d" ? this.d : b, a, d[e]);
      },
      addClass: function(a) {
        var b = this.element,
            c = P(b, "class") || "";
        c.indexOf(a) === -1 && P(b, "class", c + " " + a);
        return this;
      },
      symbolAttr: function(a) {
        var b = this;
        p("x,y,r,start,end,width,height,innerR,anchorX,anchorY".split(","), function(c) {
          b[c] = o(a[c], b[c]);
        });
        b.attr({d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)});
      },
      clip: function(a) {
        return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none");
      },
      crisp: function(a) {
        var b,
            c = {},
            d,
            e = this.strokeWidth || 0;
        d = B(e) % 2 / 2;
        a.x = V(a.x || this.x || 0) + d;
        a.y = V(a.y || this.y || 0) + d;
        a.width = V((a.width || this.width || 0) - 2 * d);
        a.height = V((a.height || this.height || 0) - 2 * d);
        a.strokeWidth = e;
        for (b in a)
          this[b] !== a[b] && (this[b] = c[b] = a[b]);
        return c;
      },
      css: function(a) {
        var b = this.styles,
            c = {},
            d = this.element,
            e,
            f,
            g = "";
        e = !b;
        if (a && a.color)
          a.fill = a.color;
        if (b)
          for (f in a)
            a[f] !== b[f] && (c[f] = a[f], e = !0);
        if (e) {
          e = this.textWidth = a && a.width && d.nodeName.toLowerCase() === "text" && C(a.width) || this.textWidth;
          b && (a = u(b, c));
          this.styles = a;
          e && (ka || !fa && this.renderer.forExport) && delete a.width;
          if (ya && !fa)
            M(this.element, a);
          else {
            b = function(a, b) {
              return "-" + b.toLowerCase();
            };
            for (f in a)
              g += f.replace(/([A-Z])/g, b) + ":" + a[f] + ";";
            P(d, "style", g);
          }
          e && this.added && this.renderer.buildText(this);
        }
        return this;
      },
      on: function(a, b) {
        var c = this,
            d = c.element;
        db && a === "click" ? (d.ontouchstart = function(a) {
          c.touchEventFired = la.now();
          a.preventDefault();
          b.call(d, a);
        }, d.onclick = function(a) {
          (za.indexOf("Android") === -1 || la.now() - (c.touchEventFired || 0) > 1100) && b.call(d, a);
        }) : d["on" + a] = b;
        return this;
      },
      setRadialReference: function(a) {
        var b = this.renderer.gradients[this.element.gradient];
        this.element.radialReference = a;
        b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));
        return this;
      },
      translate: function(a, b) {
        return this.attr({
          translateX: a,
          translateY: b
        });
      },
      invert: function() {
        this.inverted = !0;
        this.updateTransform();
        return this;
      },
      updateTransform: function() {
        var a = this.translateX || 0,
            b = this.translateY || 0,
            c = this.scaleX,
            d = this.scaleY,
            e = this.inverted,
            f = this.rotation,
            g = this.element;
        e && (a += this.attr("width"), b += this.attr("height"));
        a = ["translate(" + a + "," + b + ")"];
        e ? a.push("rotate(90) scale(-1,1)") : f && a.push("rotate(" + f + " " + (g.getAttribute("x") || 0) + " " + (g.getAttribute("y") || 0) + ")");
        (r(c) || r(d)) && a.push("scale(" + o(c, 1) + " " + o(d, 1) + ")");
        a.length && g.setAttribute("transform", a.join(" "));
      },
      toFront: function() {
        var a = this.element;
        a.parentNode.appendChild(a);
        return this;
      },
      align: function(a, b, c) {
        var d,
            e,
            f,
            g,
            h = {};
        e = this.renderer;
        f = e.alignedObjects;
        if (a) {
          if (this.alignOptions = a, this.alignByTranslate = b, !c || xa(c))
            this.alignTo = d = c || "renderer", pa(f, this), f.push(this), c = null;
        } else
          a = this.alignOptions, b = this.alignByTranslate, d = this.alignTo;
        c = o(c, e[d], e);
        d = a.align;
        e = a.verticalAlign;
        f = (c.x || 0) + (a.x || 0);
        g = (c.y || 0) + (a.y || 0);
        if (d === "right" || d === "center")
          f += (c.width - (a.width || 0)) / {
            right: 1,
            center: 2
          }[d];
        h[b ? "translateX" : "x"] = B(f);
        if (e === "bottom" || e === "middle")
          g += (c.height - (a.height || 0)) / ({
            bottom: 1,
            middle: 2
          }[e] || 1);
        h[b ? "translateY" : "y"] = B(g);
        this[this.placed ? "animate" : "attr"](h);
        this.placed = !0;
        this.alignAttr = h;
        return this;
      },
      getBBox: function(a, b) {
        var c,
            d = this.renderer,
            e,
            f,
            g,
            h = this.element,
            i = this.styles;
        e = this.textStr;
        var k,
            j = h.style,
            l,
            m = d.cache,
            n = d.cacheKeys,
            q;
        f = o(b, this.rotation);
        g = f * ja;
        e !== y && (q = ["", f || 0, i && i.fontSize, h.style.width].join(","), q = e === "" || Qb.test(e) ? "num:" + e.toString().length + q : e + q);
        q && !a && (c = m[q]);
        if (!c) {
          if (h.namespaceURI === Ha || d.forExport) {
            try {
              l = this.fakeTS && function(a) {
                p(h.querySelectorAll(".highcharts-text-shadow"), function(b) {
                  b.style.display = a;
                });
              }, Na && j.textShadow ? (k = j.textShadow, j.textShadow = "") : l && l("none"), c = h.getBBox ? u({}, h.getBBox()) : {
                width: h.offsetWidth,
                height: h.offsetHeight
              }, k ? j.textShadow = k : l && l("");
            } catch (z) {}
            if (!c || c.width < 0)
              c = {
                width: 0,
                height: 0
              };
          } else
            c = this.htmlGetBBox();
          if (d.isSVG) {
            d = c.width;
            e = c.height;
            if (ya && i && i.fontSize === "11px" && e.toPrecision(3) === "16.9")
              c.height = e = 14;
            if (f)
              c.width = Q(e * da(g)) + Q(d * W(g)), c.height = Q(e * W(g)) + Q(d * da(g));
          }
          if (q) {
            for (; n.length > 250; )
              delete m[n.shift()];
            m[q] || n.push(q);
            m[q] = c;
          }
        }
        return c;
      },
      show: function(a) {
        return this.attr({visibility: a ? "inherit" : "visible"});
      },
      hide: function() {
        return this.attr({visibility: "hidden"});
      },
      fadeOut: function(a) {
        var b = this;
        b.animate({opacity: 0}, {
          duration: a || 150,
          complete: function() {
            b.attr({y: -9999});
          }
        });
      },
      add: function(a) {
        var b = this.renderer,
            c = this.element,
            d;
        if (a)
          this.parentGroup = a;
        this.parentInverted = a && a.inverted;
        this.textStr !== void 0 && b.buildText(this);
        this.added = !0;
        if (!a || a.handleZ || this.zIndex)
          d = this.zIndexSetter();
        d || (a ? a.element : b.box).appendChild(c);
        if (this.onAdd)
          this.onAdd();
        return this;
      },
      safeRemoveChild: function(a) {
        var b = a.parentNode;
        b && b.removeChild(a);
      },
      destroy: function() {
        var a = this,
            b = a.element || {},
            c = a.shadows,
            d = a.renderer.isSVG && b.nodeName === "SPAN" && a.parentGroup,
            e,
            f;
        b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;
        Oa(a);
        if (a.clipPath)
          a.clipPath = a.clipPath.destroy();
        if (a.stops) {
          for (f = 0; f < a.stops.length; f++)
            a.stops[f] = a.stops[f].destroy();
          a.stops = null;
        }
        a.safeRemoveChild(b);
        for (c && p(c, function(b) {
          a.safeRemoveChild(b);
        }); d && d.div && d.div.childNodes.length === 0; )
          b = d.parentGroup, a.safeRemoveChild(d.div), delete d.div, d = b;
        a.alignTo && pa(a.renderer.alignedObjects, a);
        for (e in a)
          delete a[e];
        return null;
      },
      shadow: function(a, b, c) {
        var d = [],
            e,
            f,
            g = this.element,
            h,
            i,
            k,
            j;
        if (a) {
          i = o(a.width, 3);
          k = (a.opacity || 0.15) / i;
          j = this.parentInverted ? "(-1,-1)" : "(" + o(a.offsetX, 1) + ", " + o(a.offsetY, 1) + ")";
          for (e = 1; e <= i; e++) {
            f = g.cloneNode(0);
            h = i * 2 + 1 - 2 * e;
            P(f, {
              isShadow: "true",
              stroke: a.color || "black",
              "stroke-opacity": k * e,
              "stroke-width": h,
              transform: "translate" + j,
              fill: "none"
            });
            if (c)
              P(f, "height", t(P(f, "height") - h, 0)), f.cutHeight = h;
            b ? b.element.appendChild(f) : g.parentNode.insertBefore(f, g);
            d.push(f);
          }
          this.shadows = d;
        }
        return this;
      },
      xGetter: function(a) {
        this.element.nodeName === "circle" && (a = {
          x: "cx",
          y: "cy"
        }[a] || a);
        return this._defaultGetter(a);
      },
      _defaultGetter: function(a) {
        a = o(this[a], this.element ? this.element.getAttribute(a) : null, 0);
        /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));
        return a;
      },
      dSetter: function(a, b, c) {
        a && a.join && (a = a.join(" "));
        /(NaN| {2}|^$)/.test(a) && (a = "M 0 0");
        c.setAttribute(b, a);
        this[b] = a;
      },
      dashstyleSetter: function(a) {
        var b,
            c = this["stroke-width"];
        c === "inherit" && (c = 1);
        if (a = a && a.toLowerCase()) {
          a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
          for (b = a.length; b--; )
            a[b] = C(a[b]) * c;
          a = a.join(",").replace(/NaN/g, "none");
          this.element.setAttribute("stroke-dasharray", a);
        }
      },
      alignSetter: function(a) {
        this.element.setAttribute("text-anchor", {
          left: "start",
          center: "middle",
          right: "end"
        }[a]);
      },
      opacitySetter: function(a, b, c) {
        this[b] = a;
        c.setAttribute(b, a);
      },
      titleSetter: function(a) {
        var b = this.element.getElementsByTagName("title")[0];
        b || (b = A.createElementNS(Ha, "title"), this.element.appendChild(b));
        b.firstChild && b.removeChild(b.firstChild);
        b.appendChild(A.createTextNode(String(o(a), "").replace(/<[^>]*>/g, "")));
      },
      textSetter: function(a) {
        if (a !== this.textStr)
          delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this);
      },
      fillSetter: function(a, b, c) {
        typeof a === "string" ? c.setAttribute(b, a) : a && this.colorGradient(a, b, c);
      },
      visibilitySetter: function(a, b, c) {
        a === "inherit" ? c.removeAttribute(b) : c.setAttribute(b, a);
      },
      zIndexSetter: function(a, b) {
        var c = this.renderer,
            d = this.parentGroup,
            c = (d || c).element || c.box,
            e,
            f,
            g = this.element,
            h;
        e = this.added;
        var i;
        if (r(a))
          g.zIndex = a, a = +a, this[b] === a && (e = !1), this[b] = a;
        if (e) {
          if ((a = this.zIndex) && d)
            d.handleZ = !0;
          d = c.childNodes;
          for (i = 0; i < d.length && !h; i++)
            if (e = d[i], f = e.zIndex, e !== g && (C(f) > a || !r(a) && r(f)))
              c.insertBefore(g, e), h = !0;
          h || c.appendChild(g);
        }
        return h;
      },
      _defaultSetter: function(a, b, c) {
        c.setAttribute(b, a);
      }
    };
    O.prototype.yGetter = O.prototype.xGetter;
    O.prototype.translateXSetter = O.prototype.translateYSetter = O.prototype.rotationSetter = O.prototype.verticalAlignSetter = O.prototype.scaleXSetter = O.prototype.scaleYSetter = function(a, b) {
      this[b] = a;
      this.doTransform = !0;
    };
    O.prototype["stroke-widthSetter"] = O.prototype.strokeSetter = function(a, b, c) {
      this[b] = a;
      if (this.stroke && this["stroke-width"])
        this.strokeWidth = this["stroke-width"], O.prototype.fillSetter.call(this, this.stroke, "stroke", c), c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0;
      else if (b === "stroke-width" && a === 0 && this.hasStroke)
        c.removeAttribute("stroke"), this.hasStroke = !1;
    };
    var Da = function() {
      this.init.apply(this, arguments);
    };
    Da.prototype = {
      Element: O,
      init: function(a, b, c, d, e, f) {
        var g,
            d = this.createElement("svg").attr({version: "1.1"}).css(this.getStyle(d));
        g = d.element;
        a.appendChild(g);
        a.innerHTML.indexOf("xmlns") === -1 && P(g, "xmlns", Ha);
        this.isSVG = !0;
        this.box = g;
        this.boxWrapper = d;
        this.alignedObjects = [];
        this.url = (Na || mb) && A.getElementsByTagName("base").length ? D.location.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
        this.createElement("desc").add().element.appendChild(A.createTextNode("Created with Highcharts 4.2.5"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = f;
        this.forExport = e;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(b, c, !1);
        var h;
        if (Na && a.getBoundingClientRect)
          this.subPixelFix = b = function() {
            M(a, {
              left: 0,
              top: 0
            });
            h = a.getBoundingClientRect();
            M(a, {
              left: ua(h.left) - h.left + "px",
              top: ua(h.top) - h.top + "px"
            });
          }, b(), N(D, "resize", b);
      },
      getStyle: function(a) {
        return this.style = u({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: "12px"
        }, a);
      },
      isHidden: function() {
        return !this.boxWrapper.getBBox().width;
      },
      destroy: function() {
        var a = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        Ra(this.gradients || {});
        this.gradients = null;
        if (a)
          this.defs = a.destroy();
        this.subPixelFix && X(D, "resize", this.subPixelFix);
        return this.alignedObjects = null;
      },
      createElement: function(a) {
        var b = new this.Element;
        b.init(this, a);
        return b;
      },
      draw: function() {},
      getRadialAttr: function(a, b) {
        return {
          cx: a[0] - a[2] / 2 + b.cx * a[2],
          cy: a[1] - a[2] / 2 + b.cy * a[2],
          r: b.r * a[2]
        };
      },
      buildText: function(a) {
        for (var b = a.element,
            c = this,
            d = c.forExport,
            e = o(a.textStr, "").toString(),
            f = e.indexOf("<") !== -1,
            g = b.childNodes,
            h,
            i,
            k,
            j = P(b, "x"),
            l = a.styles,
            m = a.textWidth,
            n = l && l.lineHeight,
            q = l && l.textShadow,
            z = l && l.textOverflow === "ellipsis",
            s = g.length,
            G = m && !a.added && this.box,
            w = function(a) {
              return n ? C(n) : c.fontMetrics(/(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : l && l.fontSize || c.style.fontSize || 12, a).h;
            },
            v = function(a) {
              return a.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            }; s--; )
          b.removeChild(g[s]);
        !f && !q && !z && e.indexOf(" ") === -1 ? b.appendChild(A.createTextNode(v(e))) : (h = /<.*style="([^"]+)".*>/, i = /<.*href="(http[^"]+)".*>/, G && G.appendChild(b), e = f ? e.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g) : [e], e = Ba(e, function(a) {
          return a !== "";
        }), p(e, function(e, f) {
          var g,
              n = 0,
              e = e.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
          g = e.split("|||");
          p(g, function(e) {
            if (e !== "" || g.length === 1) {
              var q = {},
                  s = A.createElementNS(Ha, "tspan"),
                  o;
              h.test(e) && (o = e.match(h)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), P(s, "style", o));
              i.test(e) && !d && (P(s, "onclick", 'location.href="' + e.match(i)[1] + '"'), M(s, {cursor: "pointer"}));
              e = v(e.replace(/<(.|\n)*?>/g, "") || " ");
              if (e !== " ") {
                s.appendChild(A.createTextNode(e));
                if (n)
                  q.dx = 0;
                else if (f && j !== null)
                  q.x = j;
                P(s, q);
                b.appendChild(s);
                !n && f && (!fa && d && M(s, {display: "block"}), P(s, "dy", w(s)));
                if (m) {
                  for (var q = e.replace(/([^\^])-/g, "$1- ").split(" "),
                      p = g.length > 1 || f || q.length > 1 && l.whiteSpace !== "nowrap",
                      G,
                      S,
                      r = [],
                      t = w(s),
                      u = 1,
                      B = a.rotation,
                      y = e,
                      x = y.length; (p || z) && (q.length || r.length); )
                    a.rotation = 0, G = a.getBBox(!0), S = G.width, !fa && c.forExport && (S = c.measureSpanWidth(s.firstChild.data, a.styles)), G = S > m, k === void 0 && (k = G), z && k ? (x /= 2, y === "" || !G && x < 0.5 ? q = [] : (y = e.substring(0, y.length + (G ? -1 : 1) * ua(x)), q = [y + (m > 3 ? "\u2026" : "")], s.removeChild(s.firstChild))) : !G || q.length === 1 ? (q = r, r = [], q.length && (u++, s = A.createElementNS(Ha, "tspan"), P(s, {
                      dy: t,
                      x: j
                    }), o && P(s, "style", o), b.appendChild(s)), S > m && (m = S)) : (s.removeChild(s.firstChild), r.unshift(q.pop())), q.length && s.appendChild(A.createTextNode(q.join(" ").replace(/- /g, "-")));
                  a.rotation = B;
                }
                n++;
              }
            }
          });
        }), k && a.attr("title", a.textStr), G && G.removeChild(b), q && a.applyTextShadow && a.applyTextShadow(q));
      },
      getContrast: function(a) {
        a = ma(a).rgba;
        return a[0] + a[1] + a[2] > 384 ? "#000000" : "#FFFFFF";
      },
      button: function(a, b, c, d, e, f, g, h, i) {
        var k = this.label(a, b, c, i, null, null, null, null, "button"),
            j = 0,
            l,
            m,
            n,
            q,
            z,
            s,
            a = {
              x1: 0,
              y1: 0,
              x2: 0,
              y2: 1
            },
            e = E({
              "stroke-width": 1,
              stroke: "#CCCCCC",
              fill: {
                linearGradient: a,
                stops: [[0, "#FEFEFE"], [1, "#F6F6F6"]]
              },
              r: 2,
              padding: 5,
              style: {color: "black"}
            }, e);
        n = e.style;
        delete e.style;
        f = E(e, {
          stroke: "#68A",
          fill: {
            linearGradient: a,
            stops: [[0, "#FFF"], [1, "#ACF"]]
          }
        }, f);
        q = f.style;
        delete f.style;
        g = E(e, {
          stroke: "#68A",
          fill: {
            linearGradient: a,
            stops: [[0, "#9BD"], [1, "#CDF"]]
          }
        }, g);
        z = g.style;
        delete g.style;
        h = E(e, {style: {color: "#CCC"}}, h);
        s = h.style;
        delete h.style;
        N(k.element, ya ? "mouseover" : "mouseenter", function() {
          j !== 3 && k.attr(f).css(q);
        });
        N(k.element, ya ? "mouseout" : "mouseleave", function() {
          j !== 3 && (l = [e, f, g][j], m = [n, q, z][j], k.attr(l).css(m));
        });
        k.setState = function(a) {
          (k.state = j = a) ? a === 2 ? k.attr(g).css(z) : a === 3 && k.attr(h).css(s) : k.attr(e).css(n);
        };
        return k.on("click", function(a) {
          j !== 3 && d.call(k, a);
        }).attr(e).css(u({cursor: "default"}, n));
      },
      crispLine: function(a, b) {
        a[1] === a[4] && (a[1] = a[4] = B(a[1]) - b % 2 / 2);
        a[2] === a[5] && (a[2] = a[5] = B(a[2]) + b % 2 / 2);
        return a;
      },
      path: function(a) {
        var b = {fill: "none"};
        Ea(a) ? b.d = a : Z(a) && u(b, a);
        return this.createElement("path").attr(b);
      },
      circle: function(a, b, c) {
        a = Z(a) ? a : {
          x: a,
          y: b,
          r: c
        };
        b = this.createElement("circle");
        b.xSetter = b.ySetter = function(a, b, c) {
          c.setAttribute("c" + b, a);
        };
        return b.attr(a);
      },
      arc: function(a, b, c, d, e, f) {
        if (Z(a))
          b = a.y, c = a.r, d = a.innerR, e = a.start, f = a.end, a = a.x;
        a = this.symbol("arc", a || 0, b || 0, c || 0, c || 0, {
          innerR: d || 0,
          start: e || 0,
          end: f || 0
        });
        a.r = c;
        return a;
      },
      rect: function(a, b, c, d, e, f) {
        var e = Z(a) ? a.r : e,
            g = this.createElement("rect"),
            a = Z(a) ? a : a === y ? {} : {
              x: a,
              y: b,
              width: t(c, 0),
              height: t(d, 0)
            };
        if (f !== y)
          g.strokeWidth = f, a = g.crisp(a);
        if (e)
          a.r = e;
        g.rSetter = function(a, b, c) {
          P(c, {
            rx: a,
            ry: a
          });
        };
        return g.attr(a);
      },
      setSize: function(a, b, c) {
        var d = this.alignedObjects,
            e = d.length;
        this.width = a;
        this.height = b;
        for (this.boxWrapper[o(c, !0) ? "animate" : "attr"]({
          width: a,
          height: b
        }); e--; )
          d[e].align();
      },
      g: function(a) {
        var b = this.createElement("g");
        return r(a) ? b.attr({"class": "highcharts-" + a}) : b;
      },
      image: function(a, b, c, d, e) {
        var f = {preserveAspectRatio: "none"};
        arguments.length > 1 && u(f, {
          x: b,
          y: c,
          width: d,
          height: e
        });
        f = this.createElement("image").attr(f);
        f.element.setAttributeNS ? f.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : f.element.setAttribute("hc-svg-href", a);
        return f;
      },
      symbol: function(a, b, c, d, e, f) {
        var g = this,
            h,
            i = this.symbols[a],
            i = i && i(B(b), B(c), d, e, f),
            k = /^url\((.*?)\)$/,
            j,
            l;
        if (i)
          h = this.path(i), u(h, {
            symbolName: a,
            x: b,
            y: c,
            width: d,
            height: e
          }), f && u(h, f);
        else if (k.test(a))
          l = function(a, b) {
            a.element && (a.attr({
              width: b[0],
              height: b[1]
            }), a.alignByTranslate || a.translate(B((d - b[0]) / 2), B((e - b[1]) / 2)));
          }, j = a.match(k)[1], a = Mb[j] || f && f.width && f.height && [f.width, f.height], h = this.image(j).attr({
            x: b,
            y: c
          }), h.isImg = !0, a ? l(h, a) : (h.attr({
            width: 0,
            height: 0
          }), ba("img", {
            onload: function() {
              this.width === 0 && (M(this, {
                position: "absolute",
                top: "-999em"
              }), A.body.appendChild(this));
              l(h, Mb[j] = [this.width, this.height]);
              this.parentNode && this.parentNode.removeChild(this);
              g.imgCount--;
              if (!g.imgCount && T[g.chartIndex].onload)
                T[g.chartIndex].onload();
            },
            src: j
          }), this.imgCount++);
        return h;
      },
      symbols: {
        circle: function(a, b, c, d) {
          var e = 0.166 * c;
          return ["M", a + c / 2, b, "C", a + c + e, b, a + c + e, b + d, a + c / 2, b + d, "C", a - e, b + d, a - e, b, a + c / 2, b, "Z"];
        },
        square: function(a, b, c, d) {
          return ["M", a, b, "L", a + c, b, a + c, b + d, a, b + d, "Z"];
        },
        triangle: function(a, b, c, d) {
          return ["M", a + c / 2, b, "L", a + c, b + d, a, b + d, "Z"];
        },
        "triangle-down": function(a, b, c, d) {
          return ["M", a, b, "L", a + c, b, a + c / 2, b + d, "Z"];
        },
        diamond: function(a, b, c, d) {
          return ["M", a + c / 2, b, "L", a + c, b + d / 2, a + c / 2, b + d, a, b + d / 2, "Z"];
        },
        arc: function(a, b, c, d, e) {
          var f = e.start,
              c = e.r || c || d,
              g = e.end - 0.001,
              d = e.innerR,
              h = e.open,
              i = W(f),
              k = da(f),
              j = W(g),
              g = da(g),
              e = e.end - f < ra ? 0 : 1;
          return ["M", a + c * i, b + c * k, "A", c, c, 0, e, 1, a + c * j, b + c * g, h ? "M" : "L", a + d * j, b + d * g, "A", d, d, 0, e, 0, a + d * i, b + d * k, h ? "" : "Z"];
        },
        callout: function(a, b, c, d, e) {
          var f = F(e && e.r || 0, c, d),
              g = f + 6,
              h = e && e.anchorX,
              e = e && e.anchorY,
              i;
          i = ["M", a + f, b, "L", a + c - f, b, "C", a + c, b, a + c, b, a + c, b + f, "L", a + c, b + d - f, "C", a + c, b + d, a + c, b + d, a + c - f, b + d, "L", a + f, b + d, "C", a, b + d, a, b + d, a, b + d - f, "L", a, b + f, "C", a, b, a, b, a + f, b];
          h && h > c && e > b + g && e < b + d - g ? i.splice(13, 3, "L", a + c, e - 6, a + c + 6, e, a + c, e + 6, a + c, b + d - f) : h && h < 0 && e > b + g && e < b + d - g ? i.splice(33, 3, "L", a, e + 6, a - 6, e, a, e - 6, a, b + f) : e && e > d && h > a + g && h < a + c - g ? i.splice(23, 3, "L", h + 6, b + d, h, b + d + 6, h - 6, b + d, a + f, b + d) : e && e < 0 && h > a + g && h < a + c - g && i.splice(3, 3, "L", h - 6, b, h, b - 6, h + 6, b, c - f, b);
          return i;
        }
      },
      clipRect: function(a, b, c, d) {
        var e = "highcharts-" + yb++,
            f = this.createElement("clipPath").attr({id: e}).add(this.defs),
            a = this.rect(a, b, c, d, 0).add(f);
        a.id = e;
        a.clipPath = f;
        a.count = 0;
        return a;
      },
      text: function(a, b, c, d) {
        var e = ka || !fa && this.forExport,
            f = {};
        if (d && (this.allowHTML || !this.forExport))
          return this.html(a, b, c);
        f.x = Math.round(b || 0);
        if (c)
          f.y = Math.round(c);
        if (a || a === 0)
          f.text = a;
        a = this.createElement("text").attr(f);
        e && a.css({position: "absolute"});
        if (!d)
          a.xSetter = function(a, b, c) {
            var d = c.getElementsByTagName("tspan"),
                e,
                f = c.getAttribute(b),
                m;
            for (m = 0; m < d.length; m++)
              e = d[m], e.getAttribute(b) === f && e.setAttribute(b, a);
            c.setAttribute(b, a);
          };
        return a;
      },
      fontMetrics: function(a, b) {
        var c,
            d,
            a = a || this.style.fontSize;
        !a && b && D.getComputedStyle && (b = b.element || b, a = (c = D.getComputedStyle(b, "")) && c.fontSize);
        a = /px/.test(a) ? C(a) : /em/.test(a) ? parseFloat(a) * 12 : 12;
        c = a < 24 ? a + 3 : B(a * 1.2);
        d = B(c * 0.8);
        return {
          h: c,
          b: d,
          f: a
        };
      },
      rotCorr: function(a, b, c) {
        var d = a;
        b && c && (d = t(d * W(b * ja), 4));
        return {
          x: -a / 3 * da(b * ja),
          y: d
        };
      },
      label: function(a, b, c, d, e, f, g, h, i) {
        var k = this,
            j = k.g(i),
            l = k.text("", 0, 0, g).attr({zIndex: 1}),
            m,
            n,
            q = 0,
            z = 3,
            s = 0,
            o,
            w,
            v,
            S,
            t = 0,
            $ = {},
            x,
            A,
            Ab,
            F,
            D;
        Ab = function() {
          var a,
              b;
          a = l.element.style;
          n = (o === void 0 || w === void 0 || j.styles.textAlign) && r(l.textStr) && l.getBBox();
          j.width = (o || n.width || 0) + 2 * z + s;
          j.height = (w || n.height || 0) + 2 * z;
          x = z + k.fontMetrics(a && a.fontSize, l).b;
          if (A) {
            if (!m)
              a = t, b = (h ? -x : 0) + t, j.box = m = d ? k.symbol(d, a, b, j.width, j.height, $) : k.rect(a, b, j.width, j.height, 0, $["stroke-width"]), m.isImg || m.attr("fill", "none"), m.add(j);
            m.isImg || m.attr(u({
              width: B(j.width),
              height: B(j.height)
            }, $));
            $ = null;
          }
        };
        F = function() {
          var a = j.styles,
              a = a && a.textAlign,
              b = s + z,
              c;
          c = h ? 0 : x;
          if (r(o) && n && (a === "center" || a === "right"))
            b += {
              center: 0.5,
              right: 1
            }[a] * (o - n.width);
          if (b !== l.x || c !== l.y)
            l.attr("x", b), c !== y && l.attr("y", c);
          l.x = b;
          l.y = c;
        };
        D = function(a, b) {
          m ? m.attr(a, b) : $[a] = b;
        };
        j.onAdd = function() {
          l.add(j);
          j.attr({
            text: a || a === 0 ? a : "",
            x: b,
            y: c
          });
          m && r(e) && j.attr({
            anchorX: e,
            anchorY: f
          });
        };
        j.widthSetter = function(a) {
          o = a;
        };
        j.heightSetter = function(a) {
          w = a;
        };
        j.paddingSetter = function(a) {
          if (r(a) && a !== z)
            z = j.padding = a, F();
        };
        j.paddingLeftSetter = function(a) {
          r(a) && a !== s && (s = a, F());
        };
        j.alignSetter = function(a) {
          a = {
            left: 0,
            center: 0.5,
            right: 1
          }[a];
          a !== q && (q = a, n && j.attr({x: v}));
        };
        j.textSetter = function(a) {
          a !== y && l.textSetter(a);
          Ab();
          F();
        };
        j["stroke-widthSetter"] = function(a, b) {
          a && (A = !0);
          t = a % 2 / 2;
          D(b, a);
        };
        j.strokeSetter = j.fillSetter = j.rSetter = function(a, b) {
          b === "fill" && a && (A = !0);
          D(b, a);
        };
        j.anchorXSetter = function(a, b) {
          e = a;
          D(b, B(a) - t - v);
        };
        j.anchorYSetter = function(a, b) {
          f = a;
          D(b, a - S);
        };
        j.xSetter = function(a) {
          j.x = a;
          q && (a -= q * ((o || n.width) + 2 * z));
          v = B(a);
          j.attr("translateX", v);
        };
        j.ySetter = function(a) {
          S = j.y = B(a);
          j.attr("translateY", S);
        };
        var C = j.css;
        return u(j, {
          css: function(a) {
            if (a) {
              var b = {},
                  a = E(a);
              p(j.textProps, function(c) {
                a[c] !== y && (b[c] = a[c], delete a[c]);
              });
              l.css(b);
            }
            return C.call(j, a);
          },
          getBBox: function() {
            return {
              width: n.width + 2 * z,
              height: n.height + 2 * z,
              x: n.x - z,
              y: n.y - z
            };
          },
          shadow: function(a) {
            m && m.shadow(a);
            return j;
          },
          destroy: function() {
            X(j.element, "mouseenter");
            X(j.element, "mouseleave");
            l && (l = l.destroy());
            m && (m = m.destroy());
            O.prototype.destroy.call(j);
            j = k = Ab = F = D = null;
          }
        });
      }
    };
    cb = Da;
    u(O.prototype, {
      htmlCss: function(a) {
        var b = this.element;
        if (b = a && b.tagName === "SPAN" && a.width)
          delete a.width, this.textWidth = b, this.updateTransform();
        if (a && a.textOverflow === "ellipsis")
          a.whiteSpace = "nowrap", a.overflow = "hidden";
        this.styles = u(this.styles, a);
        M(this.element, a);
        return this;
      },
      htmlGetBBox: function() {
        var a = this.element;
        if (a.nodeName === "text")
          a.style.position = "absolute";
        return {
          x: a.offsetLeft,
          y: a.offsetTop,
          width: a.offsetWidth,
          height: a.offsetHeight
        };
      },
      htmlUpdateTransform: function() {
        if (this.added) {
          var a = this.renderer,
              b = this.element,
              c = this.translateX || 0,
              d = this.translateY || 0,
              e = this.x || 0,
              f = this.y || 0,
              g = this.textAlign || "left",
              h = {
                left: 0,
                center: 0.5,
                right: 1
              }[g],
              i = this.shadows,
              k = this.styles;
          M(b, {
            marginLeft: c,
            marginTop: d
          });
          i && p(i, function(a) {
            M(a, {
              marginLeft: c + 1,
              marginTop: d + 1
            });
          });
          this.inverted && p(b.childNodes, function(c) {
            a.invertChild(c, b);
          });
          if (b.tagName === "SPAN") {
            var i = this.rotation,
                j = C(this.textWidth),
                l = k && k.whiteSpace,
                m = [i, g, b.innerHTML, this.textWidth, this.textAlign].join(",");
            if (m !== this.cTT) {
              k = a.fontMetrics(b.style.fontSize).b;
              r(i) && this.setSpanRotation(i, h, k);
              if (b.offsetWidth > j && /[ \-]/.test(b.textContent || b.innerText))
                M(b, {
                  width: j + "px",
                  display: "block",
                  whiteSpace: l || "normal"
                }), this.hasTextWidth = !0;
              else if (this.hasTextWidth)
                M(b, {
                  width: "",
                  display: "",
                  whiteSpace: l || "nowrap"
                }), this.hasTextWidth = !1;
              this.getSpanCorrection(this.hasTextWidth ? j : b.offsetWidth, k, h, i, g);
            }
            M(b, {
              left: e + (this.xCorr || 0) + "px",
              top: f + (this.yCorr || 0) + "px"
            });
            if (mb)
              k = b.offsetHeight;
            this.cTT = m;
          }
        } else
          this.alignOnAdd = !0;
      },
      setSpanRotation: function(a, b, c) {
        var d = {},
            e = ya ? "-ms-transform" : mb ? "-webkit-transform" : Na ? "MozTransform" : Kb ? "-o-transform" : "";
        d[e] = d.transform = "rotate(" + a + "deg)";
        d[e + (Na ? "Origin" : "-origin")] = d.transformOrigin = b * 100 + "% " + c + "px";
        M(this.element, d);
      },
      getSpanCorrection: function(a, b, c) {
        this.xCorr = -a * c;
        this.yCorr = -b;
      }
    });
    u(Da.prototype, {html: function(a, b, c) {
        var d = this.createElement("span"),
            e = d.element,
            f = d.renderer,
            g = f.isSVG,
            h = function(a, b) {
              p(["opacity", "visibility"], function(c) {
                fb(a, c + "Setter", function(a, c, d, e) {
                  a.call(this, c, d, e);
                  b[d] = c;
                });
              });
            };
        d.textSetter = function(a) {
          a !== e.innerHTML && delete this.bBox;
          e.innerHTML = this.textStr = a;
          d.htmlUpdateTransform();
        };
        g && h(d, d.element.style);
        d.xSetter = d.ySetter = d.alignSetter = d.rotationSetter = function(a, b) {
          b === "align" && (b = "textAlign");
          d[b] = a;
          d.htmlUpdateTransform();
        };
        d.attr({
          text: a,
          x: B(b),
          y: B(c)
        }).css({
          position: "absolute",
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize
        });
        e.style.whiteSpace = "nowrap";
        d.css = d.htmlCss;
        if (g)
          d.add = function(a) {
            var b,
                c = f.box.parentNode,
                g = [];
            if (this.parentGroup = a) {
              if (b = a.div, !b) {
                for (; a; )
                  g.push(a), a = a.parentGroup;
                p(g.reverse(), function(a) {
                  var d,
                      e = P(a.element, "class");
                  e && (e = {className: e});
                  b = a.div = a.div || ba(Ma, e, {
                    position: "absolute",
                    left: (a.translateX || 0) + "px",
                    top: (a.translateY || 0) + "px",
                    opacity: a.opacity
                  }, b || c);
                  d = b.style;
                  u(a, {
                    translateXSetter: function(b, c) {
                      d.left = b + "px";
                      a[c] = b;
                      a.doTransform = !0;
                    },
                    translateYSetter: function(b, c) {
                      d.top = b + "px";
                      a[c] = b;
                      a.doTransform = !0;
                    }
                  });
                  h(a, d);
                });
              }
            } else
              b = c;
            b.appendChild(e);
            d.added = !0;
            d.alignOnAdd && d.htmlUpdateTransform();
            return d;
          };
        return d;
      }});
    var K;
    if (!fa && !ka) {
      K = {
        init: function(a, b) {
          var c = ["<", b, ' filled="f" stroked="f"'],
              d = ["position: ", "absolute", ";"],
              e = b === Ma;
          (b === "shape" || e) && d.push("left:0;top:0;width:1px;height:1px;");
          d.push("visibility: ", e ? "hidden" : "visible");
          c.push(' style="', d.join(""), '"/>');
          if (b)
            c = e || b === "span" || b === "img" ? c.join("") : a.prepVML(c), this.element = ba(c);
          this.renderer = a;
        },
        add: function(a) {
          var b = this.renderer,
              c = this.element,
              d = b.box,
              e = a && a.inverted,
              d = a ? a.element || a : d;
          if (a)
            this.parentGroup = a;
          e && b.invertChild(c, d);
          d.appendChild(c);
          this.added = !0;
          this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform();
          if (this.onAdd)
            this.onAdd();
          return this;
        },
        updateTransform: O.prototype.htmlUpdateTransform,
        setSpanRotation: function() {
          var a = this.rotation,
              b = W(a * ja),
              c = da(a * ja);
          M(this.element, {filter: a ? ["progid:DXImageTransform.Microsoft.Matrix(M11=", b, ", M12=", -c, ", M21=", c, ", M22=", b, ", sizingMethod='auto expand')"].join("") : "none"});
        },
        getSpanCorrection: function(a, b, c, d, e) {
          var f = d ? W(d * ja) : 1,
              g = d ? da(d * ja) : 0,
              h = o(this.elemHeight, this.element.offsetHeight),
              i;
          this.xCorr = f < 0 && -a;
          this.yCorr = g < 0 && -h;
          i = f * g < 0;
          this.xCorr += g * b * (i ? 1 - c : c);
          this.yCorr -= f * b * (d ? i ? c : 1 - c : 1);
          e && e !== "left" && (this.xCorr -= a * c * (f < 0 ? -1 : 1), d && (this.yCorr -= h * c * (g < 0 ? -1 : 1)), M(this.element, {textAlign: e}));
        },
        pathToVML: function(a) {
          for (var b = a.length,
              c = []; b--; )
            if (J(a[b]))
              c[b] = B(a[b] * 10) - 5;
            else if (a[b] === "Z")
              c[b] = "x";
            else if (c[b] = a[b], a.isArc && (a[b] === "wa" || a[b] === "at"))
              c[b + 5] === c[b + 7] && (c[b + 7] += a[b + 7] > a[b + 5] ? 1 : -1), c[b + 6] === c[b + 8] && (c[b + 8] += a[b + 8] > a[b + 6] ? 1 : -1);
          return c.join(" ") || "x";
        },
        clip: function(a) {
          var b = this,
              c;
          a ? (c = a.members, pa(c, b), c.push(b), b.destroyClip = function() {
            pa(c, b);
          }, a = a.getCSS(b)) : (b.destroyClip && b.destroyClip(), a = {clip: lb ? "inherit" : "rect(auto)"});
          return b.css(a);
        },
        css: O.prototype.htmlCss,
        safeRemoveChild: function(a) {
          a.parentNode && Sa(a);
        },
        destroy: function() {
          this.destroyClip && this.destroyClip();
          return O.prototype.destroy.apply(this);
        },
        on: function(a, b) {
          this.element["on" + a] = function() {
            var a = D.event;
            a.target = a.srcElement;
            b(a);
          };
          return this;
        },
        cutOffPath: function(a, b) {
          var c,
              a = a.split(/[ ,]/);
          c = a.length;
          if (c === 9 || c === 11)
            a[c - 4] = a[c - 2] = C(a[c - 2]) - 10 * b;
          return a.join(" ");
        },
        shadow: function(a, b, c) {
          var d = [],
              e,
              f = this.element,
              g = this.renderer,
              h,
              i = f.style,
              k,
              j = f.path,
              l,
              m,
              n,
              q;
          j && typeof j.value !== "string" && (j = "x");
          m = j;
          if (a) {
            n = o(a.width, 3);
            q = (a.opacity || 0.15) / n;
            for (e = 1; e <= 3; e++) {
              l = n * 2 + 1 - 2 * e;
              c && (m = this.cutOffPath(j.value, l + 0.5));
              k = ['<shape isShadow="true" strokeweight="', l, '" filled="false" path="', m, '" coordsize="10 10" style="', f.style.cssText, '" />'];
              h = ba(g.prepVML(k), null, {
                left: C(i.left) + o(a.offsetX, 1),
                top: C(i.top) + o(a.offsetY, 1)
              });
              if (c)
                h.cutOff = l + 1;
              k = ['<stroke color="', a.color || "black", '" opacity="', q * e, '"/>'];
              ba(g.prepVML(k), null, null, h);
              b ? b.element.appendChild(h) : f.parentNode.insertBefore(h, f);
              d.push(h);
            }
            this.shadows = d;
          }
          return this;
        },
        updateShadows: Aa,
        setAttr: function(a, b) {
          lb ? this.element[a] = b : this.element.setAttribute(a, b);
        },
        classSetter: function(a) {
          this.element.className = a;
        },
        dashstyleSetter: function(a, b, c) {
          (c.getElementsByTagName("stroke")[0] || ba(this.renderer.prepVML(["<stroke/>"]), null, null, c))[b] = a || "solid";
          this[b] = a;
        },
        dSetter: function(a, b, c) {
          var d = this.shadows,
              a = a || [];
          this.d = a.join && a.join(" ");
          c.path = a = this.pathToVML(a);
          if (d)
            for (c = d.length; c--; )
              d[c].path = d[c].cutOff ? this.cutOffPath(a, d[c].cutOff) : a;
          this.setAttr(b, a);
        },
        fillSetter: function(a, b, c) {
          var d = c.nodeName;
          if (d === "SPAN")
            c.style.color = a;
          else if (d !== "IMG")
            c.filled = a !== "none", this.setAttr("fillcolor", this.renderer.color(a, c, b, this));
        },
        "fill-opacitySetter": function(a, b, c) {
          ba(this.renderer.prepVML(["<", b.split("-")[0], ' opacity="', a, '"/>']), null, null, c);
        },
        opacitySetter: Aa,
        rotationSetter: function(a, b, c) {
          c = c.style;
          this[b] = c[b] = a;
          c.left = -B(da(a * ja) + 1) + "px";
          c.top = B(W(a * ja)) + "px";
        },
        strokeSetter: function(a, b, c) {
          this.setAttr("strokecolor", this.renderer.color(a, c, b, this));
        },
        "stroke-widthSetter": function(a, b, c) {
          c.stroked = !!a;
          this[b] = a;
          J(a) && (a += "px");
          this.setAttr("strokeweight", a);
        },
        titleSetter: function(a, b) {
          this.setAttr(b, a);
        },
        visibilitySetter: function(a, b, c) {
          a === "inherit" && (a = "visible");
          this.shadows && p(this.shadows, function(c) {
            c.style[b] = a;
          });
          c.nodeName === "DIV" && (a = a === "hidden" ? "-999em" : 0, lb || (c.style[b] = a ? "visible" : "hidden"), b = "top");
          c.style[b] = a;
        },
        xSetter: function(a, b, c) {
          this[b] = a;
          b === "x" ? b = "left" : b === "y" && (b = "top");
          this.updateClipping ? (this[b] = a, this.updateClipping()) : c.style[b] = a;
        },
        zIndexSetter: function(a, b, c) {
          c.style[b] = a;
        }
      };
      K["stroke-opacitySetter"] = K["fill-opacitySetter"];
      x.VMLElement = K = qa(O, K);
      K.prototype.ySetter = K.prototype.widthSetter = K.prototype.heightSetter = K.prototype.xSetter;
      var Bb = {
        Element: K,
        isIE8: za.indexOf("MSIE 8.0") > -1,
        init: function(a, b, c, d) {
          var e;
          this.alignedObjects = [];
          d = this.createElement(Ma).css(u(this.getStyle(d), {position: "relative"}));
          e = d.element;
          a.appendChild(d.element);
          this.isVML = !0;
          this.box = e;
          this.boxWrapper = d;
          this.gradients = {};
          this.cache = {};
          this.cacheKeys = [];
          this.imgCount = 0;
          this.setSize(b, c, !1);
          if (!A.namespaces.hcv) {
            A.namespaces.add("hcv", "urn:schemas-microsoft-com:vml");
            try {
              A.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ";
            } catch (f) {
              A.styleSheets[0].cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ";
            }
          }
        },
        isHidden: function() {
          return !this.box.offsetWidth;
        },
        clipRect: function(a, b, c, d) {
          var e = this.createElement(),
              f = Z(a);
          return u(e, {
            members: [],
            count: 0,
            left: (f ? a.x : a) + 1,
            top: (f ? a.y : b) + 1,
            width: (f ? a.width : c) - 1,
            height: (f ? a.height : d) - 1,
            getCSS: function(a) {
              var b = a.element,
                  c = b.nodeName,
                  a = a.inverted,
                  d = this.top - (c === "shape" ? b.offsetTop : 0),
                  e = this.left,
                  b = e + this.width,
                  f = d + this.height,
                  d = {clip: "rect(" + B(a ? e : d) + "px," + B(a ? f : b) + "px," + B(a ? b : f) + "px," + B(a ? d : e) + "px)"};
              !a && lb && c === "DIV" && u(d, {
                width: b + "px",
                height: f + "px"
              });
              return d;
            },
            updateClipping: function() {
              p(e.members, function(a) {
                a.element && a.css(e.getCSS(a));
              });
            }
          });
        },
        color: function(a, b, c, d) {
          var e = this,
              f,
              g = /^rgba/,
              h,
              i,
              k = "none";
          a && a.linearGradient ? i = "gradient" : a && a.radialGradient && (i = "pattern");
          if (i) {
            var j,
                l,
                m = a.linearGradient || a.radialGradient,
                n,
                q,
                z,
                s,
                o,
                w = "",
                a = a.stops,
                v,
                S = [],
                r = function() {
                  h = ['<fill colors="' + S.join(",") + '" opacity="', z, '" o:opacity2="', q, '" type="', i, '" ', w, 'focus="100%" method="any" />'];
                  ba(e.prepVML(h), null, null, b);
                };
            n = a[0];
            v = a[a.length - 1];
            n[0] > 0 && a.unshift([0, n[1]]);
            v[0] < 1 && a.push([1, v[1]]);
            p(a, function(a, b) {
              g.test(a[1]) ? (f = ma(a[1]), j = f.get("rgb"), l = f.get("a")) : (j = a[1], l = 1);
              S.push(a[0] * 100 + "% " + j);
              b ? (z = l, s = j) : (q = l, o = j);
            });
            if (c === "fill")
              if (i === "gradient")
                c = m.x1 || m[0] || 0, a = m.y1 || m[1] || 0, n = m.x2 || m[2] || 0, m = m.y2 || m[3] || 0, w = 'angle="' + (90 - Y.atan((m - a) / (n - c)) * 180 / ra) + '"', r();
              else {
                var k = m.r,
                    $ = k * 2,
                    t = k * 2,
                    u = m.cx,
                    y = m.cy,
                    B = b.radialReference,
                    x,
                    k = function() {
                      B && (x = d.getBBox(), u += (B[0] - x.x) / x.width - 0.5, y += (B[1] - x.y) / x.height - 0.5, $ *= B[2] / x.width, t *= B[2] / x.height);
                      w = 'src="' + U.global.VMLRadialGradientURL + '" size="' + $ + "," + t + '" origin="0.5,0.5" position="' + u + "," + y + '" color2="' + o + '" ';
                      r();
                    };
                d.added ? k() : d.onAdd = k;
                k = s;
              }
            else
              k = j;
          } else if (g.test(a) && b.tagName !== "IMG")
            f = ma(a), d[c + "-opacitySetter"](f.get("a"), c, b), k = f.get("rgb");
          else {
            k = b.getElementsByTagName(c);
            if (k.length)
              k[0].opacity = 1, k[0].type = "solid";
            k = a;
          }
          return k;
        },
        prepVML: function(a) {
          var b = this.isIE8,
              a = a.join("");
          b ? (a = a.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'), a = a.indexOf('style="') === -1 ? a.replace("/>", ' style="display:inline-block;behavior:url(#default#VML);" />') : a.replace('style="', 'style="display:inline-block;behavior:url(#default#VML);')) : a = a.replace("<", "<hcv:");
          return a;
        },
        text: Da.prototype.html,
        path: function(a) {
          var b = {coordsize: "10 10"};
          Ea(a) ? b.d = a : Z(a) && u(b, a);
          return this.createElement("shape").attr(b);
        },
        circle: function(a, b, c) {
          var d = this.symbol("circle");
          if (Z(a))
            c = a.r, b = a.y, a = a.x;
          d.isCircle = !0;
          d.r = c;
          return d.attr({
            x: a,
            y: b
          });
        },
        g: function(a) {
          var b;
          a && (b = {
            className: "highcharts-" + a,
            "class": "highcharts-" + a
          });
          return this.createElement(Ma).attr(b);
        },
        image: function(a, b, c, d, e) {
          var f = this.createElement("img").attr({src: a});
          arguments.length > 1 && f.attr({
            x: b,
            y: c,
            width: d,
            height: e
          });
          return f;
        },
        createElement: function(a) {
          return a === "rect" ? this.symbol(a) : Da.prototype.createElement.call(this, a);
        },
        invertChild: function(a, b) {
          var c = this,
              d = b.style,
              e = a.tagName === "IMG" && a.style;
          M(a, {
            flip: "x",
            left: C(d.width) - (e ? C(e.top) : 1),
            top: C(d.height) - (e ? C(e.left) : 1),
            rotation: -90
          });
          p(a.childNodes, function(b) {
            c.invertChild(b, a);
          });
        },
        symbols: {
          arc: function(a, b, c, d, e) {
            var f = e.start,
                g = e.end,
                h = e.r || c || d,
                c = e.innerR,
                d = W(f),
                i = da(f),
                k = W(g),
                j = da(g);
            if (g - f === 0)
              return ["x"];
            f = ["wa", a - h, b - h, a + h, b + h, a + h * d, b + h * i, a + h * k, b + h * j];
            e.open && !c && f.push("e", "M", a, b);
            f.push("at", a - c, b - c, a + c, b + c, a + c * k, b + c * j, a + c * d, b + c * i, "x", "e");
            f.isArc = !0;
            return f;
          },
          circle: function(a, b, c, d, e) {
            e && (c = d = 2 * e.r);
            e && e.isCircle && (a -= c / 2, b -= d / 2);
            return ["wa", a, b, a + c, b + d, a + c, b + d / 2, a + c, b + d / 2, "e"];
          },
          rect: function(a, b, c, d, e) {
            return Da.prototype.symbols[!r(e) || !e.r ? "square" : "callout"].call(0, a, b, c, d, e);
          }
        }
      };
      x.VMLRenderer = K = function() {
        this.init.apply(this, arguments);
      };
      K.prototype = E(Da.prototype, Bb);
      cb = K;
    }
    Da.prototype.measureSpanWidth = function(a, b) {
      var c = A.createElement("span"),
          d;
      d = A.createTextNode(a);
      c.appendChild(d);
      M(c, b);
      this.box.appendChild(c);
      d = c.offsetWidth;
      Sa(c);
      return d;
    };
    var Nb;
    if (ka)
      x.CanVGRenderer = K = function() {
        Ha = "http://www.w3.org/1999/xhtml";
      }, K.prototype.symbols = {}, Nb = function() {
        function a() {
          var a = b.length,
              d;
          for (d = 0; d < a; d++)
            b[d]();
          b = [];
        }
        var b = [];
        return {push: function(c, d) {
            if (b.length === 0) {
              var e = A.getElementsByTagName("head")[0],
                  f = A.createElement("script");
              f.type = "text/javascript";
              f.src = d;
              f.onload = a;
              e.appendChild(f);
            }
            b.push(c);
          }};
      }(), cb = K;
    Va.prototype = {
      addLabel: function() {
        var a = this.axis,
            b = a.options,
            c = a.chart,
            d = a.categories,
            e = a.names,
            f = this.pos,
            g = b.labels,
            h = a.tickPositions,
            i = f === h[0],
            k = f === h[h.length - 1],
            e = d ? o(d[f], e[f], f) : f,
            d = this.label,
            h = h.info,
            j;
        a.isDatetimeAxis && h && (j = b.dateTimeLabelFormats[h.higherRanks[f] || h.unitName]);
        this.isFirst = i;
        this.isLast = k;
        b = a.labelFormatter.call({
          axis: a,
          chart: c,
          isFirst: i,
          isLast: k,
          dateTimeLabelFormat: j,
          value: a.isLog ? ca(a.lin2log(e)) : e
        });
        r(d) ? d && d.attr({text: b}) : (this.labelLength = (this.label = d = r(b) && g.enabled ? c.renderer.text(b, 0, 0, g.useHTML).css(E(g.style)).add(a.labelGroup) : null) && d.getBBox().width, this.rotation = 0);
      },
      getLabelSize: function() {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
      },
      handleOverflow: function(a) {
        var b = this.axis,
            c = a.x,
            d = b.chart.chartWidth,
            e = b.chart.spacing,
            f = o(b.labelLeft, F(b.pos, e[3])),
            e = o(b.labelRight, t(b.pos + b.len, d - e[1])),
            g = this.label,
            h = this.rotation,
            i = {
              left: 0,
              center: 0.5,
              right: 1
            }[b.labelAlign],
            k = g.getBBox().width,
            j = b.getSlotWidth(),
            l = j,
            m = 1,
            n,
            q = {};
        if (h)
          h < 0 && c - i * k < f ? n = B(c / W(h * ja) - f) : h > 0 && c + i * k > e && (n = B((d - c) / W(h * ja)));
        else if (d = c + (1 - i) * k, c - i * k < f ? l = a.x + l * (1 - i) - f : d > e && (l = e - a.x + l * i, m = -1), l = F(j, l), l < j && b.labelAlign === "center" && (a.x += m * (j - l - i * (j - F(k, l)))), k > l || b.autoRotation && g.styles.width)
          n = l;
        if (n) {
          q.width = n;
          if (!b.options.labels.style.textOverflow)
            q.textOverflow = "ellipsis";
          g.css(q);
        }
      },
      getPosition: function(a, b, c, d) {
        var e = this.axis,
            f = e.chart,
            g = d && f.oldChartHeight || f.chartHeight;
        return {
          x: a ? e.translate(b + c, null, null, d) + e.transB : e.left + e.offset + (e.opposite ? (d && f.oldChartWidth || f.chartWidth) - e.right - e.left : 0),
          y: a ? g - e.bottom + e.offset - (e.opposite ? e.height : 0) : g - e.translate(b + c, null, null, d) - e.transB
        };
      },
      getLabelPosition: function(a, b, c, d, e, f, g, h) {
        var i = this.axis,
            k = i.transA,
            j = i.reversed,
            l = i.staggerLines,
            m = i.tickRotCorr || {
              x: 0,
              y: 0
            },
            n = e.y;
        r(n) || (n = i.side === 0 ? c.rotation ? -8 : -c.getBBox().height : i.side === 2 ? m.y + 8 : W(c.rotation * ja) * (m.y - c.getBBox(!1, 0).height / 2));
        a = a + e.x + m.x - (f && d ? f * k * (j ? -1 : 1) : 0);
        b = b + n - (f && !d ? f * k * (j ? 1 : -1) : 0);
        l && (c = g / (h || 1) % l, i.opposite && (c = l - c - 1), b += c * (i.labelOffset / l));
        return {
          x: a,
          y: B(b)
        };
      },
      getMarkPath: function(a, b, c, d, e, f) {
        return f.crispLine(["M", a, b, "L", a + (e ? 0 : -c), b + (e ? c : 0)], d);
      },
      render: function(a, b, c) {
        var d = this.axis,
            e = d.options,
            f = d.chart.renderer,
            g = d.horiz,
            h = this.type,
            i = this.label,
            k = this.pos,
            j = e.labels,
            l = this.gridLine,
            m = h ? h + "Grid" : "grid",
            n = h ? h + "Tick" : "tick",
            q = e[m + "LineWidth"],
            z = e[m + "LineColor"],
            s = e[m + "LineDashStyle"],
            m = d.tickSize(n),
            n = e[n + "Color"],
            p = this.mark,
            w = j.step,
            v = !0,
            S = d.tickmarkOffset,
            r = this.getPosition(g, k, S, b),
            $ = r.x,
            r = r.y,
            t = g && $ === d.pos + d.len || !g && r === d.pos ? -1 : 1,
            c = o(c, 1);
        this.isActive = !0;
        if (q) {
          k = d.getPlotLinePath(k + S, q * t, b, !0);
          if (l === y) {
            l = {
              stroke: z,
              "stroke-width": q
            };
            if (s)
              l.dashstyle = s;
            if (!h)
              l.zIndex = 1;
            if (b)
              l.opacity = 0;
            this.gridLine = l = q ? f.path(k).attr(l).add(d.gridGroup) : null;
          }
          if (!b && l && k)
            l[this.isNew ? "attr" : "animate"]({
              d: k,
              opacity: c
            });
        }
        if (m)
          d.opposite && (m[0] = -m[0]), h = this.getMarkPath($, r, m[0], m[1] * t, g, f), p ? p.animate({
            d: h,
            opacity: c
          }) : this.mark = f.path(h).attr({
            stroke: n,
            "stroke-width": m[1],
            opacity: c
          }).add(d.axisGroup);
        if (i && J($))
          i.xy = r = this.getLabelPosition($, r, i, g, j, S, a, w), this.isFirst && !this.isLast && !o(e.showFirstLabel, 1) || this.isLast && !this.isFirst && !o(e.showLastLabel, 1) ? v = !1 : g && !d.isRadial && !j.step && !j.rotation && !b && c !== 0 && this.handleOverflow(r), w && a % w && (v = !1), v && J(r.y) ? (r.opacity = c, i[this.isNew ? "attr" : "animate"](r), this.isNew = !1) : i.attr("y", -9999);
      },
      destroy: function() {
        Ra(this, this.axis);
      }
    };
    x.PlotLineOrBand = function(a, b) {
      this.axis = a;
      if (b)
        this.options = b, this.id = b.id;
    };
    x.PlotLineOrBand.prototype = {
      render: function() {
        var a = this,
            b = a.axis,
            c = b.horiz,
            d = a.options,
            e = d.label,
            f = a.label,
            g = d.width,
            h = d.to,
            i = d.from,
            k = r(i) && r(h),
            j = d.value,
            l = d.dashStyle,
            m = a.svgElem,
            n = [],
            q,
            z = d.color,
            s = o(d.zIndex, 0),
            p = d.events,
            w = {},
            v = b.chart.renderer,
            n = b.log2lin;
        b.isLog && (i = n(i), h = n(h), j = n(j));
        if (g) {
          if (n = b.getPlotLinePath(j, g), w = {
            stroke: z,
            "stroke-width": g
          }, l)
            w.dashstyle = l;
        } else if (k) {
          n = b.getPlotBandPath(i, h, d);
          if (z)
            w.fill = z;
          if (d.borderWidth)
            w.stroke = d.borderColor, w["stroke-width"] = d.borderWidth;
        } else
          return;
        w.zIndex = s;
        if (m)
          if (n)
            m.show(), m.animate({d: n});
          else {
            if (m.hide(), f)
              a.label = f = f.destroy();
          }
        else if (n && n.length && (a.svgElem = m = v.path(n).attr(w).add(), p))
          for (q in d = function(b) {
            m.on(b, function(c) {
              p[b].apply(a, [c]);
            });
          }, p)
            d(q);
        e && r(e.text) && n && n.length && b.width > 0 && b.height > 0 && !n.flat ? (e = E({
          align: c && k && "center",
          x: c ? !k && 4 : 10,
          verticalAlign: !c && k && "middle",
          y: c ? k ? 16 : 10 : k ? 6 : -4,
          rotation: c && !k && 90
        }, e), this.renderLabel(e, n, k, s)) : f && f.hide();
        return a;
      },
      renderLabel: function(a, b, c, d) {
        var e = this.label,
            f = this.axis.chart.renderer;
        if (!e)
          e = {
            align: a.textAlign || a.align,
            rotation: a.rotation
          }, e.zIndex = d, this.label = e = f.text(a.text, 0, 0, a.useHTML).attr(e).css(a.style).add();
        d = [b[1], b[4], c ? b[6] : b[1]];
        b = [b[2], b[5], c ? b[7] : b[2]];
        c = La(d);
        f = La(b);
        e.align(a, !1, {
          x: c,
          y: f,
          width: Ga(d) - c,
          height: Ga(b) - f
        });
        e.show();
      },
      destroy: function() {
        pa(this.axis.plotLinesAndBands, this);
        delete this.axis;
        Ra(this);
      }
    };
    var ha = x.Axis = function() {
      this.init.apply(this, arguments);
    };
    ha.prototype = {
      defaultOptions: {
        dateTimeLabelFormats: {
          millisecond: "%H:%M:%S.%L",
          second: "%H:%M:%S",
          minute: "%H:%M",
          hour: "%H:%M",
          day: "%e. %b",
          week: "%e. %b",
          month: "%b '%y",
          year: "%Y"
        },
        endOnTick: !1,
        gridLineColor: "#D8D8D8",
        labels: {
          enabled: !0,
          style: {
            color: "#606060",
            cursor: "default",
            fontSize: "11px"
          },
          x: 0
        },
        lineColor: "#C0D0E0",
        lineWidth: 1,
        minPadding: 0.01,
        maxPadding: 0.01,
        minorGridLineColor: "#E0E0E0",
        minorGridLineWidth: 1,
        minorTickColor: "#A0A0A0",
        minorTickLength: 2,
        minorTickPosition: "outside",
        startOfWeek: 1,
        startOnTick: !1,
        tickColor: "#C0D0E0",
        tickLength: 10,
        tickmarkPlacement: "between",
        tickPixelInterval: 100,
        tickPosition: "outside",
        title: {
          align: "middle",
          style: {color: "#707070"}
        },
        type: "linear"
      },
      defaultYAxisOptions: {
        endOnTick: !0,
        gridLineWidth: 1,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {x: -8},
        lineWidth: 0,
        maxPadding: 0.05,
        minPadding: 0.05,
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          enabled: !1,
          formatter: function() {
            return x.numberFormat(this.total, -1);
          },
          style: E(ea.line.dataLabels.style, {color: "#000000"})
        }
      },
      defaultLeftAxisOptions: {
        labels: {x: -15},
        title: {rotation: 270}
      },
      defaultRightAxisOptions: {
        labels: {x: 15},
        title: {rotation: 90}
      },
      defaultBottomAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        title: {rotation: 0}
      },
      defaultTopAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        title: {rotation: 0}
      },
      init: function(a, b) {
        var c = b.isX;
        this.chart = a;
        this.horiz = a.inverted ? !c : c;
        this.coll = (this.isXAxis = c) ? "xAxis" : "yAxis";
        this.opposite = b.opposite;
        this.side = b.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
        this.setOptions(b);
        var d = this.options,
            e = d.type;
        this.labelFormatter = d.labels.formatter || this.defaultLabelFormatter;
        this.userOptions = b;
        this.minPixelPadding = 0;
        this.reversed = d.reversed;
        this.visible = d.visible !== !1;
        this.zoomEnabled = d.zoomEnabled !== !1;
        this.categories = d.categories || e === "category";
        this.names = this.names || [];
        this.isLog = e === "logarithmic";
        this.isDatetimeAxis = e === "datetime";
        this.isLinked = r(d.linkedTo);
        this.ticks = {};
        this.labelEdge = [];
        this.minorTicks = {};
        this.plotLinesAndBands = [];
        this.alternateBands = {};
        this.len = 0;
        this.minRange = this.userMinRange = d.minRange || d.maxZoom;
        this.range = d.range;
        this.offset = d.offset || 0;
        this.stacks = {};
        this.oldStacks = {};
        this.stacksTouched = 0;
        this.min = this.max = null;
        this.crosshair = o(d.crosshair, ta(a.options.tooltip.crosshairs)[c ? 0 : 1], !1);
        var f,
            d = this.options.events;
        sa(this, a.axes) === -1 && (c && !this.isColorAxis ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this), a[this.coll].push(this));
        this.series = this.series || [];
        if (a.inverted && c && this.reversed === y)
          this.reversed = !0;
        this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine;
        for (f in d)
          N(this, f, d[f]);
        if (this.isLog)
          this.val2lin = this.log2lin, this.lin2val = this.lin2log;
      },
      setOptions: function(a) {
        this.options = E(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], E(U[this.coll], a));
      },
      defaultLabelFormatter: function() {
        var a = this.axis,
            b = this.value,
            c = a.categories,
            d = this.dateTimeLabelFormat,
            e = U.lang.numericSymbols,
            f = e && e.length,
            g,
            h = a.options.labels.format,
            a = a.isLog ? b : a.tickInterval;
        if (h)
          g = Ka(h, this);
        else if (c)
          g = b;
        else if (d)
          g = Qa(d, b);
        else if (f && a >= 1E3)
          for (; f-- && g === y; )
            c = Math.pow(1E3, f + 1), a >= c && b * 10 % c === 0 && e[f] !== null && (g = x.numberFormat(b / c, -1) + e[f]);
        g === y && (g = Q(b) >= 1E4 ? x.numberFormat(b, -1) : x.numberFormat(b, -1, y, ""));
        return g;
      },
      getSeriesExtremes: function() {
        var a = this,
            b = a.chart;
        a.hasVisibleSeries = !1;
        a.dataMin = a.dataMax = a.threshold = null;
        a.softThreshold = !a.isXAxis;
        a.buildStacks && a.buildStacks();
        p(a.series, function(c) {
          if (c.visible || !b.options.chart.ignoreHiddenSeries) {
            var d = c.options,
                e = d.threshold,
                f;
            a.hasVisibleSeries = !0;
            a.isLog && e <= 0 && (e = null);
            if (a.isXAxis) {
              if (d = c.xData, d.length)
                c = La(d), !J(c) && !(c instanceof la) && (d = Ba(d, function(a) {
                  return J(a);
                }), c = La(d)), a.dataMin = F(o(a.dataMin, d[0]), c), a.dataMax = t(o(a.dataMax, d[0]), Ga(d));
            } else {
              c.getExtremes();
              f = c.dataMax;
              c = c.dataMin;
              if (r(c) && r(f))
                a.dataMin = F(o(a.dataMin, c), c), a.dataMax = t(o(a.dataMax, f), f);
              if (r(e))
                a.threshold = e;
              if (!d.softThreshold || a.isLog)
                a.softThreshold = !1;
            }
          }
        });
      },
      translate: function(a, b, c, d, e, f) {
        var g = this.linkedParent || this,
            h = 1,
            i = 0,
            k = d ? g.oldTransA : g.transA,
            d = d ? g.oldMin : g.min,
            j = g.minPixelPadding,
            e = (g.isOrdinal || g.isBroken || g.isLog && e) && g.lin2val;
        if (!k)
          k = g.transA;
        if (c)
          h *= -1, i = g.len;
        g.reversed && (h *= -1, i -= h * (g.sector || g.len));
        b ? (a = a * h + i, a -= j, a = a / k + d, e && (a = g.lin2val(a))) : (e && (a = g.val2lin(a)), f === "between" && (f = 0.5), a = h * (a - d) * k + i + h * j + (J(f) ? k * f * g.pointRange : 0));
        return a;
      },
      toPixels: function(a, b) {
        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
      },
      toValue: function(a, b) {
        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
      },
      getPlotLinePath: function(a, b, c, d, e) {
        var f = this.chart,
            g = this.left,
            h = this.top,
            i,
            k,
            j = c && f.oldChartHeight || f.chartHeight,
            l = c && f.oldChartWidth || f.chartWidth,
            m;
        i = this.transB;
        var n = function(a, b, c) {
          if (a < b || a > c)
            d ? a = F(t(b, a), c) : m = !0;
          return a;
        },
            e = o(e, this.translate(a, null, null, c)),
            a = c = B(e + i);
        i = k = B(j - e - i);
        J(e) ? this.horiz ? (i = h, k = j - this.bottom, a = c = n(a, g, g + this.width)) : (a = g, c = l - this.right, i = k = n(i, h, h + this.height)) : m = !0;
        return m && !d ? null : f.renderer.crispLine(["M", a, i, "L", c, k], b || 1);
      },
      getLinearTickPositions: function(a, b, c) {
        var d,
            e = ca(V(b / a) * a),
            f = ca(ua(c / a) * a),
            g = [];
        if (b === c && J(b))
          return [b];
        for (b = e; b <= f; ) {
          g.push(b);
          b = ca(b + a);
          if (b === d)
            break;
          d = b;
        }
        return g;
      },
      getMinorTickPositions: function() {
        var a = this.options,
            b = this.tickPositions,
            c = this.minorTickInterval,
            d = [],
            e,
            f = this.pointRangePadding || 0;
        e = this.min - f;
        var f = this.max + f,
            g = f - e;
        if (g && g / c < this.len / 3)
          if (this.isLog) {
            f = b.length;
            for (e = 1; e < f; e++)
              d = d.concat(this.getLogTickPositions(c, b[e - 1], b[e], !0));
          } else if (this.isDatetimeAxis && a.minorTickInterval === "auto")
            d = d.concat(this.getTimeTicks(this.normalizeTimeTickInterval(c), e, f, a.startOfWeek));
          else
            for (b = e + (b[0] - e) % c; b <= f; b += c)
              d.push(b);
        d.length !== 0 && this.trimTicks(d, a.startOnTick, a.endOnTick);
        return d;
      },
      adjustForMinRange: function() {
        var a = this.options,
            b = this.min,
            c = this.max,
            d,
            e = this.dataMax - this.dataMin >= this.minRange,
            f,
            g,
            h,
            i,
            k,
            j;
        if (this.isXAxis && this.minRange === y && !this.isLog)
          r(a.min) || r(a.max) ? this.minRange = null : (p(this.series, function(a) {
            i = a.xData;
            for (g = k = a.xIncrement ? 1 : i.length - 1; g > 0; g--)
              if (h = i[g] - i[g - 1], f === y || h < f)
                f = h;
          }), this.minRange = F(f * 5, this.dataMax - this.dataMin));
        if (c - b < this.minRange) {
          j = this.minRange;
          d = (j - c + b) / 2;
          d = [b - d, o(a.min, b - d)];
          if (e)
            d[2] = this.dataMin;
          b = Ga(d);
          c = [b + j, o(a.max, b + j)];
          if (e)
            c[2] = this.dataMax;
          c = La(c);
          c - b < j && (d[0] = c - j, d[1] = o(a.min, c - j), b = Ga(d));
        }
        this.min = b;
        this.max = c;
      },
      getClosest: function() {
        var a;
        p(this.series, function(b) {
          var c = b.closestPointRange;
          !b.noSharedTooltip && r(c) && (a = r(a) ? F(a, c) : c);
        });
        return a;
      },
      setAxisTranslation: function(a) {
        var b = this,
            c = b.max - b.min,
            d = b.axisPointRange || 0,
            e,
            f = 0,
            g = 0,
            h = b.linkedParent,
            i = !!b.categories,
            k = b.transA,
            j = b.isXAxis;
        if (j || i || d)
          if (h ? (f = h.minPointOffset, g = h.pointRangePadding) : (e = b.getClosest(), p(b.series, function(a) {
            var c = i ? 1 : j ? o(a.options.pointRange, e, 0) : b.axisPointRange || 0,
                a = a.options.pointPlacement;
            d = t(d, c);
            b.single || (f = t(f, xa(a) ? 0 : c / 2), g = t(g, a === "on" ? 0 : c));
          })), h = b.ordinalSlope && e ? b.ordinalSlope / e : 1, b.minPointOffset = f *= h, b.pointRangePadding = g *= h, b.pointRange = F(d, c), j)
            b.closestPointRange = e;
        if (a)
          b.oldTransA = k;
        b.translationSlope = b.transA = k = b.len / (c + g || 1);
        b.transB = b.horiz ? b.left : b.bottom;
        b.minPixelPadding = k * f;
      },
      minFromRange: function() {
        return this.max - this.range;
      },
      setTickInterval: function(a) {
        var b = this,
            c = b.chart,
            d = b.options,
            e = b.isLog,
            f = b.log2lin,
            g = b.isDatetimeAxis,
            h = b.isXAxis,
            i = b.isLinked,
            k = d.maxPadding,
            j = d.minPadding,
            l = d.tickInterval,
            m = d.tickPixelInterval,
            n = b.categories,
            q = b.threshold,
            z = b.softThreshold,
            s,
            G,
            w,
            v;
        !g && !n && !i && this.getTickAmount();
        w = o(b.userMin, d.min);
        v = o(b.userMax, d.max);
        i ? (b.linkedParent = c[b.coll][d.linkedTo], c = b.linkedParent.getExtremes(), b.min = o(c.min, c.dataMin), b.max = o(c.max, c.dataMax), d.type !== b.linkedParent.options.type && aa(11, 1)) : (!z && r(q) && (b.dataMin >= q ? (s = q, j = 0) : b.dataMax <= q && (G = q, k = 0)), b.min = o(w, s, b.dataMin), b.max = o(v, G, b.dataMax));
        if (e)
          !a && F(b.min, o(b.dataMin, b.min)) <= 0 && aa(10, 1), b.min = ca(f(b.min), 15), b.max = ca(f(b.max), 15);
        if (b.range && r(b.max))
          b.userMin = b.min = w = t(b.min, b.minFromRange()), b.userMax = v = b.max, b.range = null;
        I(b, "foundExtremes");
        b.beforePadding && b.beforePadding();
        b.adjustForMinRange();
        if (!n && !b.axisPointRange && !b.usePercentage && !i && r(b.min) && r(b.max) && (f = b.max - b.min))
          !r(w) && j && (b.min -= f * j), !r(v) && k && (b.max += f * k);
        if (J(d.floor))
          b.min = t(b.min, d.floor);
        if (J(d.ceiling))
          b.max = F(b.max, d.ceiling);
        if (z && r(b.dataMin))
          if (q = q || 0, !r(w) && b.min < q && b.dataMin >= q)
            b.min = q;
          else if (!r(v) && b.max > q && b.dataMax <= q)
            b.max = q;
        b.tickInterval = b.min === b.max || b.min === void 0 || b.max === void 0 ? 1 : i && !l && m === b.linkedParent.options.tickPixelInterval ? l = b.linkedParent.tickInterval : o(l, this.tickAmount ? (b.max - b.min) / t(this.tickAmount - 1, 1) : void 0, n ? 1 : (b.max - b.min) * m / t(b.len, m));
        h && !a && p(b.series, function(a) {
          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);
        });
        b.setAxisTranslation(!0);
        b.beforeSetTickPositions && b.beforeSetTickPositions();
        if (b.postProcessTickInterval)
          b.tickInterval = b.postProcessTickInterval(b.tickInterval);
        if (b.pointRange && !l)
          b.tickInterval = t(b.pointRange, b.tickInterval);
        a = o(d.minTickInterval, b.isDatetimeAxis && b.closestPointRange);
        if (!l && b.tickInterval < a)
          b.tickInterval = a;
        if (!g && !e && !l)
          b.tickInterval = sb(b.tickInterval, null, rb(b.tickInterval), o(d.allowDecimals, !(b.tickInterval > 0.5 && b.tickInterval < 5 && b.max > 1E3 && b.max < 9999)), !!this.tickAmount);
        if (!this.tickAmount && this.len)
          b.tickInterval = b.unsquish();
        this.setTickPositions();
      },
      setTickPositions: function() {
        var a = this.options,
            b,
            c = a.tickPositions,
            d = a.tickPositioner,
            e = a.startOnTick,
            f = a.endOnTick,
            g;
        this.tickmarkOffset = this.categories && a.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;
        this.minorTickInterval = a.minorTickInterval === "auto" && this.tickInterval ? this.tickInterval / 5 : a.minorTickInterval;
        this.tickPositions = b = c && c.slice();
        if (!b && (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()]), this.tickPositions = b, d && (d = d.apply(this, [this.min, this.max]))))
          this.tickPositions = b = d;
        if (!this.isLinked)
          this.trimTicks(b, e, f), this.min === this.max && r(this.min) && !this.tickAmount && (g = !0, this.min -= 0.5, this.max += 0.5), this.single = g, !c && !d && this.adjustTickAmount();
      },
      trimTicks: function(a, b, c) {
        var d = a[0],
            e = a[a.length - 1],
            f = this.minPointOffset || 0;
        if (b)
          this.min = d;
        else
          for (; this.min - f > a[0]; )
            a.shift();
        if (c)
          this.max = e;
        else
          for (; this.max + f < a[a.length - 1]; )
            a.pop();
        a.length === 0 && r(d) && a.push((e + d) / 2);
      },
      alignToOthers: function() {
        var a = {},
            b,
            c = this.options;
        this.chart.options.chart.alignTicks !== !1 && c.alignTicks !== !1 && p(this.chart[this.coll], function(c) {
          var e = c.options,
              e = [c.horiz ? e.left : e.top, e.width, e.height, e.pane].join(",");
          c.series.length && (a[e] ? b = !0 : a[e] = 1);
        });
        return b;
      },
      getTickAmount: function() {
        var a = this.options,
            b = a.tickAmount,
            c = a.tickPixelInterval;
        !r(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);
        !b && this.alignToOthers() && (b = ua(this.len / c) + 1);
        if (b < 4)
          this.finalTickAmt = b, b = 5;
        this.tickAmount = b;
      },
      adjustTickAmount: function() {
        var a = this.tickInterval,
            b = this.tickPositions,
            c = this.tickAmount,
            d = this.finalTickAmt,
            e = b && b.length;
        if (e < c) {
          for (; b.length < c; )
            b.push(ca(b[b.length - 1] + a));
          this.transA *= (e - 1) / (c - 1);
          this.max = b[b.length - 1];
        } else
          e > c && (this.tickInterval *= 2, this.setTickPositions());
        if (r(d)) {
          for (a = c = b.length; a--; )
            (d === 3 && a % 2 === 1 || d <= 2 && a > 0 && a < c - 1) && b.splice(a, 1);
          this.finalTickAmt = y;
        }
      },
      setScale: function() {
        var a,
            b;
        this.oldMin = this.min;
        this.oldMax = this.max;
        this.oldAxisLength = this.len;
        this.setAxisSize();
        b = this.len !== this.oldAxisLength;
        p(this.series, function(b) {
          if (b.isDirtyData || b.isDirty || b.xAxis.isDirty)
            a = !0;
        });
        if (b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers()) {
          if (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, !this.isDirty)
            this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax;
        } else
          this.cleanStacks && this.cleanStacks();
      },
      setExtremes: function(a, b, c, d, e) {
        var f = this,
            g = f.chart,
            c = o(c, !0);
        p(f.series, function(a) {
          delete a.kdTree;
        });
        e = u(e, {
          min: a,
          max: b
        });
        I(f, "setExtremes", e, function() {
          f.userMin = a;
          f.userMax = b;
          f.eventArgs = e;
          c && g.redraw(d);
        });
      },
      zoom: function(a, b) {
        var c = this.dataMin,
            d = this.dataMax,
            e = this.options,
            f = F(c, o(e.min, c)),
            e = t(d, o(e.max, d));
        this.allowZoomOutside || (r(c) && a <= f && (a = f), r(d) && b >= e && (b = e));
        this.displayBtn = a !== y || b !== y;
        this.setExtremes(a, b, !1, y, {trigger: "zoom"});
        return !0;
      },
      setAxisSize: function() {
        var a = this.chart,
            b = this.options,
            c = b.offsetLeft || 0,
            d = this.horiz,
            e = o(b.width, a.plotWidth - c + (b.offsetRight || 0)),
            f = o(b.height, a.plotHeight),
            g = o(b.top, a.plotTop),
            b = o(b.left, a.plotLeft + c),
            c = /%$/;
        c.test(f) && (f = Math.round(parseFloat(f) / 100 * a.plotHeight));
        c.test(g) && (g = Math.round(parseFloat(g) / 100 * a.plotHeight + a.plotTop));
        this.left = b;
        this.top = g;
        this.width = e;
        this.height = f;
        this.bottom = a.chartHeight - f - g;
        this.right = a.chartWidth - e - b;
        this.len = t(d ? e : f, 0);
        this.pos = d ? b : g;
      },
      getExtremes: function() {
        var a = this.isLog,
            b = this.lin2log;
        return {
          min: a ? ca(b(this.min)) : this.min,
          max: a ? ca(b(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        };
      },
      getThreshold: function(a) {
        var b = this.isLog,
            c = this.lin2log,
            d = b ? c(this.min) : this.min,
            b = b ? c(this.max) : this.max;
        a === null ? a = b < 0 ? b : d : d > a ? a = d : b < a && (a = b);
        return this.translate(a, 0, 1, 0, 1);
      },
      autoLabelAlign: function(a) {
        a = (o(a, 0) - this.side * 90 + 720) % 360;
        return a > 15 && a < 165 ? "right" : a > 195 && a < 345 ? "left" : "center";
      },
      tickSize: function(a) {
        var b = this.options,
            c = b[a + "Length"],
            d = o(b[a + "Width"], a === "tick" && this.isXAxis ? 1 : 0);
        if (d && c)
          return b[a + "Position"] === "inside" && (c = -c), [c, d];
      },
      labelMetrics: function() {
        return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[0] && this.ticks[0].label);
      },
      unsquish: function() {
        var a = this.options.labels,
            b = this.horiz,
            c = this.tickInterval,
            d = c,
            e = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c),
            f,
            g = a.rotation,
            h = this.labelMetrics(),
            i,
            k = Number.MAX_VALUE,
            j,
            l = function(a) {
              a /= e || 1;
              a = a > 1 ? ua(a) : 1;
              return a * c;
            };
        b ? (j = !a.staggerLines && !a.step && (r(g) ? [g] : e < o(a.autoRotationLimit, 80) && a.autoRotation)) && p(j, function(a) {
          var b;
          if (a === g || a && a >= -90 && a <= 90)
            i = l(Q(h.h / da(ja * a))), b = i + Q(a / 360), b < k && (k = b, f = a, d = i);
        }) : a.step || (d = l(h.h));
        this.autoRotation = j;
        this.labelRotation = o(f, g);
        return d;
      },
      getSlotWidth: function() {
        var a = this.chart,
            b = this.horiz,
            c = this.options.labels,
            d = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
            e = a.margin[3];
        return b && (c.step || 0) < 2 && !c.rotation && (this.staggerLines || 1) * a.plotWidth / d || !b && (e && e - a.spacing[3] || a.chartWidth * 0.33);
      },
      renderUnsquish: function() {
        var a = this.chart,
            b = a.renderer,
            c = this.tickPositions,
            d = this.ticks,
            e = this.options.labels,
            f = this.horiz,
            g = this.getSlotWidth(),
            h = t(1, B(g - 2 * (e.padding || 5))),
            i = {},
            k = this.labelMetrics(),
            j = e.style.textOverflow,
            l,
            m = 0,
            n,
            q;
        if (!xa(e.rotation))
          i.rotation = e.rotation || 0;
        if (this.autoRotation)
          p(c, function(a) {
            if ((a = d[a]) && a.labelLength > m)
              m = a.labelLength;
          }), m > h && m > k.h ? i.rotation = this.labelRotation : this.labelRotation = 0;
        else if (g && (l = {width: h + "px"}, !j)) {
          l.textOverflow = "clip";
          for (n = c.length; !f && n--; )
            if (q = c[n], h = d[q].label)
              if (h.styles.textOverflow === "ellipsis" ? h.css({textOverflow: "clip"}) : d[q].labelLength > g && h.css({width: g + "px"}), h.getBBox().height > this.len / c.length - (k.h - k.f))
                h.specCss = {textOverflow: "ellipsis"};
        }
        if (i.rotation && (l = {width: (m > a.chartHeight * 0.5 ? a.chartHeight * 0.33 : a.chartHeight) + "px"}, !j))
          l.textOverflow = "ellipsis";
        if (this.labelAlign = e.align || this.autoLabelAlign(this.labelRotation))
          i.align = this.labelAlign;
        p(c, function(a) {
          var b = (a = d[a]) && a.label;
          if (b)
            b.attr(i), l && b.css(E(l, b.specCss)), delete b.specCss, a.rotation = i.rotation;
        });
        this.tickRotCorr = b.rotCorr(k.b, this.labelRotation || 0, this.side !== 0);
      },
      hasData: function() {
        return this.hasVisibleSeries || r(this.min) && r(this.max) && !!this.tickPositions;
      },
      getOffset: function() {
        var a = this,
            b = a.chart,
            c = b.renderer,
            d = a.options,
            e = a.tickPositions,
            f = a.ticks,
            g = a.horiz,
            h = a.side,
            i = b.inverted ? [1, 0, 3, 2][h] : h,
            k,
            j,
            l = 0,
            m,
            n = 0,
            q = d.title,
            z = d.labels,
            s = 0,
            G = a.opposite,
            w = b.axisOffset,
            b = b.clipOffset,
            v = [-1, 1, 1, -1][h],
            S,
            u = a.axisParent,
            $ = this.tickSize("tick");
        k = a.hasData();
        a.showAxis = j = k || o(d.showEmpty, !0);
        a.staggerLines = a.horiz && z.staggerLines;
        if (!a.axisGroup)
          a.gridGroup = c.g("grid").attr({zIndex: d.gridZIndex || 1}).add(u), a.axisGroup = c.g("axis").attr({zIndex: d.zIndex || 2}).add(u), a.labelGroup = c.g("axis-labels").attr({zIndex: z.zIndex || 7}).addClass("highcharts-" + a.coll.toLowerCase() + "-labels").add(u);
        if (k || a.isLinked) {
          if (p(e, function(b) {
            f[b] ? f[b].addLabel() : f[b] = new Va(a, b);
          }), a.renderUnsquish(), z.reserveSpace !== !1 && (h === 0 || h === 2 || {
            1: "left",
            3: "right"
          }[h] === a.labelAlign || a.labelAlign === "center") && p(e, function(a) {
            s = t(f[a].getLabelSize(), s);
          }), a.staggerLines)
            s *= a.staggerLines, a.labelOffset = s * (a.opposite ? -1 : 1);
        } else
          for (S in f)
            f[S].destroy(), delete f[S];
        if (q && q.text && q.enabled !== !1) {
          if (!a.axisTitle)
            (S = q.textAlign) || (S = (g ? {
              low: "left",
              middle: "center",
              high: "right"
            } : {
              low: G ? "right" : "left",
              middle: "center",
              high: G ? "left" : "right"
            })[q.align]), a.axisTitle = c.text(q.text, 0, 0, q.useHTML).attr({
              zIndex: 7,
              rotation: q.rotation || 0,
              align: S
            }).addClass("highcharts-" + this.coll.toLowerCase() + "-title").css(q.style).add(a.axisGroup), a.axisTitle.isNew = !0;
          if (j)
            l = a.axisTitle.getBBox()[g ? "height" : "width"], m = q.offset, n = r(m) ? 0 : o(q.margin, g ? 5 : 10);
          a.axisTitle[j ? "show" : "hide"](!0);
        }
        a.offset = v * o(d.offset, w[h]);
        a.tickRotCorr = a.tickRotCorr || {
          x: 0,
          y: 0
        };
        c = h === 0 ? -a.labelMetrics().h : h === 2 ? a.tickRotCorr.y : 0;
        n = Math.abs(s) + n;
        s && (n -= c, n += v * (g ? o(z.y, a.tickRotCorr.y + v * 8) : z.x));
        a.axisTitleMargin = o(m, n);
        w[h] = t(w[h], a.axisTitleMargin + l + v * a.offset, n, k && e.length && $ ? $[0] : 0);
        d = d.offset ? 0 : V(d.lineWidth / 2) * 2;
        b[i] = t(b[i], d);
      },
      getLinePath: function(a) {
        var b = this.chart,
            c = this.opposite,
            d = this.offset,
            e = this.horiz,
            f = this.left + (c ? this.width : 0) + d,
            d = b.chartHeight - this.bottom - (c ? this.height : 0) + d;
        c && (a *= -1);
        return b.renderer.crispLine(["M", e ? this.left : f, e ? d : this.top, "L", e ? b.chartWidth - this.right : f, e ? d : b.chartHeight - this.bottom], a);
      },
      getTitlePosition: function() {
        var a = this.horiz,
            b = this.left,
            c = this.top,
            d = this.len,
            e = this.options.title,
            f = a ? b : c,
            g = this.opposite,
            h = this.offset,
            i = e.x || 0,
            k = e.y || 0,
            j = C(e.style.fontSize || 12),
            d = {
              low: f + (a ? 0 : d),
              middle: f + d / 2,
              high: f + (a ? d : 0)
            }[e.align],
            b = (a ? c + this.height : b) + (a ? 1 : -1) * (g ? -1 : 1) * this.axisTitleMargin + (this.side === 2 ? j : 0);
        return {
          x: a ? d + i : b + (g ? this.width : 0) + h + i,
          y: a ? b + k - (g ? this.height : 0) + h : d + k
        };
      },
      render: function() {
        var a = this,
            b = a.chart,
            c = b.renderer,
            d = a.options,
            e = a.isLog,
            f = a.lin2log,
            g = a.isLinked,
            h = a.tickPositions,
            i = a.axisTitle,
            k = a.ticks,
            j = a.minorTicks,
            l = a.alternateBands,
            m = d.stackLabels,
            n = d.alternateGridColor,
            q = a.tickmarkOffset,
            z = d.lineWidth,
            s,
            o = b.hasRendered && J(a.oldMin),
            w = a.showAxis,
            v = $a(c.globalAnimation),
            r,
            t;
        a.labelEdge.length = 0;
        a.overlap = !1;
        p([k, j, l], function(a) {
          for (var b in a)
            a[b].isActive = !1;
        });
        if (a.hasData() || g) {
          a.minorTickInterval && !a.categories && p(a.getMinorTickPositions(), function(b) {
            j[b] || (j[b] = new Va(a, b, "minor"));
            o && j[b].isNew && j[b].render(null, !0);
            j[b].render(null, !1, 1);
          });
          if (h.length && (p(h, function(b, c) {
            if (!g || b >= a.min && b <= a.max)
              k[b] || (k[b] = new Va(a, b)), o && k[b].isNew && k[b].render(c, !0, 0.1), k[b].render(c);
          }), q && (a.min === 0 || a.single)))
            k[-1] || (k[-1] = new Va(a, -1, null, !0)), k[-1].render(-1);
          n && p(h, function(c, d) {
            t = h[d + 1] !== y ? h[d + 1] + q : a.max - q;
            if (d % 2 === 0 && c < a.max && t <= a.max + (b.polar ? -q : q))
              l[c] || (l[c] = new x.PlotLineOrBand(a)), r = c + q, l[c].options = {
                from: e ? f(r) : r,
                to: e ? f(t) : t,
                color: n
              }, l[c].render(), l[c].isActive = !0;
          });
          if (!a._addedPlotLB)
            p((d.plotLines || []).concat(d.plotBands || []), function(b) {
              a.addPlotBandOrLine(b);
            }), a._addedPlotLB = !0;
        }
        p([k, j, l], function(a) {
          var c,
              d,
              e = [],
              f = v.duration;
          for (c in a)
            if (!a[c].isActive)
              a[c].render(c, !1, 0), a[c].isActive = !1, e.push(c);
          Pa(function() {
            for (d = e.length; d--; )
              a[e[d]] && !a[e[d]].isActive && (a[e[d]].destroy(), delete a[e[d]]);
          }, a === l || !b.hasRendered || !f ? 0 : f);
        });
        if (z)
          s = a.getLinePath(z), a.axisLine ? a.axisLine.animate({d: s}) : a.axisLine = c.path(s).attr({
            stroke: d.lineColor,
            "stroke-width": z,
            zIndex: 7
          }).add(a.axisGroup), a.axisLine[w ? "show" : "hide"](!0);
        if (i && w)
          i[i.isNew ? "attr" : "animate"](a.getTitlePosition()), i.isNew = !1;
        m && m.enabled && a.renderStackTotals();
        a.isDirty = !1;
      },
      redraw: function() {
        this.visible && (this.render(), p(this.plotLinesAndBands, function(a) {
          a.render();
        }));
        p(this.series, function(a) {
          a.isDirty = !0;
        });
      },
      destroy: function(a) {
        var b = this,
            c = b.stacks,
            d,
            e = b.plotLinesAndBands;
        a || X(b);
        for (d in c)
          Ra(c[d]), c[d] = null;
        p([b.ticks, b.minorTicks, b.alternateBands], function(a) {
          Ra(a);
        });
        for (a = e.length; a--; )
          e[a].destroy();
        p("stackTotalGroup,axisLine,axisTitle,axisGroup,cross,gridGroup,labelGroup".split(","), function(a) {
          b[a] && (b[a] = b[a].destroy());
        });
        this.cross && this.cross.destroy();
      },
      drawCrosshair: function(a, b) {
        var c,
            d = this.crosshair,
            e,
            f;
        if (!this.crosshair || (r(b) || !o(d.snap, !0)) === !1)
          this.hideCrosshair();
        else if (o(d.snap, !0) ? r(b) && (c = this.isXAxis ? b.plotX : this.len - b.plotY) : c = this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos, c = this.isRadial ? this.getPlotLinePath(this.isXAxis ? b.x : o(b.stackY, b.y)) || null : this.getPlotLinePath(null, null, null, null, c) || null, c === null)
          this.hideCrosshair();
        else if (e = this.categories && !this.isRadial, f = o(d.width, e ? this.transA : 1), this.cross)
          this.cross.attr({
            d: c,
            visibility: "visible",
            "stroke-width": f
          });
        else {
          e = {
            "pointer-events": "none",
            "stroke-width": f,
            stroke: d.color || (e ? "rgba(155,200,255,0.2)" : "#C0C0C0"),
            zIndex: o(d.zIndex, 2)
          };
          if (d.dashStyle)
            e.dashstyle = d.dashStyle;
          this.cross = this.chart.renderer.path(c).attr(e).add();
        }
      },
      hideCrosshair: function() {
        this.cross && this.cross.hide();
      }
    };
    u(ha.prototype, {
      getPlotBandPath: function(a, b) {
        var c = this.getPlotLinePath(b, null, null, !0),
            d = this.getPlotLinePath(a, null, null, !0);
        d && c ? (d.flat = d.toString() === c.toString(), d.push(c[4], c[5], c[1], c[2])) : d = null;
        return d;
      },
      addPlotBand: function(a) {
        return this.addPlotBandOrLine(a, "plotBands");
      },
      addPlotLine: function(a) {
        return this.addPlotBandOrLine(a, "plotLines");
      },
      addPlotBandOrLine: function(a, b) {
        var c = (new x.PlotLineOrBand(this, a)).render(),
            d = this.userOptions;
        c && (b && (d[b] = d[b] || [], d[b].push(a)), this.plotLinesAndBands.push(c));
        return c;
      },
      removePlotBandOrLine: function(a) {
        for (var b = this.plotLinesAndBands,
            c = this.options,
            d = this.userOptions,
            e = b.length; e--; )
          b[e].id === a && b[e].destroy();
        p([c.plotLines || [], d.plotLines || [], c.plotBands || [], d.plotBands || []], function(b) {
          for (e = b.length; e--; )
            b[e].id === a && pa(b, b[e]);
        });
      }
    });
    ha.prototype.getTimeTicks = function(a, b, c, d) {
      var e = [],
          f = {},
          g = U.global.useUTC,
          h,
          i = new la(b - Ya(b)),
          k = a.unitRange,
          j = a.count;
      if (r(b)) {
        i[Fb](k >= H.second ? 0 : j * V(i.getMilliseconds() / j));
        if (k >= H.second)
          i[Gb](k >= H.minute ? 0 : j * V(i.getSeconds() / j));
        if (k >= H.minute)
          i[Hb](k >= H.hour ? 0 : j * V(i[tb]() / j));
        if (k >= H.hour)
          i[Ib](k >= H.day ? 0 : j * V(i[ub]() / j));
        if (k >= H.day)
          i[kb](k >= H.month ? 1 : j * V(i[Ua]() / j));
        k >= H.month && (i[wb](k >= H.year ? 0 : j * V(i[ab]() / j)), h = i[bb]());
        k >= H.year && (h -= h % j, i[xb](h));
        if (k === H.week)
          i[kb](i[Ua]() - i[vb]() + o(d, 1));
        b = 1;
        if (qb || Za)
          i = i.getTime(), i = new la(i + Ya(i));
        h = i[bb]();
        for (var d = i.getTime(),
            l = i[ab](),
            m = i[Ua](),
            n = !g || !!Za,
            q = (H.day + (g ? Ya(i) : i.getTimezoneOffset() * 6E4)) % H.day; d < c; )
          e.push(d), k === H.year ? d = jb(h + b * j, 0) : k === H.month ? d = jb(h, l + b * j) : n && (k === H.day || k === H.week) ? d = jb(h, l, m + b * j * (k === H.day ? 1 : 7)) : d += k * j, b++;
        e.push(d);
        p(Ba(e, function(a) {
          return k <= H.hour && a % H.day === q;
        }), function(a) {
          f[a] = "day";
        });
      }
      e.info = u(a, {
        higherRanks: f,
        totalRange: k * j
      });
      return e;
    };
    ha.prototype.normalizeTimeTickInterval = function(a, b) {
      var c = b || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]],
          d = c[c.length - 1],
          e = H[d[0]],
          f = d[1],
          g;
      for (g = 0; g < c.length; g++)
        if (d = c[g], e = H[d[0]], f = d[1], c[g + 1] && a <= (e * f[f.length - 1] + H[c[g + 1][0]]) / 2)
          break;
      e === H.year && a < 5 * e && (f = [1, 2, 5]);
      c = sb(a / e, f, d[0] === "year" ? t(rb(a / e), 1) : 1);
      return {
        unitRange: e,
        count: c,
        unitName: d[0]
      };
    };
    ha.prototype.getLogTickPositions = function(a, b, c, d) {
      var e = this.options,
          f = this.len,
          g = this.lin2log,
          h = this.log2lin,
          i = [];
      if (!d)
        this._minorAutoInterval = null;
      if (a >= 0.5)
        a = B(a), i = this.getLinearTickPositions(a, b, c);
      else if (a >= 0.08)
        for (var f = V(b),
            k,
            j,
            l,
            m,
            n,
            e = a > 0.3 ? [1, 2, 4] : a > 0.15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; f < c + 1 && !n; f++) {
          j = e.length;
          for (k = 0; k < j && !n; k++)
            l = h(g(f) * e[k]), l > b && (!d || m <= c) && m !== y && i.push(m), m > c && (n = !0), m = l;
        }
      else if (b = g(b), c = g(c), a = e[d ? "minorTickInterval" : "tickInterval"], a = o(a === "auto" ? null : a, this._minorAutoInterval, (c - b) * (e.tickPixelInterval / (d ? 5 : 1)) / ((d ? f / this.tickPositions.length : f) || 1)), a = sb(a, null, rb(a)), i = Ca(this.getLinearTickPositions(a, b, c), h), !d)
        this._minorAutoInterval = a / 5;
      if (!d)
        this.tickInterval = a;
      return i;
    };
    ha.prototype.log2lin = function(a) {
      return Y.log(a) / Y.LN10;
    };
    ha.prototype.lin2log = function(a) {
      return Y.pow(10, a);
    };
    var Ob = x.Tooltip = function() {
      this.init.apply(this, arguments);
    };
    Ob.prototype = {
      init: function(a, b) {
        var c = b.borderWidth,
            d = b.style,
            e = C(d.padding);
        this.chart = a;
        this.options = b;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.label = a.renderer.label("", 0, 0, b.shape || "callout", null, null, b.useHTML, null, "tooltip").attr({
          padding: e,
          fill: b.backgroundColor,
          "stroke-width": c,
          r: b.borderRadius,
          zIndex: 8
        }).css(d).css({padding: 0}).add().attr({y: -9999});
        ka || this.label.shadow(b.shadow);
        this.shared = b.shared;
      },
      destroy: function() {
        if (this.label)
          this.label = this.label.destroy();
        clearTimeout(this.hideTimer);
        clearTimeout(this.tooltipTimeout);
      },
      move: function(a, b, c, d) {
        var e = this,
            f = e.now,
            g = e.options.animation !== !1 && !e.isHidden && (Q(a - f.x) > 1 || Q(b - f.y) > 1),
            h = e.followPointer || e.len > 1;
        u(f, {
          x: g ? (2 * f.x + a) / 3 : a,
          y: g ? (f.y + b) / 2 : b,
          anchorX: h ? y : g ? (2 * f.anchorX + c) / 3 : c,
          anchorY: h ? y : g ? (f.anchorY + d) / 2 : d
        });
        e.label.attr(f);
        if (g)
          clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
            e && e.move(a, b, c, d);
          }, 32);
      },
      hide: function(a) {
        var b = this;
        clearTimeout(this.hideTimer);
        a = o(a, this.options.hideDelay, 500);
        if (!this.isHidden)
          this.hideTimer = Pa(function() {
            b.label[a ? "fadeOut" : "hide"]();
            b.isHidden = !0;
          }, a);
      },
      getAnchor: function(a, b) {
        var c,
            d = this.chart,
            e = d.inverted,
            f = d.plotTop,
            g = d.plotLeft,
            h = 0,
            i = 0,
            k,
            j,
            a = ta(a);
        c = a[0].tooltipPos;
        this.followPointer && b && (b.chartX === y && (b = d.pointer.normalize(b)), c = [b.chartX - d.plotLeft, b.chartY - f]);
        c || (p(a, function(a) {
          k = a.series.yAxis;
          j = a.series.xAxis;
          h += a.plotX + (!e && j ? j.left - g : 0);
          i += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!e && k ? k.top - f : 0);
        }), h /= a.length, i /= a.length, c = [e ? d.plotWidth - i : h, this.shared && !e && a.length > 1 && b ? b.chartY - f : e ? d.plotHeight - h : i]);
        return Ca(c, B);
      },
      getPosition: function(a, b, c) {
        var d = this.chart,
            e = this.distance,
            f = {},
            g = c.h || 0,
            h,
            i = ["y", d.chartHeight, b, c.plotY + d.plotTop, d.plotTop, d.plotTop + d.plotHeight],
            k = ["x", d.chartWidth, a, c.plotX + d.plotLeft, d.plotLeft, d.plotLeft + d.plotWidth],
            j = !this.followPointer && o(c.ttBelow, !d.inverted === !!c.negative),
            l = function(a, b, c, d, h, i) {
              var k = c < d - e,
                  m = d + e + c < b,
                  l = d - e - c;
              d += e;
              if (j && m)
                f[a] = d;
              else if (!j && k)
                f[a] = l;
              else if (k)
                f[a] = F(i - c, l - g < 0 ? l : l - g);
              else if (m)
                f[a] = t(h, d + g + c > b ? d : d + g);
              else
                return !1;
            },
            m = function(a, b, c, d) {
              var g;
              d < e || d > b - e ? g = !1 : f[a] = d < c / 2 ? 1 : d > b - c / 2 ? b - c - 2 : d - c / 2;
              return g;
            },
            n = function(a) {
              var b = i;
              i = k;
              k = b;
              h = a;
            },
            q = function() {
              l.apply(0, i) !== !1 ? m.apply(0, k) === !1 && !h && (n(!0), q()) : h ? f.x = f.y = 0 : (n(!0), q());
            };
        (d.inverted || this.len > 1) && n();
        q();
        return f;
      },
      defaultFormatter: function(a) {
        var b = this.points || ta(this),
            c;
        c = [a.tooltipFooterHeaderFormatter(b[0])];
        c = c.concat(a.bodyFormatter(b));
        c.push(a.tooltipFooterHeaderFormatter(b[0], !0));
        return c.join("");
      },
      refresh: function(a, b) {
        var c = this.chart,
            d = this.label,
            e = this.options,
            f,
            g,
            h,
            i = {},
            k,
            j = [];
        k = e.formatter || this.defaultFormatter;
        var i = c.hoverPoints,
            l,
            m = this.shared;
        clearTimeout(this.hideTimer);
        this.followPointer = ta(a)[0].series.tooltipOptions.followPointer;
        h = this.getAnchor(a, b);
        f = h[0];
        g = h[1];
        m && (!a.series || !a.series.noSharedTooltip) ? (c.hoverPoints = a, i && p(i, function(a) {
          a.setState();
        }), p(a, function(a) {
          a.setState("hover");
          j.push(a.getLabelConfig());
        }), i = {
          x: a[0].category,
          y: a[0].y
        }, i.points = j, this.len = j.length, a = a[0]) : i = a.getLabelConfig();
        k = k.call(i, this);
        i = a.series;
        this.distance = o(i.tooltipOptions.distance, 16);
        k === !1 ? this.hide() : (this.isHidden && (Oa(d), d.attr("opacity", 1).show()), d.attr({text: k}), l = e.borderColor || a.color || i.color || "#606060", d.attr({stroke: l}), this.updatePosition({
          plotX: f,
          plotY: g,
          negative: a.negative,
          ttBelow: a.ttBelow,
          h: h[2] || 0
        }), this.isHidden = !1);
        I(c, "tooltipRefresh", {
          text: k,
          x: f + c.plotLeft,
          y: g + c.plotTop,
          borderColor: l
        });
      },
      updatePosition: function(a) {
        var b = this.chart,
            c = this.label,
            c = (this.options.positioner || this.getPosition).call(this, c.width, c.height, a);
        this.move(B(c.x), B(c.y || 0), a.plotX + b.plotLeft, a.plotY + b.plotTop);
      },
      getXDateFormat: function(a, b, c) {
        var d,
            b = b.dateTimeLabelFormats,
            e = c && c.closestPointRange,
            f,
            g = {
              millisecond: 15,
              second: 12,
              minute: 9,
              hour: 6,
              day: 3
            },
            h,
            i = "millisecond";
        if (e) {
          h = Qa("%m-%d %H:%M:%S.%L", a.x);
          for (f in H) {
            if (e === H.week && +Qa("%w", a.x) === c.options.startOfWeek && h.substr(6) === "00:00:00.000") {
              f = "week";
              break;
            }
            if (H[f] > e) {
              f = i;
              break;
            }
            if (g[f] && h.substr(g[f]) !== "01-01 00:00:00.000".substr(g[f]))
              break;
            f !== "week" && (i = f);
          }
          f && (d = b[f]);
        } else
          d = b.day;
        return d || b.year;
      },
      tooltipFooterHeaderFormatter: function(a, b) {
        var c = b ? "footer" : "header",
            d = a.series,
            e = d.tooltipOptions,
            f = e.xDateFormat,
            g = d.xAxis,
            h = g && g.options.type === "datetime" && J(a.key),
            c = e[c + "Format"];
        h && !f && (f = this.getXDateFormat(a, e, g));
        h && f && (c = c.replace("{point.key}", "{point.key:" + f + "}"));
        return Ka(c, {
          point: a,
          series: d
        });
      },
      bodyFormatter: function(a) {
        return Ca(a, function(a) {
          var c = a.series.tooltipOptions;
          return (c.pointFormatter || a.point.tooltipFormatter).call(a.point, c.pointFormat);
        });
      }
    };
    var ia;
    db = A && A.documentElement.ontouchstart !== y;
    var Xa = x.Pointer = function(a, b) {
      this.init(a, b);
    };
    Xa.prototype = {
      init: function(a, b) {
        var c = b.chart,
            d = c.events,
            e = ka ? "" : c.zoomType,
            c = a.inverted,
            f;
        this.options = b;
        this.chart = a;
        this.zoomX = f = /x/.test(e);
        this.zoomY = e = /y/.test(e);
        this.zoomHor = f && !c || e && c;
        this.zoomVert = e && !c || f && c;
        this.hasZoom = f || e;
        this.runChartClick = d && !!d.click;
        this.pinchDown = [];
        this.lastValidTouch = {};
        if (x.Tooltip && b.tooltip.enabled)
          a.tooltip = new Ob(a, b.tooltip), this.followTouchMove = o(b.tooltip.followTouchMove, !0);
        this.setDOMEvents();
      },
      normalize: function(a, b) {
        var c,
            d,
            a = a || D.event;
        if (!a.target)
          a.target = a.srcElement;
        d = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;
        if (!b)
          this.chartPosition = b = zb(this.chart.container);
        d.pageX === y ? (c = t(a.x, a.clientX - b.left), d = a.y) : (c = d.pageX - b.left, d = d.pageY - b.top);
        return u(a, {
          chartX: B(c),
          chartY: B(d)
        });
      },
      getCoordinates: function(a) {
        var b = {
          xAxis: [],
          yAxis: []
        };
        p(this.chart.axes, function(c) {
          b[c.isXAxis ? "xAxis" : "yAxis"].push({
            axis: c,
            value: c.toValue(a[c.horiz ? "chartX" : "chartY"])
          });
        });
        return b;
      },
      runPointActions: function(a) {
        var b = this.chart,
            c = b.series,
            d = b.tooltip,
            e = d ? d.shared : !1,
            f = b.hoverPoint,
            g = b.hoverSeries,
            h,
            i = [Number.MAX_VALUE, Number.MAX_VALUE],
            k,
            j,
            l = [],
            m = [],
            n;
        if (!e && !g)
          for (h = 0; h < c.length; h++)
            if (c[h].directTouch || !c[h].options.stickyTracking)
              c = [];
        g && (e ? g.noSharedTooltip : g.directTouch) && f ? m = [f] : (p(c, function(b) {
          k = b.noSharedTooltip && e;
          j = !e && b.directTouch;
          b.visible && !k && !j && o(b.options.enableMouseTracking, !0) && (n = b.searchPoint(a, !k && b.kdDimensions === 1)) && l.push(n);
        }), p(l, function(a) {
          a && p(["dist", "distX"], function(b, c) {
            if (J(a[b])) {
              var d = a[b] === i[c] && a.series.group.zIndex >= m[c].series.group.zIndex;
              if (a[b] < i[c] || d)
                i[c] = a[b], m[c] = a;
            }
          });
        }));
        if (e)
          for (h = l.length; h--; )
            (l[h].clientX !== m[1].clientX || l[h].series.noSharedTooltip) && l.splice(h, 1);
        if (m[0] && (m[0] !== this.prevKDPoint || d && d.isHidden))
          if (e && !m[0].series.noSharedTooltip)
            l.length && d && d.refresh(l, a), p(l, function(b) {
              b.onMouseOver(a, b !== (g && g.directTouch && f || m[0]));
            }), this.prevKDPoint = m[1];
          else {
            d && d.refresh(m[0], a);
            if (!g || !g.directTouch)
              m[0].onMouseOver(a);
            this.prevKDPoint = m[0];
          }
        else
          c = g && g.tooltipOptions.followPointer, d && c && !d.isHidden && (c = d.getAnchor([{}], a), d.updatePosition({
            plotX: c[0],
            plotY: c[1]
          }));
        if (!this._onDocumentMouseMove)
          this._onDocumentMouseMove = function(a) {
            if (T[ia])
              T[ia].pointer.onDocumentMouseMove(a);
          }, N(A, "mousemove", this._onDocumentMouseMove);
        p(e ? l : [o(f, m[1])], function(c) {
          p(b.axes, function(b) {
            (!c || c.series[b.coll] === b) && b.drawCrosshair(a, c);
          });
        });
      },
      reset: function(a, b) {
        var c = this.chart,
            d = c.hoverSeries,
            e = c.hoverPoint,
            f = c.hoverPoints,
            g = c.tooltip,
            h = g && g.shared ? f : e;
        a && h && p(ta(h), function(b) {
          b.series.isCartesian && b.plotX === void 0 && (a = !1);
        });
        if (a)
          g && h && (g.refresh(h), e && (e.setState(e.state, !0), p(c.axes, function(a) {
            o(a.crosshair && a.crosshair.snap, !0) ? a.drawCrosshair(null, e) : a.hideCrosshair();
          })));
        else {
          if (e)
            e.onMouseOut();
          f && p(f, function(a) {
            a.setState();
          });
          if (d)
            d.onMouseOut();
          g && g.hide(b);
          if (this._onDocumentMouseMove)
            X(A, "mousemove", this._onDocumentMouseMove), this._onDocumentMouseMove = null;
          p(c.axes, function(a) {
            a.hideCrosshair();
          });
          this.hoverX = c.hoverPoints = c.hoverPoint = null;
        }
      },
      scaleGroups: function(a, b) {
        var c = this.chart,
            d;
        p(c.series, function(e) {
          d = a || e.getPlotBox();
          e.xAxis && e.xAxis.zoomEnabled && (e.group.attr(d), e.markerGroup && (e.markerGroup.attr(d), e.markerGroup.clip(b ? c.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(d));
        });
        c.clipRect.attr(b || c.clipBox);
      },
      dragStart: function(a) {
        var b = this.chart;
        b.mouseIsDown = a.type;
        b.cancelClick = !1;
        b.mouseDownX = this.mouseDownX = a.chartX;
        b.mouseDownY = this.mouseDownY = a.chartY;
      },
      drag: function(a) {
        var b = this.chart,
            c = b.options.chart,
            d = a.chartX,
            e = a.chartY,
            f = this.zoomHor,
            g = this.zoomVert,
            h = b.plotLeft,
            i = b.plotTop,
            k = b.plotWidth,
            j = b.plotHeight,
            l,
            m = this.selectionMarker,
            n = this.mouseDownX,
            q = this.mouseDownY,
            o = c.panKey && a[c.panKey + "Key"];
        if (!m || !m.touch)
          if (d < h ? d = h : d > h + k && (d = h + k), e < i ? e = i : e > i + j && (e = i + j), this.hasDragged = Math.sqrt(Math.pow(n - d, 2) + Math.pow(q - e, 2)), this.hasDragged > 10) {
            l = b.isInsidePlot(n - h, q - i);
            if (b.hasCartesianSeries && (this.zoomX || this.zoomY) && l && !o && !m)
              this.selectionMarker = m = b.renderer.rect(h, i, f ? 1 : k, g ? 1 : j, 0).attr({
                fill: c.selectionMarkerFill || "rgba(69,114,167,0.25)",
                zIndex: 7
              }).add();
            m && f && (d -= n, m.attr({
              width: Q(d),
              x: (d > 0 ? 0 : d) + n
            }));
            m && g && (d = e - q, m.attr({
              height: Q(d),
              y: (d > 0 ? 0 : d) + q
            }));
            l && !m && c.panning && b.pan(a, c.panning);
          }
      },
      drop: function(a) {
        var b = this,
            c = this.chart,
            d = this.hasPinched;
        if (this.selectionMarker) {
          var e = {
            originalEvent: a,
            xAxis: [],
            yAxis: []
          },
              f = this.selectionMarker,
              g = f.attr ? f.attr("x") : f.x,
              h = f.attr ? f.attr("y") : f.y,
              i = f.attr ? f.attr("width") : f.width,
              k = f.attr ? f.attr("height") : f.height,
              j;
          if (this.hasDragged || d)
            p(c.axes, function(c) {
              if (c.zoomEnabled && r(c.min) && (d || b[{
                xAxis: "zoomX",
                yAxis: "zoomY"
              }[c.coll]])) {
                var f = c.horiz,
                    n = a.type === "touchend" ? c.minPixelPadding : 0,
                    q = c.toValue((f ? g : h) + n),
                    f = c.toValue((f ? g + i : h + k) - n);
                e[c.coll].push({
                  axis: c,
                  min: F(q, f),
                  max: t(q, f)
                });
                j = !0;
              }
            }), j && I(c, "selection", e, function(a) {
              c.zoom(u(a, d ? {animation: !1} : null));
            });
          this.selectionMarker = this.selectionMarker.destroy();
          d && this.scaleGroups();
        }
        if (c)
          M(c.container, {cursor: c._cursor}), c.cancelClick = this.hasDragged > 10, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [];
      },
      onContainerMouseDown: function(a) {
        a = this.normalize(a);
        a.preventDefault && a.preventDefault();
        this.dragStart(a);
      },
      onDocumentMouseUp: function(a) {
        T[ia] && T[ia].pointer.drop(a);
      },
      onDocumentMouseMove: function(a) {
        var b = this.chart,
            c = this.chartPosition,
            a = this.normalize(a, c);
        c && !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) && this.reset();
      },
      onContainerMouseLeave: function(a) {
        var b = T[ia];
        if (b && (a.relatedTarget || a.toElement))
          b.pointer.reset(), b.pointer.chartPosition = null;
      },
      onContainerMouseMove: function(a) {
        var b = this.chart;
        if (!r(ia) || !T[ia] || !T[ia].mouseIsDown)
          ia = b.index;
        a = this.normalize(a);
        a.returnValue = !1;
        b.mouseIsDown === "mousedown" && this.drag(a);
        (this.inClass(a.target, "highcharts-tracker") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop)) && !b.openMenu && this.runPointActions(a);
      },
      inClass: function(a, b) {
        for (var c; a; ) {
          if (c = P(a, "class")) {
            if (c.indexOf(b) !== -1)
              return !0;
            if (c.indexOf("highcharts-container") !== -1)
              return !1;
          }
          a = a.parentNode;
        }
      },
      onTrackerMouseOut: function(a) {
        var b = this.chart.hoverSeries,
            a = a.relatedTarget || a.toElement;
        if (b && a && !b.options.stickyTracking && !this.inClass(a, "highcharts-tooltip") && !this.inClass(a, "highcharts-series-" + b.index))
          b.onMouseOut();
      },
      onContainerClick: function(a) {
        var b = this.chart,
            c = b.hoverPoint,
            d = b.plotLeft,
            e = b.plotTop,
            a = this.normalize(a);
        b.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (I(c.series, "click", u(a, {point: c})), b.hoverPoint && c.firePointEvent("click", a)) : (u(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - d, a.chartY - e) && I(b, "click", a)));
      },
      setDOMEvents: function() {
        var a = this,
            b = a.chart.container;
        b.onmousedown = function(b) {
          a.onContainerMouseDown(b);
        };
        b.onmousemove = function(b) {
          a.onContainerMouseMove(b);
        };
        b.onclick = function(b) {
          a.onContainerClick(b);
        };
        N(b, "mouseleave", a.onContainerMouseLeave);
        eb === 1 && N(A, "mouseup", a.onDocumentMouseUp);
        if (db)
          b.ontouchstart = function(b) {
            a.onContainerTouchStart(b);
          }, b.ontouchmove = function(b) {
            a.onContainerTouchMove(b);
          }, eb === 1 && N(A, "touchend", a.onDocumentTouchEnd);
      },
      destroy: function() {
        var a;
        X(this.chart.container, "mouseleave", this.onContainerMouseLeave);
        eb || (X(A, "mouseup", this.onDocumentMouseUp), X(A, "touchend", this.onDocumentTouchEnd));
        clearInterval(this.tooltipTimeout);
        for (a in this)
          this[a] = null;
      }
    };
    u(x.Pointer.prototype, {
      pinchTranslate: function(a, b, c, d, e, f) {
        (this.zoomHor || this.pinchHor) && this.pinchTranslateDirection(!0, a, b, c, d, e, f);
        (this.zoomVert || this.pinchVert) && this.pinchTranslateDirection(!1, a, b, c, d, e, f);
      },
      pinchTranslateDirection: function(a, b, c, d, e, f, g, h) {
        var i = this.chart,
            k = a ? "x" : "y",
            j = a ? "X" : "Y",
            l = "chart" + j,
            m = a ? "width" : "height",
            n = i["plot" + (a ? "Left" : "Top")],
            q,
            o,
            s = h || 1,
            p = i.inverted,
            w = i.bounds[a ? "h" : "v"],
            v = b.length === 1,
            r = b[0][l],
            t = c[0][l],
            u = !v && b[1][l],
            x = !v && c[1][l],
            B,
            c = function() {
              !v && Q(r - u) > 20 && (s = h || Q(t - x) / Q(r - u));
              o = (n - t) / s + r;
              q = i["plot" + (a ? "Width" : "Height")] / s;
            };
        c();
        b = o;
        b < w.min ? (b = w.min, B = !0) : b + q > w.max && (b = w.max - q, B = !0);
        B ? (t -= 0.8 * (t - g[k][0]), v || (x -= 0.8 * (x - g[k][1])), c()) : g[k] = [t, x];
        p || (f[k] = o - n, f[m] = q);
        f = p ? 1 / s : s;
        e[m] = q;
        e[k] = b;
        d[p ? a ? "scaleY" : "scaleX" : "scale" + j] = s;
        d["translate" + j] = f * n + (t - f * r);
      },
      pinch: function(a) {
        var b = this,
            c = b.chart,
            d = b.pinchDown,
            e = a.touches,
            f = e.length,
            g = b.lastValidTouch,
            h = b.hasZoom,
            i = b.selectionMarker,
            k = {},
            j = f === 1 && (b.inClass(a.target, "highcharts-tracker") && c.runTrackerClick || b.runChartClick),
            l = {};
        if (f > 1)
          b.initiated = !0;
        h && b.initiated && !j && a.preventDefault();
        Ca(e, function(a) {
          return b.normalize(a);
        });
        if (a.type === "touchstart")
          p(e, function(a, b) {
            d[b] = {
              chartX: a.chartX,
              chartY: a.chartY
            };
          }), g.x = [d[0].chartX, d[1] && d[1].chartX], g.y = [d[0].chartY, d[1] && d[1].chartY], p(c.axes, function(a) {
            if (a.zoomEnabled) {
              var b = c.bounds[a.horiz ? "h" : "v"],
                  d = a.minPixelPadding,
                  e = a.toPixels(o(a.options.min, a.dataMin)),
                  f = a.toPixels(o(a.options.max, a.dataMax)),
                  g = F(e, f),
                  e = t(e, f);
              b.min = F(a.pos, g - d);
              b.max = t(a.pos + a.len, e + d);
            }
          }), b.res = !0;
        else if (d.length) {
          if (!i)
            b.selectionMarker = i = u({
              destroy: Aa,
              touch: !0
            }, c.plotBox);
          b.pinchTranslate(d, e, k, i, l, g);
          b.hasPinched = h;
          b.scaleGroups(k, l);
          if (!h && b.followTouchMove && f === 1)
            this.runPointActions(b.normalize(a));
          else if (b.res)
            b.res = !1, this.reset(!1, 0);
        }
      },
      touch: function(a, b) {
        var c = this.chart,
            d;
        ia = c.index;
        if (a.touches.length === 1)
          if (a = this.normalize(a), c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop) && !c.openMenu) {
            b && this.runPointActions(a);
            if (a.type === "touchmove")
              c = this.pinchDown, d = c[0] ? Math.sqrt(Math.pow(c[0].chartX - a.chartX, 2) + Math.pow(c[0].chartY - a.chartY, 2)) >= 4 : !1;
            o(d, !0) && this.pinch(a);
          } else
            b && this.reset();
        else
          a.touches.length === 2 && this.pinch(a);
      },
      onContainerTouchStart: function(a) {
        this.touch(a, !0);
      },
      onContainerTouchMove: function(a) {
        this.touch(a);
      },
      onDocumentTouchEnd: function(a) {
        T[ia] && T[ia].pointer.drop(a);
      }
    });
    if (D.PointerEvent || D.MSPointerEvent) {
      var va = {},
          Cb = !!D.PointerEvent,
          Rb = function() {
            var a,
                b = [];
            b.item = function(a) {
              return this[a];
            };
            for (a in va)
              va.hasOwnProperty(a) && b.push({
                pageX: va[a].pageX,
                pageY: va[a].pageY,
                target: va[a].target
              });
            return b;
          },
          Db = function(a, b, c, d) {
            if ((a.pointerType === "touch" || a.pointerType === a.MSPOINTER_TYPE_TOUCH) && T[ia])
              d(a), d = T[ia].pointer, d[b]({
                type: c,
                target: a.currentTarget,
                preventDefault: Aa,
                touches: Rb()
              });
          };
      u(Xa.prototype, {
        onContainerPointerDown: function(a) {
          Db(a, "onContainerTouchStart", "touchstart", function(a) {
            va[a.pointerId] = {
              pageX: a.pageX,
              pageY: a.pageY,
              target: a.currentTarget
            };
          });
        },
        onContainerPointerMove: function(a) {
          Db(a, "onContainerTouchMove", "touchmove", function(a) {
            va[a.pointerId] = {
              pageX: a.pageX,
              pageY: a.pageY
            };
            if (!va[a.pointerId].target)
              va[a.pointerId].target = a.currentTarget;
          });
        },
        onDocumentPointerUp: function(a) {
          Db(a, "onDocumentTouchEnd", "touchend", function(a) {
            delete va[a.pointerId];
          });
        },
        batchMSEvents: function(a) {
          a(this.chart.container, Cb ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
          a(this.chart.container, Cb ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
          a(A, Cb ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
        }
      });
      fb(Xa.prototype, "init", function(a, b, c) {
        a.call(this, b, c);
        this.hasZoom && M(b.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      });
      fb(Xa.prototype, "setDOMEvents", function(a) {
        a.apply(this);
        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(N);
      });
      fb(Xa.prototype, "destroy", function(a) {
        this.batchMSEvents(X);
        a.call(this);
      });
    }
    var ob = x.Legend = function(a, b) {
      this.init(a, b);
    };
    ob.prototype = {
      init: function(a, b) {
        var c = this,
            d = b.itemStyle,
            e = b.itemMarginTop || 0;
        this.options = b;
        if (b.enabled)
          c.itemStyle = d, c.itemHiddenStyle = E(d, b.itemHiddenStyle), c.itemMarginTop = e, c.padding = d = o(b.padding, 8), c.initialItemX = d, c.initialItemY = d - 5, c.maxItemWidth = 0, c.chart = a, c.itemHeight = 0, c.symbolWidth = o(b.symbolWidth, 16), c.pages = [], c.render(), N(c.chart, "endResize", function() {
            c.positionCheckboxes();
          });
      },
      colorizeItem: function(a, b) {
        var c = this.options,
            d = a.legendItem,
            e = a.legendLine,
            f = a.legendSymbol,
            g = this.itemHiddenStyle.color,
            c = b ? c.itemStyle.color : g,
            h = b ? a.legendColor || a.color || "#CCC" : g,
            g = a.options && a.options.marker,
            i = {fill: h},
            k;
        d && d.css({
          fill: c,
          color: c
        });
        e && e.attr({stroke: h});
        if (f) {
          if (g && f.isMarker)
            for (k in i.stroke = h, g = a.convertAttribs(g), g)
              d = g[k], d !== y && (i[k] = d);
          f.attr(i);
        }
      },
      positionItem: function(a) {
        var b = this.options,
            c = b.symbolPadding,
            b = !b.rtl,
            d = a._legendItemPos,
            e = d[0],
            d = d[1],
            f = a.checkbox;
        (a = a.legendGroup) && a.element && a.translate(b ? e : this.legendWidth - e - 2 * c - 4, d);
        if (f)
          f.x = e, f.y = d;
      },
      destroyItem: function(a) {
        var b = a.checkbox;
        p(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function(b) {
          a[b] && (a[b] = a[b].destroy());
        });
        b && Sa(a.checkbox);
      },
      destroy: function() {
        var a = this.group,
            b = this.box;
        if (b)
          this.box = b.destroy();
        if (a)
          this.group = a.destroy();
      },
      positionCheckboxes: function(a) {
        var b = this.group.alignAttr,
            c,
            d = this.clipHeight || this.legendHeight,
            e = this.titleHeight;
        if (b)
          c = b.translateY, p(this.allItems, function(f) {
            var g = f.checkbox,
                h;
            g && (h = c + e + g.y + (a || 0) + 3, M(g, {
              left: b.translateX + f.checkboxOffset + g.x - 20 + "px",
              top: h + "px",
              display: h > c - 6 && h < c + d - 6 ? "" : "none"
            }));
          });
      },
      renderTitle: function() {
        var a = this.padding,
            b = this.options.title,
            c = 0;
        if (b.text) {
          if (!this.title)
            this.title = this.chart.renderer.label(b.text, a - 3, a - 4, null, null, null, null, null, "legend-title").attr({zIndex: 1}).css(b.style).add(this.group);
          a = this.title.getBBox();
          c = a.height;
          this.offsetWidth = a.width;
          this.contentGroup.attr({translateY: c});
        }
        this.titleHeight = c;
      },
      setText: function(a) {
        var b = this.options;
        a.legendItem.attr({text: b.labelFormat ? Ka(b.labelFormat, a) : b.labelFormatter.call(a)});
      },
      renderItem: function(a) {
        var b = this.chart,
            c = b.renderer,
            d = this.options,
            e = d.layout === "horizontal",
            f = this.symbolWidth,
            g = d.symbolPadding,
            h = this.itemStyle,
            i = this.itemHiddenStyle,
            k = this.padding,
            j = e ? o(d.itemDistance, 20) : 0,
            l = !d.rtl,
            m = d.width,
            n = d.itemMarginBottom || 0,
            q = this.itemMarginTop,
            z = this.initialItemX,
            s = a.legendItem,
            p = a.series && a.series.drawLegendSymbol ? a.series : a,
            w = p.options,
            w = this.createCheckboxForItem && w && w.showCheckbox,
            v = d.useHTML;
        if (!s) {
          a.legendGroup = c.g("legend-item").attr({zIndex: 1}).add(this.scrollGroup);
          a.legendItem = s = c.text("", l ? f + g : -g, this.baseline || 0, v).css(E(a.visible ? h : i)).attr({
            align: l ? "left" : "right",
            zIndex: 2
          }).add(a.legendGroup);
          if (!this.baseline)
            this.fontMetrics = c.fontMetrics(h.fontSize, s), this.baseline = this.fontMetrics.f + 3 + q, s.attr("y", this.baseline);
          p.drawLegendSymbol(this, a);
          this.setItemEvents && this.setItemEvents(a, s, v, h, i);
          w && this.createCheckboxForItem(a);
        }
        this.colorizeItem(a, a.visible);
        this.setText(a);
        c = s.getBBox();
        f = a.checkboxOffset = d.itemWidth || a.legendItemWidth || f + g + c.width + j + (w ? 20 : 0);
        this.itemHeight = g = B(a.legendItemHeight || c.height);
        if (e && this.itemX - z + f > (m || b.chartWidth - 2 * k - z - d.x))
          this.itemX = z, this.itemY += q + this.lastLineHeight + n, this.lastLineHeight = 0;
        this.maxItemWidth = t(this.maxItemWidth, f);
        this.lastItemY = q + this.itemY + n;
        this.lastLineHeight = t(g, this.lastLineHeight);
        a._legendItemPos = [this.itemX, this.itemY];
        e ? this.itemX += f : (this.itemY += q + g + n, this.lastLineHeight = g);
        this.offsetWidth = m || t((e ? this.itemX - z - j : f) + k, this.offsetWidth);
      },
      getAllItems: function() {
        var a = [];
        p(this.chart.series, function(b) {
          var c = b.options;
          if (o(c.showInLegend, !r(c.linkedTo) ? y : !1, !0))
            a = a.concat(b.legendItems || (c.legendType === "point" ? b.data : b));
        });
        return a;
      },
      adjustMargins: function(a, b) {
        var c = this.chart,
            d = this.options,
            e = d.align.charAt(0) + d.verticalAlign.charAt(0) + d.layout.charAt(0);
        this.display && !d.floating && p([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function(f, g) {
          f.test(e) && !r(a[g]) && (c[nb[g]] = t(c[nb[g]], c.legend[(g + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][g] * d[g % 2 ? "x" : "y"] + o(d.margin, 12) + b[g]));
        });
      },
      render: function() {
        var a = this,
            b = a.chart,
            c = b.renderer,
            d = a.group,
            e,
            f,
            g,
            h,
            i = a.box,
            k = a.options,
            j = a.padding,
            l = k.borderWidth,
            m = k.backgroundColor;
        a.itemX = a.initialItemX;
        a.itemY = a.initialItemY;
        a.offsetWidth = 0;
        a.lastItemY = 0;
        if (!d)
          a.group = d = c.g("legend").attr({zIndex: 7}).add(), a.contentGroup = c.g().attr({zIndex: 1}).add(d), a.scrollGroup = c.g().add(a.contentGroup);
        a.renderTitle();
        e = a.getAllItems();
        hb(e, function(a, b) {
          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
        });
        k.reversed && e.reverse();
        a.allItems = e;
        a.display = f = !!e.length;
        a.lastLineHeight = 0;
        p(e, function(b) {
          a.renderItem(b);
        });
        g = (k.width || a.offsetWidth) + j;
        h = a.lastItemY + a.lastLineHeight + a.titleHeight;
        h = a.handleOverflow(h);
        h += j;
        if (l || m) {
          if (i) {
            if (g > 0 && h > 0)
              i[i.isNew ? "attr" : "animate"](i.crisp({
                width: g,
                height: h
              })), i.isNew = !1;
          } else
            a.box = i = c.rect(0, 0, g, h, k.borderRadius, l || 0).attr({
              stroke: k.borderColor,
              "stroke-width": l || 0,
              fill: m || "none"
            }).add(d).shadow(k.shadow), i.isNew = !0;
          i[f ? "show" : "hide"]();
        }
        a.legendWidth = g;
        a.legendHeight = h;
        p(e, function(b) {
          a.positionItem(b);
        });
        f && d.align(u({
          width: g,
          height: h
        }, k), !0, "spacingBox");
        b.isResizing || this.positionCheckboxes();
      },
      handleOverflow: function(a) {
        var b = this,
            c = this.chart,
            d = c.renderer,
            e = this.options,
            f = e.y,
            f = c.spacingBox.height + (e.verticalAlign === "top" ? -f : f) - this.padding,
            g = e.maxHeight,
            h,
            i = this.clipRect,
            k = e.navigation,
            j = o(k.animation, !0),
            l = k.arrowSize || 12,
            m = this.nav,
            n = this.pages,
            q = this.padding,
            z,
            s = this.allItems,
            r = function(a) {
              i.attr({height: a});
              if (b.contentGroup.div)
                b.contentGroup.div.style.clip = "rect(" + q + "px,9999px," + (q + a) + "px,0)";
            };
        e.layout === "horizontal" && (f /= 2);
        g && (f = F(f, g));
        n.length = 0;
        if (a > f && k.enabled !== !1) {
          this.clipHeight = h = t(f - 20 - this.titleHeight - q, 0);
          this.currentPage = o(this.currentPage, 1);
          this.fullHeight = a;
          p(s, function(a, b) {
            var c = a._legendItemPos[1],
                d = B(a.legendItem.getBBox().height),
                e = n.length;
            if (!e || c - n[e - 1] > h && (z || c) !== n[e - 1])
              n.push(z || c), e++;
            b === s.length - 1 && c + d - n[e - 1] > h && n.push(c);
            c !== z && (z = c);
          });
          if (!i)
            i = b.clipRect = d.clipRect(0, q, 9999, 0), b.contentGroup.clip(i);
          r(h);
          if (!m)
            this.nav = m = d.g().attr({zIndex: 1}).add(this.group), this.up = d.symbol("triangle", 0, 0, l, l).on("click", function() {
              b.scroll(-1, j);
            }).add(m), this.pager = d.text("", 15, 10).css(k.style).add(m), this.down = d.symbol("triangle-down", 0, 0, l, l).on("click", function() {
              b.scroll(1, j);
            }).add(m);
          b.scroll(0);
          a = f;
        } else if (m)
          r(c.chartHeight), m.hide(), this.scrollGroup.attr({translateY: 1}), this.clipHeight = 0;
        return a;
      },
      scroll: function(a, b) {
        var c = this.pages,
            d = c.length,
            e = this.currentPage + a,
            f = this.clipHeight,
            g = this.options.navigation,
            h = g.activeColor,
            g = g.inactiveColor,
            i = this.pager,
            k = this.padding;
        e > d && (e = d);
        if (e > 0)
          b !== y && Ta(b, this.chart), this.nav.attr({
            translateX: k,
            translateY: f + this.padding + 7 + this.titleHeight,
            visibility: "visible"
          }), this.up.attr({fill: e === 1 ? g : h}).css({cursor: e === 1 ? "default" : "pointer"}), i.attr({text: e + "/" + d}), this.down.attr({
            x: 18 + this.pager.getBBox().width,
            fill: e === d ? g : h
          }).css({cursor: e === d ? "default" : "pointer"}), c = -c[e - 1] + this.initialItemY, this.scrollGroup.animate({translateY: c}), this.currentPage = e, this.positionCheckboxes(c);
      }
    };
    K = x.LegendSymbolMixin = {
      drawRectangle: function(a, b) {
        var c = a.options.symbolHeight || a.fontMetrics.f;
        b.legendSymbol = this.chart.renderer.rect(0, a.baseline - c + 1, a.symbolWidth, c, a.options.symbolRadius || 0).attr({zIndex: 3}).add(b.legendGroup);
      },
      drawLineMarker: function(a) {
        var b = this.options,
            c = b.marker,
            d = a.symbolWidth,
            e = this.chart.renderer,
            f = this.legendGroup,
            a = a.baseline - B(a.fontMetrics.b * 0.3),
            g;
        if (b.lineWidth) {
          g = {"stroke-width": b.lineWidth};
          if (b.dashStyle)
            g.dashstyle = b.dashStyle;
          this.legendLine = e.path(["M", 0, a, "L", d, a]).attr(g).add(f);
        }
        if (c && c.enabled !== !1)
          b = c.radius, this.legendSymbol = c = e.symbol(this.symbol, d / 2 - b, a - b, 2 * b, 2 * b, c).add(f), c.isMarker = !0;
      }
    };
    (/Trident\/7\.0/.test(za) || Na) && fb(ob.prototype, "positionItem", function(a, b) {
      var c = this,
          d = function() {
            b._legendItemPos && a.call(c, b);
          };
      d();
      setTimeout(d);
    });
    var gb = x.Chart = function() {
      this.getArgs.apply(this, arguments);
    };
    x.chart = function(a, b, c) {
      return new gb(a, b, c);
    };
    gb.prototype = {
      callbacks: [],
      getArgs: function() {
        var a = [].slice.call(arguments);
        if (xa(a[0]) || a[0].nodeName)
          this.renderTo = a.shift();
        this.init(a[0], a[1]);
      },
      init: function(a, b) {
        var c,
            d = a.series;
        a.series = null;
        c = E(U, a);
        c.series = a.series = d;
        this.userOptions = a;
        d = c.chart;
        this.margin = this.splashArray("margin", d);
        this.spacing = this.splashArray("spacing", d);
        var e = d.events;
        this.bounds = {
          h: {},
          v: {}
        };
        this.callback = b;
        this.isResizing = 0;
        this.options = c;
        this.axes = [];
        this.series = [];
        this.hasCartesianSeries = d.showAxes;
        var f = this,
            g;
        f.index = T.length;
        T.push(f);
        eb++;
        d.reflow !== !1 && N(f, "load", function() {
          f.initReflow();
        });
        if (e)
          for (g in e)
            N(f, g, e[g]);
        f.xAxis = [];
        f.yAxis = [];
        f.animation = ka ? !1 : o(d.animation, !0);
        f.pointCount = f.colorCounter = f.symbolCounter = 0;
        f.firstRender();
      },
      initSeries: function(a) {
        var b = this.options.chart;
        (b = L[a.type || b.type || b.defaultSeriesType]) || aa(17, !0);
        b = new b;
        b.init(this, a);
        return b;
      },
      isInsidePlot: function(a, b, c) {
        var d = c ? b : a,
            a = c ? a : b;
        return d >= 0 && d <= this.plotWidth && a >= 0 && a <= this.plotHeight;
      },
      redraw: function(a) {
        var b = this.axes,
            c = this.series,
            d = this.pointer,
            e = this.legend,
            f = this.isDirtyLegend,
            g,
            h,
            i = this.hasCartesianSeries,
            k = this.isDirtyBox,
            j = c.length,
            l = j,
            m = this.renderer,
            n = m.isHidden(),
            q = [];
        Ta(a, this);
        n && this.cloneRenderTo();
        for (this.layOutTitles(); l--; )
          if (a = c[l], a.options.stacking && (g = !0, a.isDirty)) {
            h = !0;
            break;
          }
        if (h)
          for (l = j; l--; )
            if (a = c[l], a.options.stacking)
              a.isDirty = !0;
        p(c, function(a) {
          a.isDirty && a.options.legendType === "point" && (a.updateTotals && a.updateTotals(), f = !0);
          a.isDirtyData && I(a, "updatedData");
        });
        if (f && e.options.enabled)
          e.render(), this.isDirtyLegend = !1;
        g && this.getStacks();
        if (i && !this.isResizing)
          this.maxTicks = null, p(b, function(a) {
            a.setScale();
          });
        this.getMargins();
        i && (p(b, function(a) {
          a.isDirty && (k = !0);
        }), p(b, function(a) {
          var b = a.min + "," + a.max;
          if (a.extKey !== b)
            a.extKey = b, q.push(function() {
              I(a, "afterSetExtremes", u(a.eventArgs, a.getExtremes()));
              delete a.eventArgs;
            });
          (k || g) && a.redraw();
        }));
        k && this.drawChartBox();
        p(c, function(a) {
          a.isDirty && a.visible && (!a.isCartesian || a.xAxis) && a.redraw();
        });
        d && d.reset(!0);
        m.draw();
        I(this, "redraw");
        n && this.cloneRenderTo(!0);
        p(q, function(a) {
          a.call();
        });
      },
      get: function(a) {
        var b = this.axes,
            c = this.series,
            d,
            e;
        for (d = 0; d < b.length; d++)
          if (b[d].options.id === a)
            return b[d];
        for (d = 0; d < c.length; d++)
          if (c[d].options.id === a)
            return c[d];
        for (d = 0; d < c.length; d++) {
          e = c[d].points || [];
          for (b = 0; b < e.length; b++)
            if (e[b].id === a)
              return e[b];
        }
        return null;
      },
      getAxes: function() {
        var a = this,
            b = this.options,
            c = b.xAxis = ta(b.xAxis || {}),
            b = b.yAxis = ta(b.yAxis || {});
        p(c, function(a, b) {
          a.index = b;
          a.isX = !0;
        });
        p(b, function(a, b) {
          a.index = b;
        });
        c = c.concat(b);
        p(c, function(b) {
          new ha(a, b);
        });
      },
      getSelectedPoints: function() {
        var a = [];
        p(this.series, function(b) {
          a = a.concat(Ba(b.points || [], function(a) {
            return a.selected;
          }));
        });
        return a;
      },
      getSelectedSeries: function() {
        return Ba(this.series, function(a) {
          return a.selected;
        });
      },
      setTitle: function(a, b, c) {
        var g;
        var d = this,
            e = d.options,
            f;
        f = e.title = E(e.title, a);
        g = e.subtitle = E(e.subtitle, b), e = g;
        p([["title", a, f], ["subtitle", b, e]], function(a) {
          var b = a[0],
              c = d[b],
              e = a[1],
              a = a[2];
          c && e && (d[b] = c = c.destroy());
          a && a.text && !c && (d[b] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({
            align: a.align,
            "class": "highcharts-" + b,
            zIndex: a.zIndex || 4
          }).css(a.style).add());
        });
        d.layOutTitles(c);
      },
      layOutTitles: function(a) {
        var b = 0,
            c = this.title,
            d = this.subtitle,
            e = this.options,
            f = e.title,
            e = e.subtitle,
            g = this.renderer,
            h = this.spacingBox;
        if (c && (c.css({width: (f.width || h.width + f.widthAdjust) + "px"}).align(u({y: g.fontMetrics(f.style.fontSize, c).b - 3}, f), !1, h), !f.floating && !f.verticalAlign))
          b = c.getBBox().height;
        d && (d.css({width: (e.width || h.width + e.widthAdjust) + "px"}).align(u({y: b + (f.margin - 13) + g.fontMetrics(e.style.fontSize, c).b}, e), !1, h), !e.floating && !e.verticalAlign && (b = ua(b + d.getBBox().height)));
        c = this.titleOffset !== b;
        this.titleOffset = b;
        if (!this.isDirtyBox && c)
          this.isDirtyBox = c, this.hasRendered && o(a, !0) && this.isDirtyBox && this.redraw();
      },
      getChartSize: function() {
        var a = this.options.chart,
            b = a.width,
            a = a.height,
            c = this.renderToClone || this.renderTo;
        if (!r(b))
          this.containerWidth = na(c, "width");
        if (!r(a))
          this.containerHeight = na(c, "height");
        this.chartWidth = t(0, b || this.containerWidth || 600);
        this.chartHeight = t(0, o(a, this.containerHeight > 19 ? this.containerHeight : 400));
      },
      cloneRenderTo: function(a) {
        var b = this.renderToClone,
            c = this.container;
        a ? b && (this.renderTo.appendChild(c), Sa(b), delete this.renderToClone) : (c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), this.renderToClone = b = this.renderTo.cloneNode(0), M(b, {
          position: "absolute",
          top: "-9999px",
          display: "block"
        }), b.style.setProperty && b.style.setProperty("display", "block", "important"), A.body.appendChild(b), c && b.appendChild(c));
      },
      getContainer: function() {
        var a,
            b = this.options,
            c = b.chart,
            d,
            e;
        a = this.renderTo;
        var f = "highcharts-" + yb++;
        if (!a)
          this.renderTo = a = c.renderTo;
        if (xa(a))
          this.renderTo = a = A.getElementById(a);
        a || aa(13, !0);
        d = C(P(a, "data-highcharts-chart"));
        J(d) && T[d] && T[d].hasRendered && T[d].destroy();
        P(a, "data-highcharts-chart", this.index);
        a.innerHTML = "";
        !c.skipClone && !a.offsetWidth && this.cloneRenderTo();
        this.getChartSize();
        d = this.chartWidth;
        e = this.chartHeight;
        this.container = a = ba(Ma, {
          className: "highcharts-container" + (c.className ? " " + c.className : ""),
          id: f
        }, u({
          position: "relative",
          overflow: "hidden",
          width: d + "px",
          height: e + "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
        }, c.style), this.renderToClone || a);
        this._cursor = a.style.cursor;
        this.renderer = new (x[c.renderer] || cb)(a, d, e, c.style, c.forExport, b.exporting && b.exporting.allowHTML);
        ka && this.renderer.create(this, a, d, e);
        this.renderer.chartIndex = this.index;
      },
      getMargins: function(a) {
        var b = this.spacing,
            c = this.margin,
            d = this.titleOffset;
        this.resetMargins();
        if (d && !r(c[0]))
          this.plotTop = t(this.plotTop, d + this.options.title.margin + b[0]);
        this.legend.adjustMargins(c, b);
        this.extraBottomMargin && (this.marginBottom += this.extraBottomMargin);
        this.extraTopMargin && (this.plotTop += this.extraTopMargin);
        a || this.getAxisMargins();
      },
      getAxisMargins: function() {
        var a = this,
            b = a.axisOffset = [0, 0, 0, 0],
            c = a.margin;
        a.hasCartesianSeries && p(a.axes, function(a) {
          a.visible && a.getOffset();
        });
        p(nb, function(d, e) {
          r(c[e]) || (a[d] += b[e]);
        });
        a.setChartSize();
      },
      reflow: function(a) {
        var b = this,
            c = b.options.chart,
            d = b.renderTo,
            e = c.width || na(d, "width"),
            f = c.height || na(d, "height"),
            c = a ? a.target : D;
        if (!b.hasUserSize && !b.isPrinting && e && f && (c === D || c === A)) {
          if (e !== b.containerWidth || f !== b.containerHeight)
            clearTimeout(b.reflowTimeout), b.reflowTimeout = Pa(function() {
              if (b.container)
                b.setSize(e, f, !1), b.hasUserSize = null;
            }, a ? 100 : 0);
          b.containerWidth = e;
          b.containerHeight = f;
        }
      },
      initReflow: function() {
        var a = this,
            b = function(b) {
              a.reflow(b);
            };
        N(D, "resize", b);
        N(a, "destroy", function() {
          X(D, "resize", b);
        });
      },
      setSize: function(a, b, c) {
        var d = this,
            e,
            f,
            g = d.renderer;
        d.isResizing += 1;
        Ta(c, d);
        d.oldChartHeight = d.chartHeight;
        d.oldChartWidth = d.chartWidth;
        if (r(a))
          d.chartWidth = e = t(0, B(a)), d.hasUserSize = !!e;
        if (r(b))
          d.chartHeight = f = t(0, B(b));
        a = g.globalAnimation;
        (a ? Wa : M)(d.container, {
          width: e + "px",
          height: f + "px"
        }, a);
        d.setChartSize(!0);
        g.setSize(e, f, c);
        d.maxTicks = null;
        p(d.axes, function(a) {
          a.isDirty = !0;
          a.setScale();
        });
        p(d.series, function(a) {
          a.isDirty = !0;
        });
        d.isDirtyLegend = !0;
        d.isDirtyBox = !0;
        d.layOutTitles();
        d.getMargins();
        d.redraw(c);
        d.oldChartHeight = null;
        I(d, "resize");
        Pa(function() {
          d && I(d, "endResize", null, function() {
            d.isResizing -= 1;
          });
        }, $a(a).duration);
      },
      setChartSize: function(a) {
        var b = this.inverted,
            c = this.renderer,
            d = this.chartWidth,
            e = this.chartHeight,
            f = this.options.chart,
            g = this.spacing,
            h = this.clipOffset,
            i,
            k,
            j,
            l;
        this.plotLeft = i = B(this.plotLeft);
        this.plotTop = k = B(this.plotTop);
        this.plotWidth = j = t(0, B(d - i - this.marginRight));
        this.plotHeight = l = t(0, B(e - k - this.marginBottom));
        this.plotSizeX = b ? l : j;
        this.plotSizeY = b ? j : l;
        this.plotBorderWidth = f.plotBorderWidth || 0;
        this.spacingBox = c.spacingBox = {
          x: g[3],
          y: g[0],
          width: d - g[3] - g[1],
          height: e - g[0] - g[2]
        };
        this.plotBox = c.plotBox = {
          x: i,
          y: k,
          width: j,
          height: l
        };
        d = 2 * V(this.plotBorderWidth / 2);
        b = ua(t(d, h[3]) / 2);
        c = ua(t(d, h[0]) / 2);
        this.clipBox = {
          x: b,
          y: c,
          width: V(this.plotSizeX - t(d, h[1]) / 2 - b),
          height: t(0, V(this.plotSizeY - t(d, h[2]) / 2 - c))
        };
        a || p(this.axes, function(a) {
          a.setAxisSize();
          a.setAxisTranslation();
        });
      },
      resetMargins: function() {
        var a = this;
        p(nb, function(b, c) {
          a[b] = o(a.margin[c], a.spacing[c]);
        });
        a.axisOffset = [0, 0, 0, 0];
        a.clipOffset = [0, 0, 0, 0];
      },
      drawChartBox: function() {
        var a = this.options.chart,
            b = this.renderer,
            c = this.chartWidth,
            d = this.chartHeight,
            e = this.chartBackground,
            f = this.plotBackground,
            g = this.plotBorder,
            h = this.plotBGImage,
            i = a.borderWidth || 0,
            k = a.backgroundColor,
            j = a.plotBackgroundColor,
            l = a.plotBackgroundImage,
            m = a.plotBorderWidth || 0,
            n,
            q = this.plotLeft,
            o = this.plotTop,
            p = this.plotWidth,
            r = this.plotHeight,
            w = this.plotBox,
            v = this.clipRect,
            t = this.clipBox;
        n = i + (a.shadow ? 8 : 0);
        if (i || k)
          if (e)
            e.animate(e.crisp({
              width: c - n,
              height: d - n
            }));
          else {
            e = {fill: k || "none"};
            if (i)
              e.stroke = a.borderColor, e["stroke-width"] = i;
            this.chartBackground = b.rect(n / 2, n / 2, c - n, d - n, a.borderRadius, i).attr(e).addClass("highcharts-background").add().shadow(a.shadow);
          }
        if (j)
          f ? f.animate(w) : this.plotBackground = b.rect(q, o, p, r, 0).attr({fill: j}).add().shadow(a.plotShadow);
        if (l)
          h ? h.animate(w) : this.plotBGImage = b.image(l, q, o, p, r).add();
        v ? v.animate({
          width: t.width,
          height: t.height
        }) : this.clipRect = b.clipRect(t);
        if (m)
          g ? (g.strokeWidth = -m, g.animate(g.crisp({
            x: q,
            y: o,
            width: p,
            height: r
          }))) : this.plotBorder = b.rect(q, o, p, r, 0, -m).attr({
            stroke: a.plotBorderColor,
            "stroke-width": m,
            fill: "none",
            zIndex: 1
          }).add();
        this.isDirtyBox = !1;
      },
      propFromSeries: function() {
        var a = this,
            b = a.options.chart,
            c,
            d = a.options.series,
            e,
            f;
        p(["inverted", "angular", "polar"], function(g) {
          c = L[b.type || b.defaultSeriesType];
          f = a[g] || b[g] || c && c.prototype[g];
          for (e = d && d.length; !f && e--; )
            (c = L[d[e].type]) && c.prototype[g] && (f = !0);
          a[g] = f;
        });
      },
      linkSeries: function() {
        var a = this,
            b = a.series;
        p(b, function(a) {
          a.linkedSeries.length = 0;
        });
        p(b, function(b) {
          var d = b.options.linkedTo;
          if (xa(d) && (d = d === ":previous" ? a.series[b.index - 1] : a.get(d)))
            d.linkedSeries.push(b), b.linkedParent = d, b.visible = o(b.options.visible, d.options.visible, b.visible);
        });
      },
      renderSeries: function() {
        p(this.series, function(a) {
          a.translate();
          a.render();
        });
      },
      renderLabels: function() {
        var a = this,
            b = a.options.labels;
        b.items && p(b.items, function(c) {
          var d = u(b.style, c.style),
              e = C(d.left) + a.plotLeft,
              f = C(d.top) + a.plotTop + 12;
          delete d.left;
          delete d.top;
          a.renderer.text(c.html, e, f).attr({zIndex: 2}).css(d).add();
        });
      },
      render: function() {
        var a = this.axes,
            b = this.renderer,
            c = this.options,
            d,
            e,
            f,
            g;
        this.setTitle();
        this.legend = new ob(this, c.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        d = this.plotWidth;
        e = this.plotHeight -= 21;
        p(a, function(a) {
          a.setScale();
        });
        this.getAxisMargins();
        f = d / this.plotWidth > 1.1;
        g = e / this.plotHeight > 1.05;
        if (f || g)
          this.maxTicks = null, p(a, function(a) {
            (a.horiz && f || !a.horiz && g) && a.setTickInterval(!0);
          }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries && p(a, function(a) {
          a.visible && a.render();
        });
        if (!this.seriesGroup)
          this.seriesGroup = b.g("series-group").attr({zIndex: 3}).add();
        this.renderSeries();
        this.renderLabels();
        this.showCredits(c.credits);
        this.hasRendered = !0;
      },
      showCredits: function(a) {
        if (a.enabled && !this.credits)
          this.credits = this.renderer.text(a.text, 0, 0).on("click", function() {
            if (a.href)
              D.location.href = a.href;
          }).attr({
            align: a.position.align,
            zIndex: 8
          }).css(a.style).add().align(a.position);
      },
      destroy: function() {
        var a = this,
            b = a.axes,
            c = a.series,
            d = a.container,
            e,
            f = d && d.parentNode;
        I(a, "destroy");
        T[a.index] = y;
        eb--;
        a.renderTo.removeAttribute("data-highcharts-chart");
        X(a);
        for (e = b.length; e--; )
          b[e] = b[e].destroy();
        for (e = c.length; e--; )
          c[e] = c[e].destroy();
        p("title,subtitle,chartBackground,plotBackground,plotBGImage,plotBorder,seriesGroup,clipRect,credits,pointer,scroller,rangeSelector,legend,resetZoomButton,tooltip,renderer".split(","), function(b) {
          var c = a[b];
          c && c.destroy && (a[b] = c.destroy());
        });
        if (d)
          d.innerHTML = "", X(d), f && Sa(d);
        for (e in a)
          delete a[e];
      },
      isReadyToRender: function() {
        var a = this;
        return !fa && D == D.top && A.readyState !== "complete" || ka && !D.canvg ? (ka ? Nb.push(function() {
          a.firstRender();
        }, a.options.global.canvasToolsURL) : A.attachEvent("onreadystatechange", function() {
          A.detachEvent("onreadystatechange", a.firstRender);
          A.readyState === "complete" && a.firstRender();
        }), !1) : !0;
      },
      firstRender: function() {
        var a = this,
            b = a.options;
        if (a.isReadyToRender()) {
          a.getContainer();
          I(a, "init");
          a.resetMargins();
          a.setChartSize();
          a.propFromSeries();
          a.getAxes();
          p(b.series || [], function(b) {
            a.initSeries(b);
          });
          a.linkSeries();
          I(a, "beforeRender");
          if (x.Pointer)
            a.pointer = new Xa(a, b);
          a.render();
          a.renderer.draw();
          if (!a.renderer.imgCount && a.onload)
            a.onload();
          a.cloneRenderTo(!0);
        }
      },
      onload: function() {
        var a = this;
        p([this.callback].concat(this.callbacks), function(b) {
          b && a.index !== void 0 && b.apply(a, [a]);
        });
        I(a, "load");
        this.onload = null;
      },
      splashArray: function(a, b) {
        var c = b[a],
            c = Z(c) ? c : [c, c, c, c];
        return [o(b[a + "Top"], c[0]), o(b[a + "Right"], c[1]), o(b[a + "Bottom"], c[2]), o(b[a + "Left"], c[3])];
      }
    };
    var Bb = x.CenteredSeriesMixin = {getCenter: function() {
        var a = this.options,
            b = this.chart,
            c = 2 * (a.slicedOffset || 0),
            d = b.plotWidth - 2 * c,
            b = b.plotHeight - 2 * c,
            e = a.center,
            e = [o(e[0], "50%"), o(e[1], "50%"), a.size || "100%", a.innerSize || 0],
            f = F(d, b),
            g,
            h;
        for (g = 0; g < 4; ++g)
          h = e[g], a = g < 2 || g === 2 && /%$/.test(h), e[g] = (/%$/.test(h) ? [d, b, f, e[2]][g] * parseFloat(h) / 100 : parseFloat(h)) + (a ? c : 0);
        e[3] > e[2] && (e[3] = e[2]);
        return e;
      }},
        Ja = function() {};
    Ja.prototype = {
      init: function(a, b, c) {
        this.series = a;
        this.color = a.color;
        this.applyOptions(b, c);
        this.pointAttr = {};
        if (a.options.colorByPoint && (b = a.options.colors || a.chart.options.colors, this.color = this.color || b[a.colorCounter++], a.colorCounter === b.length))
          a.colorCounter = 0;
        a.chart.pointCount++;
        return this;
      },
      applyOptions: function(a, b) {
        var c = this.series,
            d = c.options.pointValKey || c.pointValKey,
            a = Ja.prototype.optionsToObject.call(this, a);
        u(this, a);
        this.options = this.options ? u(this.options, a) : a;
        if (d)
          this.y = this[d];
        this.isNull = this.x === null || this.y === null;
        if (this.x === void 0 && c)
          this.x = b === void 0 ? c.autoIncrement() : b;
        return this;
      },
      optionsToObject: function(a) {
        var b = {},
            c = this.series,
            d = c.options.keys,
            e = d || c.pointArrayMap || ["y"],
            f = e.length,
            g = 0,
            h = 0;
        if (J(a) || a === null)
          b[e[0]] = a;
        else if (Ea(a)) {
          if (!d && a.length > f) {
            c = typeof a[0];
            if (c === "string")
              b.name = a[0];
            else if (c === "number")
              b.x = a[0];
            g++;
          }
          for (; h < f; ) {
            if (!d || a[g] !== void 0)
              b[e[h]] = a[g];
            g++;
            h++;
          }
        } else if (typeof a === "object") {
          b = a;
          if (a.dataLabels)
            c._hasPointLabels = !0;
          if (a.marker)
            c._hasPointMarkers = !0;
        }
        return b;
      },
      destroy: function() {
        var a = this.series.chart,
            b = a.hoverPoints,
            c;
        a.pointCount--;
        if (b && (this.setState(), pa(b, this), !b.length))
          a.hoverPoints = null;
        if (this === a.hoverPoint)
          this.onMouseOut();
        if (this.graphic || this.dataLabel)
          X(this), this.destroyElements();
        this.legendItem && a.legend.destroyItem(this);
        for (c in this)
          this[c] = null;
      },
      destroyElements: function() {
        for (var a = ["graphic", "dataLabel", "dataLabelUpper", "connector", "shadowGroup"],
            b,
            c = 6; c--; )
          b = a[c], this[b] && (this[b] = this[b].destroy());
      },
      getLabelConfig: function() {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      },
      tooltipFormatter: function(a) {
        var b = this.series,
            c = b.tooltipOptions,
            d = o(c.valueDecimals, ""),
            e = c.valuePrefix || "",
            f = c.valueSuffix || "";
        p(b.pointArrayMap || ["y"], function(b) {
          b = "{point." + b;
          if (e || f)
            a = a.replace(b + "}", e + b + "}" + f);
          a = a.replace(b + "}", b + ":,." + d + "f}");
        });
        return Ka(a, {
          point: this,
          series: this.series
        });
      },
      firePointEvent: function(a, b, c) {
        var d = this,
            e = this.series.options;
        (e.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents();
        a === "click" && e.allowPointSelect && (c = function(a) {
          d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
        });
        I(this, a, b, c);
      },
      visible: !0
    };
    var R = x.Series = function() {};
    R.prototype = {
      isCartesian: !0,
      type: "line",
      pointClass: Ja,
      sorted: !0,
      requireSorting: !0,
      pointAttrToOptions: {
        stroke: "lineColor",
        "stroke-width": "lineWidth",
        fill: "fillColor",
        r: "radius"
      },
      directTouch: !1,
      axisTypes: ["xAxis", "yAxis"],
      colorCounter: 0,
      parallelArrays: ["x", "y"],
      init: function(a, b) {
        var c = this,
            d,
            e,
            f = a.series,
            g = function(a, b) {
              return o(a.options.index, a._i) - o(b.options.index, b._i);
            };
        c.chart = a;
        c.options = b = c.setOptions(b);
        c.linkedSeries = [];
        c.bindAxes();
        u(c, {
          name: b.name,
          state: "",
          pointAttr: {},
          visible: b.visible !== !1,
          selected: b.selected === !0
        });
        if (ka)
          b.animation = !1;
        e = b.events;
        for (d in e)
          N(c, d, e[d]);
        if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect)
          a.runTrackerClick = !0;
        c.getColor();
        c.getSymbol();
        p(c.parallelArrays, function(a) {
          c[a + "Data"] = [];
        });
        c.setData(b.data, !1);
        if (c.isCartesian)
          a.hasCartesianSeries = !0;
        f.push(c);
        c._i = f.length - 1;
        hb(f, g);
        this.yAxis && hb(this.yAxis.series, g);
        p(f, function(a, b) {
          a.index = b;
          a.name = a.name || "Series " + (b + 1);
        });
      },
      bindAxes: function() {
        var a = this,
            b = a.options,
            c = a.chart,
            d;
        p(a.axisTypes || [], function(e) {
          p(c[e], function(c) {
            d = c.options;
            if (b[e] === d.index || b[e] !== y && b[e] === d.id || b[e] === y && d.index === 0)
              c.series.push(a), a[e] = c, c.isDirty = !0;
          });
          !a[e] && a.optionalAxis !== e && aa(18, !0);
        });
      },
      updateParallelArrays: function(a, b) {
        var c = a.series,
            d = arguments,
            e = J(b) ? function(d) {
              var e = d === "y" && c.toYData ? c.toYData(a) : a[d];
              c[d + "Data"][b] = e;
            } : function(a) {
              Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2));
            };
        p(c.parallelArrays, e);
      },
      autoIncrement: function() {
        var a = this.options,
            b = this.xIncrement,
            c,
            d = a.pointIntervalUnit,
            b = o(b, a.pointStart, 0);
        this.pointInterval = c = o(this.pointInterval, a.pointInterval, 1);
        d && (a = new la(b), d === "day" ? a = +a[kb](a[Ua]() + c) : d === "month" ? a = +a[wb](a[ab]() + c) : d === "year" && (a = +a[xb](a[bb]() + c)), c = a - b);
        this.xIncrement = b + c;
        return b;
      },
      setOptions: function(a) {
        var b = this.chart,
            c = b.options.plotOptions,
            b = b.userOptions || {},
            d = b.plotOptions || {},
            e = c[this.type];
        this.userOptions = a;
        c = E(e, c.series, a);
        this.tooltipOptions = E(U.tooltip, U.plotOptions[this.type].tooltip, b.tooltip, d.series && d.series.tooltip, d[this.type] && d[this.type].tooltip, a.tooltip);
        e.marker === null && delete c.marker;
        this.zoneAxis = c.zoneAxis;
        a = this.zones = (c.zones || []).slice();
        if ((c.negativeColor || c.negativeFillColor) && !c.zones)
          a.push({
            value: c[this.zoneAxis + "Threshold"] || c.threshold || 0,
            color: c.negativeColor,
            fillColor: c.negativeFillColor
          });
        a.length && r(a[a.length - 1].value) && a.push({
          color: this.color,
          fillColor: this.fillColor
        });
        return c;
      },
      getCyclic: function(a, b, c) {
        var d = this.userOptions,
            e = "_" + a + "Index",
            f = a + "Counter";
        b || (r(d[e]) ? b = d[e] : (d[e] = b = this.chart[f] % c.length, this.chart[f] += 1), b = c[b]);
        this[a] = b;
      },
      getColor: function() {
        this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || ea[this.type].color, this.chart.options.colors);
      },
      getSymbol: function() {
        var a = this.options.marker;
        this.getCyclic("symbol", a.symbol, this.chart.options.symbols);
        if (/^url/.test(this.symbol))
          a.radius = 0;
      },
      drawLegendSymbol: K.drawLineMarker,
      setData: function(a, b, c, d) {
        var e = this,
            f = e.points,
            g = f && f.length || 0,
            h,
            i = e.options,
            k = e.chart,
            j = null,
            l = e.xAxis,
            m = l && !!l.categories,
            n = i.turboThreshold,
            q = this.xData,
            z = this.yData,
            s = (h = e.pointArrayMap) && h.length,
            a = a || [];
        h = a.length;
        b = o(b, !0);
        if (d !== !1 && h && g === h && !e.cropped && !e.hasGroupedData && e.visible)
          p(a, function(a, b) {
            f[b].update && a !== i.data[b] && f[b].update(a, !1, null, !1);
          });
        else {
          e.xIncrement = null;
          e.colorCounter = 0;
          p(this.parallelArrays, function(a) {
            e[a + "Data"].length = 0;
          });
          if (n && h > n) {
            for (c = 0; j === null && c < h; )
              j = a[c], c++;
            if (J(j)) {
              m = o(i.pointStart, 0);
              j = o(i.pointInterval, 1);
              for (c = 0; c < h; c++)
                q[c] = m, z[c] = a[c], m += j;
              e.xIncrement = m;
            } else if (Ea(j))
              if (s)
                for (c = 0; c < h; c++)
                  j = a[c], q[c] = j[0], z[c] = j.slice(1, s + 1);
              else
                for (c = 0; c < h; c++)
                  j = a[c], q[c] = j[0], z[c] = j[1];
            else
              aa(12);
          } else
            for (c = 0; c < h; c++)
              if (a[c] !== y && (j = {series: e}, e.pointClass.prototype.applyOptions.apply(j, [a[c]]), e.updateParallelArrays(j, c), m && r(j.name)))
                l.names[j.x] = j.name;
          xa(z[0]) && aa(14, !0);
          e.data = [];
          e.options.data = e.userOptions.data = a;
          for (c = g; c--; )
            f[c] && f[c].destroy && f[c].destroy();
          if (l)
            l.minRange = l.userMinRange;
          e.isDirty = e.isDirtyData = k.isDirtyBox = !0;
          c = !1;
        }
        i.legendType === "point" && (this.processData(), this.generatePoints());
        b && k.redraw(c);
      },
      processData: function(a) {
        var b = this.xData,
            c = this.yData,
            d = b.length,
            e;
        e = 0;
        var f,
            g,
            h = this.xAxis,
            i,
            k = this.options;
        i = k.cropThreshold;
        var j = this.getExtremesFromAll || k.getExtremesFromAll,
            l = this.isCartesian,
            k = h && h.val2lin,
            m = h && h.isLog,
            n,
            q;
        if (l && !this.isDirty && !h.isDirty && !this.yAxis.isDirty && !a)
          return !1;
        if (h)
          a = h.getExtremes(), n = a.min, q = a.max;
        if (l && this.sorted && !j && (!i || d > i || this.forceCrop))
          if (b[d - 1] < n || b[0] > q)
            b = [], c = [];
          else if (b[0] < n || b[d - 1] > q)
            e = this.cropData(this.xData, this.yData, n, q), b = e.xData, c = e.yData, e = e.start, f = !0;
        for (i = b.length || 1; --i; )
          d = m ? k(b[i]) - k(b[i - 1]) : b[i] - b[i - 1], d > 0 && (g === y || d < g) ? g = d : d < 0 && this.requireSorting && aa(15);
        this.cropped = f;
        this.cropStart = e;
        this.processedXData = b;
        this.processedYData = c;
        this.closestPointRange = g;
      },
      cropData: function(a, b, c, d) {
        var e = a.length,
            f = 0,
            g = e,
            h = o(this.cropShoulder, 1),
            i;
        for (i = 0; i < e; i++)
          if (a[i] >= c) {
            f = t(0, i - h);
            break;
          }
        for (c = i; c < e; c++)
          if (a[c] > d) {
            g = c + h;
            break;
          }
        return {
          xData: a.slice(f, g),
          yData: b.slice(f, g),
          start: f,
          end: g
        };
      },
      generatePoints: function() {
        var a = this.options.data,
            b = this.data,
            c,
            d = this.processedXData,
            e = this.processedYData,
            f = this.pointClass,
            g = d.length,
            h = this.cropStart || 0,
            i,
            k = this.hasGroupedData,
            j,
            l = [],
            m;
        if (!b && !k)
          b = [], b.length = a.length, b = this.data = b;
        for (m = 0; m < g; m++)
          i = h + m, k ? (l[m] = (new f).init(this, [d[m]].concat(ta(e[m]))), l[m].dataGroup = this.groupMap[m]) : (b[i] ? j = b[i] : a[i] !== y && (b[i] = j = (new f).init(this, a[i], d[m])), l[m] = j), l[m].index = i;
        if (b && (g !== (c = b.length) || k))
          for (m = 0; m < c; m++)
            if (m === h && !k && (m += g), b[m])
              b[m].destroyElements(), b[m].plotX = y;
        this.data = b;
        this.points = l;
      },
      getExtremes: function(a) {
        var b = this.yAxis,
            c = this.processedXData,
            d,
            e = [],
            f = 0;
        d = this.xAxis.getExtremes();
        var g = d.min,
            h = d.max,
            i,
            k,
            j,
            l,
            a = a || this.stackedYData || this.processedYData || [];
        d = a.length;
        for (l = 0; l < d; l++)
          if (k = c[l], j = a[l], i = j !== null && j !== y && (!b.isLog || j.length || j > 0), k = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c[l + 1] || k) >= g && (c[l - 1] || k) <= h, i && k)
            if (i = j.length)
              for (; i--; )
                j[i] !== null && (e[f++] = j[i]);
            else
              e[f++] = j;
        this.dataMin = La(e);
        this.dataMax = Ga(e);
      },
      translate: function() {
        this.processedXData || this.processData();
        this.generatePoints();
        for (var a = this.options,
            b = a.stacking,
            c = this.xAxis,
            d = c.categories,
            e = this.yAxis,
            f = this.points,
            g = f.length,
            h = !!this.modifyValue,
            i = a.pointPlacement,
            k = i === "between" || J(i),
            j = a.threshold,
            l = a.startFromThreshold ? j : 0,
            m,
            n,
            q,
            p,
            s = Number.MAX_VALUE,
            a = 0; a < g; a++) {
          var G = f[a],
              w = G.x,
              v = G.y;
          n = G.low;
          var u = b && e.stacks[(this.negStacks && v < (l ? 0 : j) ? "-" : "") + this.stackKey];
          if (e.isLog && v !== null && v <= 0)
            G.y = v = null, aa(10);
          G.plotX = m = ca(F(t(-1E5, c.translate(w, 0, 0, 0, 1, i, this.type === "flags")), 1E5));
          if (b && this.visible && !G.isNull && u && u[w])
            p = this.getStackIndicator(p, w, this.index), u = u[w], v = u.points[p.key], n = v[0], v = v[1], n === l && (n = o(j, e.min)), e.isLog && n <= 0 && (n = null), G.total = G.stackTotal = u.total, G.percentage = u.total && G.y / u.total * 100, G.stackY = v, u.setOffset(this.pointXOffset || 0, this.barW || 0);
          G.yBottom = r(n) ? e.translate(n, 0, 1, 0, 1) : null;
          h && (v = this.modifyValue(v, G));
          G.plotY = n = typeof v === "number" && v !== Infinity ? F(t(-1E5, e.translate(v, 0, 1, 0, 1)), 1E5) : y;
          G.isInside = n !== y && n >= 0 && n <= e.len && m >= 0 && m <= c.len;
          G.clientX = k ? c.translate(w, 0, 0, 0, 1) : m;
          G.negative = G.y < (j || 0);
          G.category = d && d[G.x] !== y ? d[G.x] : G.x;
          G.isNull || (q !== void 0 && (s = F(s, Q(m - q))), q = m);
        }
        this.closestPointRangePx = s;
      },
      getValidPoints: function(a, b) {
        var c = this.chart;
        return Ba(a || this.points || [], function(a) {
          return b && !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : !a.isNull;
        });
      },
      setClip: function(a) {
        var b = this.chart,
            c = this.options,
            d = b.renderer,
            e = b.inverted,
            f = this.clipBox,
            g = f || b.clipBox,
            h = this.sharedClipKey || ["_sharedClip", a && a.duration, a && a.easing, g.height, c.xAxis, c.yAxis].join(","),
            i = b[h],
            k = b[h + "m"];
        if (!i) {
          if (a)
            g.width = 0, b[h + "m"] = k = d.clipRect(-99, e ? -b.plotLeft : -b.plotTop, 99, e ? b.chartWidth : b.chartHeight);
          b[h] = i = d.clipRect(g);
        }
        a && (i.count += 1);
        if (c.clip !== !1)
          this.group.clip(a || f ? i : b.clipRect), this.markerGroup.clip(k), this.sharedClipKey = h;
        a || (i.count -= 1, i.count <= 0 && h && b[h] && (f || (b[h] = b[h].destroy()), b[h + "m"] && (b[h + "m"] = b[h + "m"].destroy())));
      },
      animate: function(a) {
        var b = this.chart,
            c = this.options.animation,
            d;
        if (c && !Z(c))
          c = ea[this.type].animation;
        a ? this.setClip(c) : (d = this.sharedClipKey, (a = b[d]) && a.animate({width: b.plotSizeX}, c), b[d + "m"] && b[d + "m"].animate({width: b.plotSizeX + 99}, c), this.animate = null);
      },
      afterAnimate: function() {
        this.setClip();
        I(this, "afterAnimate");
      },
      drawPoints: function() {
        var a,
            b = this.points,
            c = this.chart,
            d,
            e,
            f,
            g,
            h,
            i,
            k,
            j,
            l = this.options.marker,
            m = this.pointAttr[""],
            n,
            q,
            p,
            s = this.markerGroup,
            r = o(l.enabled, this.xAxis.isRadial, this.closestPointRangePx > 2 * l.radius);
        if (l.enabled !== !1 || this._hasPointMarkers)
          for (f = b.length; f--; )
            if (g = b[f], d = V(g.plotX), e = g.plotY, j = g.graphic, n = g.marker || {}, q = !!g.marker, a = r && n.enabled === y || n.enabled, p = g.isInside, a && J(e) && g.y !== null)
              if (a = g.pointAttr[g.selected ? "select" : ""] || m, h = a.r, i = o(n.symbol, this.symbol), k = i.indexOf("url") === 0, j)
                j[p ? "show" : "hide"](!0).attr(a).animate(u({
                  x: d - h,
                  y: e - h
                }, j.symbolName ? {
                  width: 2 * h,
                  height: 2 * h
                } : {}));
              else {
                if (p && (h > 0 || k))
                  g.graphic = c.renderer.symbol(i, d - h, e - h, 2 * h, 2 * h, q ? n : l).attr(a).add(s);
              }
            else if (j)
              g.graphic = j.destroy();
      },
      convertAttribs: function(a, b, c, d) {
        var e = this.pointAttrToOptions,
            f,
            g,
            h = {},
            a = a || {},
            b = b || {},
            c = c || {},
            d = d || {};
        for (f in e)
          g = e[f], h[f] = o(a[g], b[f], c[f], d[f]);
        return h;
      },
      getAttribs: function() {
        var a = this,
            b = a.options,
            c = ea[a.type].marker ? b.marker : b,
            d = c.states,
            e = d.hover,
            f,
            g = a.color,
            h = a.options.negativeColor,
            i = {
              stroke: g,
              fill: g
            },
            k = a.points || [],
            j,
            l = [],
            m,
            n = a.pointAttrToOptions;
        f = a.hasPointSpecificOptions;
        var q = c.lineColor,
            z = c.fillColor;
        j = b.turboThreshold;
        var s = a.zones,
            t = a.zoneAxis || "y",
            w,
            v;
        b.marker ? (e.radius = e.radius || c.radius + e.radiusPlus, e.lineWidth = e.lineWidth || c.lineWidth + e.lineWidthPlus) : (e.color = e.color || ma(e.color || g).brighten(e.brightness).get(), e.negativeColor = e.negativeColor || ma(e.negativeColor || h).brighten(e.brightness).get());
        l[""] = a.convertAttribs(c, i);
        p(["hover", "select"], function(b) {
          l[b] = a.convertAttribs(d[b], l[""]);
        });
        a.pointAttr = l;
        g = k.length;
        if (!j || g < j || f)
          for (; g--; ) {
            j = k[g];
            if ((c = j.options && j.options.marker || j.options) && c.enabled === !1)
              c.radius = 0;
            i = null;
            if (s.length) {
              f = 0;
              for (i = s[f]; j[t] >= i.value; )
                i = s[++f];
              j.color = j.fillColor = i = o(i.color, a.color);
            }
            f = b.colorByPoint || j.color;
            if (j.options)
              for (v in n)
                r(c[n[v]]) && (f = !0);
            if (f) {
              c = c || {};
              m = [];
              d = c.states || {};
              f = d.hover = d.hover || {};
              if (!b.marker || j.negative && !f.fillColor && !e.fillColor)
                f[a.pointAttrToOptions.fill] = f.color || !j.options.color && e[j.negative && h ? "negativeColor" : "color"] || ma(j.color).brighten(f.brightness || e.brightness).get();
              w = {color: j.color};
              if (!z)
                w.fillColor = j.color;
              if (!q)
                w.lineColor = j.color;
              c.hasOwnProperty("color") && !c.color && delete c.color;
              if (i && !e.fillColor)
                f.fillColor = i;
              m[""] = a.convertAttribs(u(w, c), l[""]);
              m.hover = a.convertAttribs(d.hover, l.hover, m[""]);
              m.select = a.convertAttribs(d.select, l.select, m[""]);
            } else
              m = l;
            j.pointAttr = m;
          }
      },
      destroy: function() {
        var a = this,
            b = a.chart,
            c = /AppleWebKit\/533/.test(za),
            d,
            e = a.data || [],
            f,
            g,
            h;
        I(a, "destroy");
        X(a);
        p(a.axisTypes || [], function(b) {
          if (h = a[b])
            pa(h.series, a), h.isDirty = h.forceRedraw = !0;
        });
        a.legendItem && a.chart.legend.destroyItem(a);
        for (d = e.length; d--; )
          (f = e[d]) && f.destroy && f.destroy();
        a.points = null;
        clearTimeout(a.animationTimeout);
        for (g in a)
          a[g] instanceof O && !a[g].survive && (d = c && g === "group" ? "hide" : "destroy", a[g][d]());
        if (b.hoverSeries === a)
          b.hoverSeries = null;
        pa(b.series, a);
        for (g in a)
          delete a[g];
      },
      getGraphPath: function(a, b, c) {
        var d = this,
            e = d.options,
            f = e.step,
            g,
            h = [],
            i,
            a = a || d.points;
        (g = a.reversed) && a.reverse();
        (f = {
          right: 1,
          center: 2
        }[f] || f && 3) && g && (f = 4 - f);
        e.connectNulls && !b && !c && (a = this.getValidPoints(a));
        p(a, function(g, j) {
          var l = g.plotX,
              m = g.plotY,
              n = a[j - 1];
          if ((g.leftCliff || n && n.rightCliff) && !c)
            i = !0;
          g.isNull && !r(b) && j > 0 ? i = !e.connectNulls : g.isNull && !b ? i = !0 : (j === 0 || i ? n = ["M", g.plotX, g.plotY] : d.getPointSpline ? n = d.getPointSpline(a, g, j) : f ? (n = f === 1 ? ["L", n.plotX, m] : f === 2 ? ["L", (n.plotX + l) / 2, n.plotY, "L", (n.plotX + l) / 2, m] : ["L", l, n.plotY], n.push("L", l, m)) : n = ["L", l, m], h.push.apply(h, n), i = !1);
        });
        return d.graphPath = h;
      },
      drawGraph: function() {
        var a = this,
            b = this.options,
            c = [["graph", b.lineColor || this.color, b.dashStyle]],
            d = b.lineWidth,
            e = b.linecap !== "square",
            f = (this.gappedPath || this.getGraphPath).call(this),
            g = this.fillGraph && this.color || "none";
        p(this.zones, function(d, e) {
          c.push(["zoneGraph" + e, d.color || a.color, d.dashStyle || b.dashStyle]);
        });
        p(c, function(c, i) {
          var k = c[0],
              j = a[k];
          if (j)
            j.animate({d: f});
          else if ((d || g) && f.length)
            j = {
              stroke: c[1],
              "stroke-width": d,
              fill: g,
              zIndex: 1
            }, c[2] ? j.dashstyle = c[2] : e && (j["stroke-linecap"] = j["stroke-linejoin"] = "round"), a[k] = a.chart.renderer.path(f).attr(j).add(a.group).shadow(i < 2 && b.shadow);
        });
      },
      applyZones: function() {
        var a = this,
            b = this.chart,
            c = b.renderer,
            d = this.zones,
            e,
            f,
            g = this.clips || [],
            h,
            i = this.graph,
            k = this.area,
            j = t(b.chartWidth, b.chartHeight),
            l = this[(this.zoneAxis || "y") + "Axis"],
            m,
            n = l.reversed,
            q = b.inverted,
            z = l.horiz,
            s,
            r,
            w,
            v = !1;
        if (d.length && (i || k) && l.min !== y)
          i && i.hide(), k && k.hide(), m = l.getExtremes(), p(d, function(d, p) {
            e = n ? z ? b.plotWidth : 0 : z ? 0 : l.toPixels(m.min);
            e = F(t(o(f, e), 0), j);
            f = F(t(B(l.toPixels(o(d.value, m.max), !0)), 0), j);
            v && (e = f = l.toPixels(m.max));
            s = Math.abs(e - f);
            r = F(e, f);
            w = t(e, f);
            if (l.isXAxis) {
              if (h = {
                x: q ? w : r,
                y: 0,
                width: s,
                height: j
              }, !z)
                h.x = b.plotHeight - h.x;
            } else if (h = {
              x: 0,
              y: q ? w : r,
              width: j,
              height: s
            }, z)
              h.y = b.plotWidth - h.y;
            b.inverted && c.isVML && (h = l.isXAxis ? {
              x: 0,
              y: n ? r : w,
              height: h.width,
              width: b.chartWidth
            } : {
              x: h.y - b.plotLeft - b.spacingBox.x,
              y: 0,
              width: h.height,
              height: b.chartHeight
            });
            g[p] ? g[p].animate(h) : (g[p] = c.clipRect(h), i && a["zoneGraph" + p].clip(g[p]), k && a["zoneArea" + p].clip(g[p]));
            v = d.value > m.max;
          }), this.clips = g;
      },
      invertGroups: function() {
        function a() {
          var a = {
            width: b.yAxis.len,
            height: b.xAxis.len
          };
          p(["group", "markerGroup"], function(c) {
            b[c] && b[c].attr(a).invert();
          });
        }
        var b = this,
            c = b.chart;
        if (b.xAxis)
          N(c, "resize", a), N(b, "destroy", function() {
            X(c, "resize", a);
          }), a(), b.invertGroups = a;
      },
      plotGroup: function(a, b, c, d, e) {
        var f = this[a],
            g = !f;
        g && (this[a] = f = this.chart.renderer.g(b).attr({zIndex: d || 0.1}).add(e), f.addClass("highcharts-series-" + this.index));
        f.attr({visibility: c})[g ? "attr" : "animate"](this.getPlotBox());
        return f;
      },
      getPlotBox: function() {
        var a = this.chart,
            b = this.xAxis,
            c = this.yAxis;
        if (a.inverted)
          b = c, c = this.xAxis;
        return {
          translateX: b ? b.left : a.plotLeft,
          translateY: c ? c.top : a.plotTop,
          scaleX: 1,
          scaleY: 1
        };
      },
      render: function() {
        var a = this,
            b = a.chart,
            c,
            d = a.options,
            e = !!a.animate && b.renderer.isSVG && $a(d.animation).duration,
            f = a.visible ? "inherit" : "hidden",
            g = d.zIndex,
            h = a.hasRendered,
            i = b.seriesGroup;
        c = a.plotGroup("group", "series", f, g, i);
        a.markerGroup = a.plotGroup("markerGroup", "markers", f, g, i);
        e && a.animate(!0);
        a.getAttribs();
        c.inverted = a.isCartesian ? b.inverted : !1;
        a.drawGraph && (a.drawGraph(), a.applyZones());
        p(a.points, function(a) {
          a.redraw && a.redraw();
        });
        a.drawDataLabels && a.drawDataLabels();
        a.visible && a.drawPoints();
        a.drawTracker && a.options.enableMouseTracking !== !1 && a.drawTracker();
        b.inverted && a.invertGroups();
        d.clip !== !1 && !a.sharedClipKey && !h && c.clip(b.clipRect);
        e && a.animate();
        if (!h)
          a.animationTimeout = Pa(function() {
            a.afterAnimate();
          }, e);
        a.isDirty = a.isDirtyData = !1;
        a.hasRendered = !0;
      },
      redraw: function() {
        var a = this.chart,
            b = this.isDirty || this.isDirtyData,
            c = this.group,
            d = this.xAxis,
            e = this.yAxis;
        c && (a.inverted && c.attr({
          width: a.plotWidth,
          height: a.plotHeight
        }), c.animate({
          translateX: o(d && d.left, a.plotLeft),
          translateY: o(e && e.top, a.plotTop)
        }));
        this.translate();
        this.render();
        b && delete this.kdTree;
      },
      kdDimensions: 1,
      kdAxisArray: ["clientX", "plotY"],
      searchPoint: function(a, b) {
        var c = this.xAxis,
            d = this.yAxis,
            e = this.chart.inverted;
        return this.searchKDTree({
          clientX: e ? c.len - a.chartY + c.pos : a.chartX - c.pos,
          plotY: e ? d.len - a.chartX + d.pos : a.chartY - d.pos
        }, b);
      },
      buildKDTree: function() {
        function a(c, e, f) {
          var g,
              h;
          if (h = c && c.length)
            return g = b.kdAxisArray[e % f], c.sort(function(a, b) {
              return a[g] - b[g];
            }), h = Math.floor(h / 2), {
              point: c[h],
              left: a(c.slice(0, h), e + 1, f),
              right: a(c.slice(h + 1), e + 1, f)
            };
        }
        var b = this,
            c = b.kdDimensions;
        delete b.kdTree;
        Pa(function() {
          b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c);
        }, b.options.kdNow ? 0 : 1);
      },
      searchKDTree: function(a, b) {
        function c(a, b, k, j) {
          var l = b.point,
              m = d.kdAxisArray[k % j],
              n,
              q,
              o = l;
          q = r(a[e]) && r(l[e]) ? Math.pow(a[e] - l[e], 2) : null;
          n = r(a[f]) && r(l[f]) ? Math.pow(a[f] - l[f], 2) : null;
          n = (q || 0) + (n || 0);
          l.dist = r(n) ? Math.sqrt(n) : Number.MAX_VALUE;
          l.distX = r(q) ? Math.sqrt(q) : Number.MAX_VALUE;
          m = a[m] - l[m];
          n = m < 0 ? "left" : "right";
          q = m < 0 ? "right" : "left";
          b[n] && (n = c(a, b[n], k + 1, j), o = n[g] < o[g] ? n : l);
          b[q] && Math.sqrt(m * m) < o[g] && (a = c(a, b[q], k + 1, j), o = a[g] < o[g] ? a : o);
          return o;
        }
        var d = this,
            e = this.kdAxisArray[0],
            f = this.kdAxisArray[1],
            g = b ? "distX" : "dist";
        this.kdTree || this.buildKDTree();
        if (this.kdTree)
          return c(a, this.kdTree, this.kdDimensions, this.kdDimensions);
      }
    };
    Jb.prototype = {
      destroy: function() {
        Ra(this, this.axis);
      },
      render: function(a) {
        var b = this.options,
            c = b.format,
            c = c ? Ka(c, this) : b.formatter.call(this);
        this.label ? this.label.attr({
          text: c,
          visibility: "hidden"
        }) : this.label = this.axis.chart.renderer.text(c, null, null, b.useHTML).css(b.style).attr({
          align: this.textAlign,
          rotation: b.rotation,
          visibility: "hidden"
        }).add(a);
      },
      setOffset: function(a, b) {
        var c = this.axis,
            d = c.chart,
            e = d.inverted,
            f = c.reversed,
            f = this.isNegative && !f || !this.isNegative && f,
            g = c.translate(c.usePercentage ? 100 : this.total, 0, 0, 0, 1),
            c = c.translate(0),
            c = Q(g - c),
            h = d.xAxis[0].translate(this.x) + a,
            i = d.plotHeight,
            f = {
              x: e ? f ? g : g - c : h,
              y: e ? i - h - b : f ? i - g - c : i - g,
              width: e ? c : b,
              height: e ? b : c
            };
        if (e = this.label)
          e.align(this.alignOptions, null, f), f = e.alignAttr, e[this.options.crop === !1 || d.isInsidePlot(f.x, f.y) ? "show" : "hide"](!0);
      }
    };
    gb.prototype.getStacks = function() {
      var a = this;
      p(a.yAxis, function(a) {
        if (a.stacks && a.hasVisibleSeries)
          a.oldStacks = a.stacks;
      });
      p(a.series, function(b) {
        if (b.options.stacking && (b.visible === !0 || a.options.chart.ignoreHiddenSeries === !1))
          b.stackKey = b.type + o(b.options.stack, "");
      });
    };
    ha.prototype.buildStacks = function() {
      var a = this.series,
          b,
          c = o(this.options.reversedStacks, !0),
          d = a.length,
          e;
      if (!this.isXAxis) {
        this.usePercentage = !1;
        for (e = d; e--; )
          a[c ? e : d - e - 1].setStackedPoints();
        for (e = d; e--; )
          b = a[c ? e : d - e - 1], b.setStackCliffs && b.setStackCliffs();
        if (this.usePercentage)
          for (e = 0; e < d; e++)
            a[e].setPercentStacks();
      }
    };
    ha.prototype.renderStackTotals = function() {
      var a = this.chart,
          b = a.renderer,
          c = this.stacks,
          d,
          e,
          f = this.stackTotalGroup;
      if (!f)
        this.stackTotalGroup = f = b.g("stack-labels").attr({
          visibility: "visible",
          zIndex: 6
        }).add();
      f.translate(a.plotLeft, a.plotTop);
      for (d in c)
        for (e in a = c[d], a)
          a[e].render(f);
    };
    ha.prototype.resetStacks = function() {
      var a = this.stacks,
          b,
          c;
      if (!this.isXAxis)
        for (b in a)
          for (c in a[b])
            a[b][c].touched < this.stacksTouched ? (a[b][c].destroy(), delete a[b][c]) : (a[b][c].total = null, a[b][c].cum = 0);
    };
    ha.prototype.cleanStacks = function() {
      var a,
          b,
          c;
      if (!this.isXAxis) {
        if (this.oldStacks)
          a = this.stacks = this.oldStacks;
        for (b in a)
          for (c in a[b])
            a[b][c].cum = a[b][c].total;
      }
    };
    R.prototype.setStackedPoints = function() {
      if (this.options.stacking && !(this.visible !== !0 && this.chart.options.chart.ignoreHiddenSeries !== !1)) {
        var a = this.processedXData,
            b = this.processedYData,
            c = [],
            d = b.length,
            e = this.options,
            f = e.threshold,
            g = e.startFromThreshold ? f : 0,
            h = e.stack,
            e = e.stacking,
            i = this.stackKey,
            k = "-" + i,
            j = this.negStacks,
            l = this.yAxis,
            m = l.stacks,
            n = l.oldStacks,
            q,
            p,
            s,
            r,
            w,
            v,
            u;
        l.stacksTouched += 1;
        for (w = 0; w < d; w++) {
          v = a[w];
          u = b[w];
          q = this.getStackIndicator(q, v, this.index);
          r = q.key;
          s = (p = j && u < (g ? 0 : f)) ? k : i;
          m[s] || (m[s] = {});
          if (!m[s][v])
            n[s] && n[s][v] ? (m[s][v] = n[s][v], m[s][v].total = null) : m[s][v] = new Jb(l, l.options.stackLabels, p, v, h);
          s = m[s][v];
          if (u !== null)
            s.points[r] = s.points[this.index] = [o(s.cum, g)], s.touched = l.stacksTouched, q.index > 0 && this.singleStacks === !1 && (s.points[r][0] = s.points[this.index + "," + v + ",0"][0]);
          e === "percent" ? (p = p ? i : k, j && m[p] && m[p][v] ? (p = m[p][v], s.total = p.total = t(p.total, s.total) + Q(u) || 0) : s.total = ca(s.total + (Q(u) || 0))) : s.total = ca(s.total + (u || 0));
          s.cum = o(s.cum, g) + (u || 0);
          if (u !== null)
            s.points[r].push(s.cum), c[w] = s.cum;
        }
        if (e === "percent")
          l.usePercentage = !0;
        this.stackedYData = c;
        l.oldStacks = {};
      }
    };
    R.prototype.setPercentStacks = function() {
      var a = this,
          b = a.stackKey,
          c = a.yAxis.stacks,
          d = a.processedXData,
          e;
      p([b, "-" + b], function(b) {
        var f;
        for (var g = d.length,
            h,
            i; g--; )
          if (h = d[g], e = a.getStackIndicator(e, h, a.index), f = (i = c[b] && c[b][h]) && i.points[e.key], h = f)
            i = i.total ? 100 / i.total : 0, h[0] = ca(h[0] * i), h[1] = ca(h[1] * i), a.stackedYData[g] = h[1];
      });
    };
    R.prototype.getStackIndicator = function(a, b, c) {
      !r(a) || a.x !== b ? a = {
        x: b,
        index: 0
      } : a.index++;
      a.key = [c, b, a.index].join(",");
      return a;
    };
    u(gb.prototype, {
      addSeries: function(a, b, c) {
        var d,
            e = this;
        a && (b = o(b, !0), I(e, "addSeries", {options: a}, function() {
          d = e.initSeries(a);
          e.isDirtyLegend = !0;
          e.linkSeries();
          b && e.redraw(c);
        }));
        return d;
      },
      addAxis: function(a, b, c, d) {
        var e = b ? "xAxis" : "yAxis",
            f = this.options,
            a = E(a, {
              index: this[e].length,
              isX: b
            });
        new ha(this, a);
        f[e] = ta(f[e] || {});
        f[e].push(a);
        o(c, !0) && this.redraw(d);
      },
      showLoading: function(a) {
        var b = this,
            c = b.options,
            d = b.loadingDiv,
            e = c.loading,
            f = function() {
              d && M(d, {
                left: b.plotLeft + "px",
                top: b.plotTop + "px",
                width: b.plotWidth + "px",
                height: b.plotHeight + "px"
              });
            };
        if (!d)
          b.loadingDiv = d = ba(Ma, {className: "highcharts-loading"}, u(e.style, {
            zIndex: 10,
            display: "none"
          }), b.container), b.loadingSpan = ba("span", null, e.labelStyle, d), N(b, "redraw", f);
        b.loadingSpan.innerHTML = a || c.lang.loading;
        if (!b.loadingShown)
          M(d, {
            opacity: 0,
            display: ""
          }), Wa(d, {opacity: e.style.opacity}, {duration: e.showDuration || 0}), b.loadingShown = !0;
        f();
      },
      hideLoading: function() {
        var a = this.options,
            b = this.loadingDiv;
        b && Wa(b, {opacity: 0}, {
          duration: a.loading.hideDuration || 100,
          complete: function() {
            M(b, {display: "none"});
          }
        });
        this.loadingShown = !1;
      }
    });
    u(Ja.prototype, {
      update: function(a, b, c, d) {
        function e() {
          f.applyOptions(a);
          if (f.y === null && h)
            f.graphic = h.destroy();
          if (Z(a) && !Ea(a))
            f.redraw = function() {
              if (h && h.element && a && a.marker && a.marker.symbol)
                f.graphic = h.destroy();
              if (a && a.dataLabels && f.dataLabel)
                f.dataLabel = f.dataLabel.destroy();
              f.redraw = null;
            };
          i = f.index;
          g.updateParallelArrays(f, i);
          if (l && f.name)
            l[f.x] = f.name;
          j.data[i] = Z(j.data[i]) && !Ea(j.data[i]) ? f.options : a;
          g.isDirty = g.isDirtyData = !0;
          if (!g.fixedBox && g.hasCartesianSeries)
            k.isDirtyBox = !0;
          if (j.legendType === "point")
            k.isDirtyLegend = !0;
          b && k.redraw(c);
        }
        var f = this,
            g = f.series,
            h = f.graphic,
            i,
            k = g.chart,
            j = g.options,
            l = g.xAxis && g.xAxis.names,
            b = o(b, !0);
        d === !1 ? e() : f.firePointEvent("update", {options: a}, e);
      },
      remove: function(a, b) {
        this.series.removePoint(sa(this, this.series.data), a, b);
      }
    });
    u(R.prototype, {
      addPoint: function(a, b, c, d) {
        var e = this,
            f = e.options,
            g = e.data,
            h = e.graph,
            i = e.area,
            k = e.chart,
            j = e.xAxis && e.xAxis.names,
            l = h && h.shift || 0,
            m = ["graph", "area"],
            h = f.data,
            n,
            q = e.xData;
        Ta(d, k);
        if (c) {
          for (d = e.zones.length; d--; )
            m.push("zoneGraph" + d, "zoneArea" + d);
          p(m, function(a) {
            if (e[a])
              e[a].shift = l + (f.step ? 2 : 1);
          });
        }
        if (i)
          i.isArea = !0;
        b = o(b, !0);
        i = {series: e};
        e.pointClass.prototype.applyOptions.apply(i, [a]);
        m = i.x;
        d = q.length;
        if (e.requireSorting && m < q[d - 1])
          for (n = !0; d && q[d - 1] > m; )
            d--;
        e.updateParallelArrays(i, "splice", d, 0, 0);
        e.updateParallelArrays(i, d);
        if (j && i.name)
          j[m] = i.name;
        h.splice(d, 0, a);
        n && (e.data.splice(d, 0, null), e.processData());
        f.legendType === "point" && e.generatePoints();
        c && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), e.updateParallelArrays(i, "shift"), h.shift()));
        e.isDirty = !0;
        e.isDirtyData = !0;
        b && (e.getAttribs(), k.redraw());
      },
      removePoint: function(a, b, c) {
        var d = this,
            e = d.data,
            f = e[a],
            g = d.points,
            h = d.chart,
            i = function() {
              g && g.length === e.length && g.splice(a, 1);
              e.splice(a, 1);
              d.options.data.splice(a, 1);
              d.updateParallelArrays(f || {series: d}, "splice", a, 1);
              f && f.destroy();
              d.isDirty = !0;
              d.isDirtyData = !0;
              b && h.redraw();
            };
        Ta(c, h);
        b = o(b, !0);
        f ? f.firePointEvent("remove", null, i) : i();
      },
      remove: function(a, b) {
        var c = this,
            d = c.chart;
        I(c, "remove", null, function() {
          c.destroy();
          d.isDirtyLegend = d.isDirtyBox = !0;
          d.linkSeries();
          o(a, !0) && d.redraw(b);
        });
      },
      update: function(a, b) {
        var c = this,
            d = this.chart,
            e = this.userOptions,
            f = this.type,
            g = L[f].prototype,
            h = ["group", "markerGroup", "dataLabelsGroup"],
            i;
        if (a.type && a.type !== f || a.zIndex !== void 0)
          h.length = 0;
        p(h, function(a) {
          h[a] = c[a];
          delete c[a];
        });
        a = E(e, {
          animation: !1,
          index: this.index,
          pointStart: this.xData[0]
        }, {data: this.options.data}, a);
        this.remove(!1);
        for (i in g)
          this[i] = y;
        u(this, L[a.type || f].prototype);
        p(h, function(a) {
          c[a] = h[a];
        });
        this.init(d, a);
        d.linkSeries();
        o(b, !0) && d.redraw(!1);
      }
    });
    u(ha.prototype, {
      update: function(a, b) {
        var c = this.chart,
            a = c.options[this.coll][this.options.index] = E(this.userOptions, a);
        this.destroy(!0);
        this._addedPlotLB = this.chart._labelPanes = y;
        this.init(c, u(a, {events: y}));
        c.isDirtyBox = !0;
        o(b, !0) && c.redraw();
      },
      remove: function(a) {
        for (var b = this.chart,
            c = this.coll,
            d = this.series,
            e = d.length; e--; )
          d[e] && d[e].remove(!1);
        pa(b.axes, this);
        pa(b[c], this);
        b.options[c].splice(this.options.index, 1);
        p(b[c], function(a, b) {
          a.options.index = b;
        });
        this.destroy();
        b.isDirtyBox = !0;
        o(a, !0) && b.redraw();
      },
      setTitle: function(a, b) {
        this.update({title: a}, b);
      },
      setCategories: function(a, b) {
        this.update({categories: a}, b);
      }
    });
    var wa = qa(R);
    L.line = wa;
    ea.area = E(ga, {
      softThreshold: !1,
      threshold: 0
    });
    var oa = qa(R, {
      type: "area",
      singleStacks: !1,
      getStackPoints: function() {
        var a = [],
            b = [],
            c = this.xAxis,
            d = this.yAxis,
            e = d.stacks[this.stackKey],
            f = {},
            g = this.points,
            h = this.index,
            i = d.series,
            k = i.length,
            j,
            l = o(d.options.reversedStacks, !0) ? 1 : -1,
            m,
            n;
        if (this.options.stacking) {
          for (m = 0; m < g.length; m++)
            f[g[m].x] = g[m];
          for (n in e)
            e[n].total !== null && b.push(n);
          b.sort(function(a, b) {
            return a - b;
          });
          j = Ca(i, function() {
            return this.visible;
          });
          p(b, function(g, i) {
            var n = 0,
                o,
                r;
            if (f[g] && !f[g].isNull)
              a.push(f[g]), p([-1, 1], function(a) {
                var c = a === 1 ? "rightNull" : "leftNull",
                    d = 0,
                    n = e[b[i + a]];
                if (n)
                  for (m = h; m >= 0 && m < k; )
                    o = n.points[m], o || (m === h ? f[g][c] = !0 : j[m] && (r = e[g].points[m]) && (d -= r[1] - r[0])), m += l;
                f[g][a === 1 ? "rightCliff" : "leftCliff"] = d;
              });
            else {
              for (m = h; m >= 0 && m < k; ) {
                if (o = e[g].points[m]) {
                  n = o[1];
                  break;
                }
                m += l;
              }
              n = d.toPixels(n, !0);
              a.push({
                isNull: !0,
                plotX: c.toPixels(g, !0),
                plotY: n,
                yBottom: n
              });
            }
          });
        }
        return a;
      },
      getGraphPath: function(a) {
        var b = R.prototype.getGraphPath,
            c = this.options,
            d = c.stacking,
            e = this.yAxis,
            f,
            g,
            h = [],
            i = [],
            k = this.index,
            j,
            l = e.stacks[this.stackKey],
            m = c.threshold,
            n = e.getThreshold(c.threshold),
            q,
            c = c.connectNulls || d === "percent",
            p = function(b, c, f) {
              var g = a[b],
                  b = d && l[g.x].points[k],
                  q = g[f + "Null"] || 0,
                  f = g[f + "Cliff"] || 0,
                  o,
                  p,
                  g = !0;
              f || q ? (o = (q ? b[0] : b[1]) + f, p = b[0] + f, g = !!q) : !d && a[c] && a[c].isNull && (o = p = m);
              o !== void 0 && (i.push({
                plotX: j,
                plotY: o === null ? n : e.getThreshold(o),
                isNull: g
              }), h.push({
                plotX: j,
                plotY: p === null ? n : e.getThreshold(p)
              }));
            },
            a = a || this.points;
        d && (a = this.getStackPoints());
        for (f = 0; f < a.length; f++)
          if (g = a[f].isNull, j = o(a[f].rectPlotX, a[f].plotX), q = o(a[f].yBottom, n), !g || c) {
            c || p(f, f - 1, "left");
            if (!g || d || !c)
              i.push(a[f]), h.push({
                x: f,
                plotX: j,
                plotY: q
              });
            c || p(f, f + 1, "right");
          }
        f = b.call(this, i, !0, !0);
        h.reversed = !0;
        g = b.call(this, h, !0, !0);
        g.length && (g[0] = "L");
        f = f.concat(g);
        b = b.call(this, i, !1, c);
        this.areaPath = f;
        return b;
      },
      drawGraph: function() {
        this.areaPath = [];
        R.prototype.drawGraph.apply(this);
        var a = this,
            b = this.areaPath,
            c = this.options,
            d = [["area", this.color, c.fillColor]];
        p(this.zones, function(b, f) {
          d.push(["zoneArea" + f, b.color || a.color, b.fillColor || c.fillColor]);
        });
        p(d, function(d) {
          var f = d[0],
              g = a[f];
          g ? g.animate({d: b}) : (g = {
            fill: d[2] || d[1],
            zIndex: 0
          }, d[2] || (g["fill-opacity"] = o(c.fillOpacity, 0.75)), a[f] = a.chart.renderer.path(b).attr(g).add(a.group));
        });
      },
      drawLegendSymbol: K.drawRectangle
    });
    L.area = oa;
    ea.spline = E(ga);
    wa = qa(R, {
      type: "spline",
      getPointSpline: function(a, b, c) {
        var d = b.plotX,
            e = b.plotY,
            f = a[c - 1],
            c = a[c + 1],
            g,
            h,
            i,
            k;
        if (f && !f.isNull && c && !c.isNull) {
          a = f.plotY;
          i = c.plotX;
          var c = c.plotY,
              j = 0;
          g = (1.5 * d + f.plotX) / 2.5;
          h = (1.5 * e + a) / 2.5;
          i = (1.5 * d + i) / 2.5;
          k = (1.5 * e + c) / 2.5;
          i !== g && (j = (k - h) * (i - d) / (i - g) + e - k);
          h += j;
          k += j;
          h > a && h > e ? (h = t(a, e), k = 2 * e - h) : h < a && h < e && (h = F(a, e), k = 2 * e - h);
          k > c && k > e ? (k = t(c, e), h = 2 * e - k) : k < c && k < e && (k = F(c, e), h = 2 * e - k);
          b.rightContX = i;
          b.rightContY = k;
        }
        b = ["C", o(f.rightContX, f.plotX), o(f.rightContY, f.plotY), o(g, d), o(h, e), d, e];
        f.rightContX = f.rightContY = null;
        return b;
      }
    });
    L.spline = wa;
    ea.areaspline = E(ea.area);
    oa = oa.prototype;
    wa = qa(wa, {
      type: "areaspline",
      getStackPoints: oa.getStackPoints,
      getGraphPath: oa.getGraphPath,
      setStackCliffs: oa.setStackCliffs,
      drawGraph: oa.drawGraph,
      drawLegendSymbol: K.drawRectangle
    });
    L.areaspline = wa;
    ea.column = E(ga, {
      borderColor: "#FFFFFF",
      borderRadius: 0,
      groupPadding: 0.2,
      marker: null,
      pointPadding: 0.1,
      minPointLength: 0,
      cropThreshold: 50,
      pointRange: null,
      states: {
        hover: {
          brightness: 0.1,
          shadow: !1,
          halo: !1
        },
        select: {
          color: "#C0C0C0",
          borderColor: "#000000",
          shadow: !1
        }
      },
      dataLabels: {
        align: null,
        verticalAlign: null,
        y: null
      },
      softThreshold: !1,
      startFromThreshold: !0,
      stickyTracking: !1,
      tooltip: {distance: 6},
      threshold: 0
    });
    wa = qa(R, {
      type: "column",
      pointAttrToOptions: {
        stroke: "borderColor",
        fill: "color",
        r: "borderRadius"
      },
      cropShoulder: 0,
      directTouch: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      negStacks: !0,
      init: function() {
        R.prototype.init.apply(this, arguments);
        var a = this,
            b = a.chart;
        b.hasRendered && p(b.series, function(b) {
          if (b.type === a.type)
            b.isDirty = !0;
        });
      },
      getColumnMetrics: function() {
        var a = this,
            b = a.options,
            c = a.xAxis,
            d = a.yAxis,
            e = c.reversed,
            f,
            g = {},
            h = 0;
        b.grouping === !1 ? h = 1 : p(a.chart.series, function(b) {
          var c = b.options,
              e = b.yAxis,
              i;
          if (b.type === a.type && b.visible && d.len === e.len && d.pos === e.pos)
            c.stacking ? (f = b.stackKey, g[f] === y && (g[f] = h++), i = g[f]) : c.grouping !== !1 && (i = h++), b.columnIndex = i;
        });
        var i = F(Q(c.transA) * (c.ordinalSlope || b.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),
            k = i * b.groupPadding,
            j = (i - 2 * k) / h,
            b = F(b.maxPointWidth || c.len, o(b.pointWidth, j * (1 - 2 * b.pointPadding)));
        a.columnMetrics = {
          width: b,
          offset: (j - b) / 2 + (k + ((a.columnIndex || 0) + (e ? 1 : 0)) * j - i / 2) * (e ? -1 : 1)
        };
        return a.columnMetrics;
      },
      crispCol: function(a, b, c, d) {
        var e = this.chart,
            f = this.borderWidth,
            g = -(f % 2 ? 0.5 : 0),
            f = f % 2 ? 0.5 : 1;
        e.inverted && e.renderer.isVML && (f += 1);
        c = Math.round(a + c) + g;
        a = Math.round(a) + g;
        c -= a;
        d = Math.round(b + d) + f;
        g = Q(b) <= 0.5 && d > 0.5;
        b = Math.round(b) + f;
        d -= b;
        g && d && (b -= 1, d += 1);
        return {
          x: a,
          y: b,
          width: c,
          height: d
        };
      },
      translate: function() {
        var a = this,
            b = a.chart,
            c = a.options,
            d = a.borderWidth = o(c.borderWidth, a.closestPointRange * a.xAxis.transA < 2 ? 0 : 1),
            e = a.yAxis,
            f = a.translatedThreshold = e.getThreshold(c.threshold),
            g = o(c.minPointLength, 5),
            h = a.getColumnMetrics(),
            i = h.width,
            k = a.barW = t(i, 1 + 2 * d),
            j = a.pointXOffset = h.offset;
        b.inverted && (f -= 0.5);
        c.pointPadding && (k = ua(k));
        R.prototype.translate.apply(a);
        p(a.points, function(c) {
          var d = F(o(c.yBottom, f), 9E4),
              h = 999 + Q(d),
              h = F(t(-h, c.plotY), e.len + h),
              q = c.plotX + j,
              p = k,
              s = F(h, d),
              r,
              w = t(h, d) - s;
          Q(w) < g && g && (w = g, r = !e.reversed && !c.negative || e.reversed && c.negative, s = Q(s - f) > g ? d - g : f - (r ? g : 0));
          c.barX = q;
          c.pointWidth = i;
          c.tooltipPos = b.inverted ? [e.len + e.pos - b.plotLeft - h, a.xAxis.len - q - p / 2, w] : [q + p / 2, h + e.pos - b.plotTop, w];
          c.shapeType = "rect";
          c.shapeArgs = a.crispCol(q, s, p, w);
        });
      },
      getSymbol: Aa,
      drawLegendSymbol: K.drawRectangle,
      drawGraph: Aa,
      drawPoints: function() {
        var a = this,
            b = this.chart,
            c = a.options,
            d = b.renderer,
            e = c.animationLimit || 250,
            f,
            g;
        p(a.points, function(h) {
          var i = h.graphic,
              k;
          if (J(h.plotY) && h.y !== null)
            f = h.shapeArgs, k = r(a.borderWidth) ? {"stroke-width": a.borderWidth} : {}, g = h.pointAttr[h.selected ? "select" : ""] || a.pointAttr[""], i ? (Oa(i), i.attr(k).attr(g)[b.pointCount < e ? "animate" : "attr"](E(f))) : h.graphic = d[h.shapeType](f).attr(k).attr(g).add(h.group || a.group).shadow(c.shadow, null, c.stacking && !c.borderRadius);
          else if (i)
            h.graphic = i.destroy();
        });
      },
      animate: function(a) {
        var b = this,
            c = this.yAxis,
            d = b.options,
            e = this.chart.inverted,
            f = {};
        if (fa)
          a ? (f.scaleY = 0.001, a = F(c.pos + c.len, t(c.pos, c.toPixels(d.threshold))), e ? f.translateX = a - c.len : f.translateY = a, b.group.attr(f)) : (f[e ? "translateX" : "translateY"] = c.pos, b.group.animate(f, u($a(b.options.animation), {step: function(a, c) {
              b.group.attr({scaleY: t(0.001, c.pos)});
            }})), b.animate = null);
      },
      remove: function() {
        var a = this,
            b = a.chart;
        b.hasRendered && p(b.series, function(b) {
          if (b.type === a.type)
            b.isDirty = !0;
        });
        R.prototype.remove.apply(a, arguments);
      }
    });
    L.column = wa;
    ea.bar = E(ea.column);
    oa = qa(wa, {
      type: "bar",
      inverted: !0
    });
    L.bar = oa;
    ea.scatter = E(ga, {
      lineWidth: 0,
      marker: {enabled: !0},
      tooltip: {
        headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
        pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
      }
    });
    oa = qa(R, {
      type: "scatter",
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1,
      kdDimensions: 2,
      drawGraph: function() {
        this.options.lineWidth && R.prototype.drawGraph.call(this);
      }
    });
    L.scatter = oa;
    ea.pie = E(ga, {
      borderColor: "#FFFFFF",
      borderWidth: 1,
      center: [null, null],
      clip: !1,
      colorByPoint: !0,
      dataLabels: {
        distance: 30,
        enabled: !0,
        formatter: function() {
          return this.y === null ? void 0 : this.point.name;
        },
        x: 0
      },
      ignoreHiddenPoint: !0,
      legendType: "point",
      marker: null,
      size: null,
      showInLegend: !1,
      slicedOffset: 10,
      states: {hover: {
          brightness: 0.1,
          shadow: !1
        }},
      stickyTracking: !1,
      tooltip: {followPointer: !0}
    });
    ga = {
      type: "pie",
      isCartesian: !1,
      pointClass: qa(Ja, {
        init: function() {
          Ja.prototype.init.apply(this, arguments);
          var a = this,
              b;
          a.name = o(a.name, "Slice");
          b = function(b) {
            a.slice(b.type === "select");
          };
          N(a, "select", b);
          N(a, "unselect", b);
          return a;
        },
        setVisible: function(a, b) {
          var c = this,
              d = c.series,
              e = d.chart,
              f = d.options.ignoreHiddenPoint,
              b = o(b, f);
          if (a !== c.visible) {
            c.visible = c.options.visible = a = a === y ? !c.visible : a;
            d.options.data[sa(c, d.data)] = c.options;
            p(["graphic", "dataLabel", "connector", "shadowGroup"], function(b) {
              if (c[b])
                c[b][a ? "show" : "hide"](!0);
            });
            c.legendItem && e.legend.colorizeItem(c, a);
            !a && c.state === "hover" && c.setState("");
            if (f)
              d.isDirty = !0;
            b && e.redraw();
          }
        },
        slice: function(a, b, c) {
          var d = this.series;
          Ta(c, d.chart);
          o(b, !0);
          this.sliced = this.options.sliced = a = r(a) ? a : !this.sliced;
          d.options.data[sa(this, d.data)] = this.options;
          a = a ? this.slicedTranslation : {
            translateX: 0,
            translateY: 0
          };
          this.graphic.animate(a);
          this.shadowGroup && this.shadowGroup.animate(a);
        },
        haloPath: function(a) {
          var b = this.shapeArgs,
              c = this.series.chart;
          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.plotLeft + b.x, c.plotTop + b.y, b.r + a, b.r + a, {
            innerR: this.shapeArgs.r,
            start: b.start,
            end: b.end
          });
        }
      }),
      requireSorting: !1,
      directTouch: !0,
      noSharedTooltip: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      axisTypes: [],
      pointAttrToOptions: {
        stroke: "borderColor",
        "stroke-width": "borderWidth",
        fill: "color"
      },
      animate: function(a) {
        var b = this,
            c = b.points,
            d = b.startAngleRad;
        if (!a)
          p(c, function(a) {
            var c = a.graphic,
                g = a.shapeArgs;
            c && (c.attr({
              r: a.startR || b.center[3] / 2,
              start: d,
              end: d
            }), c.animate({
              r: g.r,
              start: g.start,
              end: g.end
            }, b.options.animation));
          }), b.animate = null;
      },
      updateTotals: function() {
        var a,
            b = 0,
            c = this.points,
            d = c.length,
            e,
            f = this.options.ignoreHiddenPoint;
        for (a = 0; a < d; a++)
          e = c[a], b += f && !e.visible ? 0 : e.y;
        this.total = b;
        for (a = 0; a < d; a++)
          e = c[a], e.percentage = b > 0 && (e.visible || !f) ? e.y / b * 100 : 0, e.total = b;
      },
      generatePoints: function() {
        R.prototype.generatePoints.call(this);
        this.updateTotals();
      },
      translate: function(a) {
        this.generatePoints();
        var b = 0,
            c = this.options,
            d = c.slicedOffset,
            e = d + c.borderWidth,
            f,
            g,
            h,
            i = c.startAngle || 0,
            k = this.startAngleRad = ra / 180 * (i - 90),
            i = (this.endAngleRad = ra / 180 * (o(c.endAngle, i + 360) - 90)) - k,
            j = this.points,
            l = c.dataLabels.distance,
            c = c.ignoreHiddenPoint,
            m,
            n = j.length,
            q;
        if (!a)
          this.center = a = this.getCenter();
        this.getX = function(b, c) {
          h = Y.asin(F((b - a[1]) / (a[2] / 2 + l), 1));
          return a[0] + (c ? -1 : 1) * W(h) * (a[2] / 2 + l);
        };
        for (m = 0; m < n; m++) {
          q = j[m];
          f = k + b * i;
          if (!c || q.visible)
            b += q.percentage / 100;
          g = k + b * i;
          q.shapeType = "arc";
          q.shapeArgs = {
            x: a[0],
            y: a[1],
            r: a[2] / 2,
            innerR: a[3] / 2,
            start: B(f * 1E3) / 1E3,
            end: B(g * 1E3) / 1E3
          };
          h = (g + f) / 2;
          h > 1.5 * ra ? h -= 2 * ra : h < -ra / 2 && (h += 2 * ra);
          q.slicedTranslation = {
            translateX: B(W(h) * d),
            translateY: B(da(h) * d)
          };
          f = W(h) * a[2] / 2;
          g = da(h) * a[2] / 2;
          q.tooltipPos = [a[0] + f * 0.7, a[1] + g * 0.7];
          q.half = h < -ra / 2 || h > ra / 2 ? 1 : 0;
          q.angle = h;
          e = F(e, l / 2);
          q.labelPos = [a[0] + f + W(h) * l, a[1] + g + da(h) * l, a[0] + f + W(h) * e, a[1] + g + da(h) * e, a[0] + f, a[1] + g, l < 0 ? "center" : q.half ? "right" : "left", h];
        }
      },
      drawGraph: null,
      drawPoints: function() {
        var a = this,
            b = a.chart.renderer,
            c,
            d,
            e = a.options.shadow,
            f,
            g,
            h,
            i;
        if (e && !a.shadowGroup)
          a.shadowGroup = b.g("shadow").add(a.group);
        p(a.points, function(k) {
          if (k.y !== null) {
            d = k.graphic;
            h = k.shapeArgs;
            f = k.shadowGroup;
            g = k.pointAttr[k.selected ? "select" : ""];
            if (!g.stroke)
              g.stroke = g.fill;
            if (e && !f)
              f = k.shadowGroup = b.g("shadow").add(a.shadowGroup);
            c = k.sliced ? k.slicedTranslation : {
              translateX: 0,
              translateY: 0
            };
            f && f.attr(c);
            if (d)
              d.setRadialReference(a.center).attr(g).animate(u(h, c));
            else {
              i = {"stroke-linejoin": "round"};
              if (!k.visible)
                i.visibility = "hidden";
              k.graphic = d = b[k.shapeType](h).setRadialReference(a.center).attr(g).attr(i).attr(c).add(a.group).shadow(e, f);
            }
          }
        });
      },
      searchPoint: Aa,
      sortByAngle: function(a, b) {
        a.sort(function(a, d) {
          return a.angle !== void 0 && (d.angle - a.angle) * b;
        });
      },
      drawLegendSymbol: K.drawRectangle,
      getCenter: Bb.getCenter,
      getSymbol: Aa
    };
    ga = qa(R, ga);
    L.pie = ga;
    R.prototype.drawDataLabels = function() {
      var a = this,
          b = a.options,
          c = b.cursor,
          d = b.dataLabels,
          e = a.points,
          f,
          g,
          h = a.hasRendered || 0,
          i,
          k,
          j = o(d.defer, !0),
          l = a.chart.renderer;
      if (d.enabled || a._hasPointLabels)
        a.dlProcessOptions && a.dlProcessOptions(d), k = a.plotGroup("dataLabelsGroup", "data-labels", j && !h ? "hidden" : "visible", d.zIndex || 6), j && (k.attr({opacity: +h}), h || N(a, "afterAnimate", function() {
          a.visible && k.show();
          k[b.animation ? "animate" : "attr"]({opacity: 1}, {duration: 200});
        })), g = d, p(e, function(e) {
          var h,
              j = e.dataLabel,
              p,
              s,
              t = e.connector,
              w = !0,
              v,
              x = {};
          f = e.dlOptions || e.options && e.options.dataLabels;
          h = o(f && f.enabled, g.enabled) && e.y !== null;
          if (j && !h)
            e.dataLabel = j.destroy();
          else if (h) {
            d = E(g, f);
            v = d.style;
            h = d.rotation;
            p = e.getLabelConfig();
            i = d.format ? Ka(d.format, p) : d.formatter.call(p, d);
            v.color = o(d.color, v.color, a.color, "black");
            if (j)
              if (r(i))
                j.attr({text: i}), w = !1;
              else {
                if (e.dataLabel = j = j.destroy(), t)
                  e.connector = t.destroy();
              }
            else if (r(i)) {
              j = {
                fill: d.backgroundColor,
                stroke: d.borderColor,
                "stroke-width": d.borderWidth,
                r: d.borderRadius || 0,
                rotation: h,
                padding: d.padding,
                zIndex: 1
              };
              if (v.color === "contrast")
                x.color = d.inside || d.distance < 0 || b.stacking ? l.getContrast(e.color || a.color) : "#000000";
              if (c)
                x.cursor = c;
              for (s in j)
                j[s] === y && delete j[s];
              j = e.dataLabel = l[h ? "text" : "label"](i, 0, -9999, d.shape, null, null, d.useHTML).attr(j).css(u(v, x)).add(k).shadow(d.shadow);
            }
            j && a.alignDataLabel(e, j, d, null, w);
          }
        });
    };
    R.prototype.alignDataLabel = function(a, b, c, d, e) {
      var f = this.chart,
          g = f.inverted,
          h = o(a.plotX, -9999),
          i = o(a.plotY, -9999),
          k = b.getBBox(),
          j = f.renderer.fontMetrics(c.style.fontSize).b,
          l = c.rotation,
          m = c.align,
          n = this.visible && (a.series.forceDL || f.isInsidePlot(h, B(i), g) || d && f.isInsidePlot(h, g ? d.x + 1 : d.y + d.height - 1, g)),
          q = o(c.overflow, "justify") === "justify";
      if (n)
        d = u({
          x: g ? f.plotWidth - i : h,
          y: B(g ? f.plotHeight - h : i),
          width: 0,
          height: 0
        }, d), u(c, {
          width: k.width,
          height: k.height
        }), l ? (q = !1, g = f.renderer.rotCorr(j, l), g = {
          x: d.x + c.x + d.width / 2 + g.x,
          y: d.y + c.y + {
            top: 0,
            middle: 0.5,
            bottom: 1
          }[c.verticalAlign] * d.height
        }, b[e ? "attr" : "animate"](g).attr({align: m}), h = (l + 720) % 360, h = h > 180 && h < 360, m === "left" ? g.y -= h ? k.height : 0 : m === "center" ? (g.x -= k.width / 2, g.y -= k.height / 2) : m === "right" && (g.x -= k.width, g.y -= h ? 0 : k.height)) : (b.align(c, null, d), g = b.alignAttr), q ? this.justifyDataLabel(b, c, g, k, d, e) : o(c.crop, !0) && (n = f.isInsidePlot(g.x, g.y) && f.isInsidePlot(g.x + k.width, g.y + k.height)), c.shape && !l && b.attr({
          anchorX: a.plotX,
          anchorY: a.plotY
        });
      if (!n)
        Oa(b), b.attr({y: -9999}), b.placed = !1;
    };
    R.prototype.justifyDataLabel = function(a, b, c, d, e, f) {
      var g = this.chart,
          h = b.align,
          i = b.verticalAlign,
          k,
          j,
          l = a.box ? 0 : a.padding || 0;
      k = c.x + l;
      if (k < 0)
        h === "right" ? b.align = "left" : b.x = -k, j = !0;
      k = c.x + d.width - l;
      if (k > g.plotWidth)
        h === "left" ? b.align = "right" : b.x = g.plotWidth - k, j = !0;
      k = c.y + l;
      if (k < 0)
        i === "bottom" ? b.verticalAlign = "top" : b.y = -k, j = !0;
      k = c.y + d.height - l;
      if (k > g.plotHeight)
        i === "top" ? b.verticalAlign = "bottom" : b.y = g.plotHeight - k, j = !0;
      if (j)
        a.placed = !f, a.align(b, null, e);
    };
    if (L.pie)
      L.pie.prototype.drawDataLabels = function() {
        var a = this,
            b = a.data,
            c,
            d = a.chart,
            e = a.options.dataLabels,
            f = o(e.connectorPadding, 10),
            g = o(e.connectorWidth, 1),
            h = d.plotWidth,
            i = d.plotHeight,
            k,
            j,
            l = o(e.softConnector, !0),
            m = e.distance,
            n = a.center,
            q = n[2] / 2,
            r = n[1],
            s = m > 0,
            u,
            w,
            v,
            x = [[], []],
            y,
            A,
            D,
            E,
            C,
            H = [0, 0, 0, 0],
            M = function(a, b) {
              return b.y - a.y;
            };
        if (a.visible && (e.enabled || a._hasPointLabels)) {
          R.prototype.drawDataLabels.apply(a);
          p(b, function(a) {
            if (a.dataLabel && a.visible)
              x[a.half].push(a), a.dataLabel._pos = null;
          });
          for (E = 2; E--; ) {
            var I = [],
                N = [],
                J = x[E],
                L = J.length,
                K;
            if (L) {
              a.sortByAngle(J, E - 0.5);
              for (C = b = 0; !b && J[C]; )
                b = J[C] && J[C].dataLabel && (J[C].dataLabel.getBBox().height || 21), C++;
              if (m > 0) {
                w = F(r + q + m, d.plotHeight);
                for (C = t(0, r - q - m); C <= w; C += b)
                  I.push(C);
                w = I.length;
                if (L > w) {
                  c = [].concat(J);
                  c.sort(M);
                  for (C = L; C--; )
                    c[C].rank = C;
                  for (C = L; C--; )
                    J[C].rank >= w && J.splice(C, 1);
                  L = J.length;
                }
                for (C = 0; C < L; C++) {
                  c = J[C];
                  v = c.labelPos;
                  c = 9999;
                  var P,
                      O;
                  for (O = 0; O < w; O++)
                    P = Q(I[O] - v[1]), P < c && (c = P, K = O);
                  if (K < C && I[C] !== null)
                    K = C;
                  else
                    for (w < L - C + K && I[C] !== null && (K = w - L + C); I[K] === null; )
                      K++;
                  N.push({
                    i: K,
                    y: I[K]
                  });
                  I[K] = null;
                }
                N.sort(M);
              }
              for (C = 0; C < L; C++) {
                c = J[C];
                v = c.labelPos;
                u = c.dataLabel;
                D = c.visible === !1 ? "hidden" : "inherit";
                c = v[1];
                if (m > 0) {
                  if (w = N.pop(), K = w.i, A = w.y, c > A && I[K + 1] !== null || c < A && I[K - 1] !== null)
                    A = F(t(0, c), d.plotHeight);
                } else
                  A = c;
                y = e.justify ? n[0] + (E ? -1 : 1) * (q + m) : a.getX(A === r - q - m || A === r + q + m ? c : A, E);
                u._attr = {
                  visibility: D,
                  align: v[6]
                };
                u._pos = {
                  x: y + e.x + ({
                    left: f,
                    right: -f
                  }[v[6]] || 0),
                  y: A + e.y - 10
                };
                u.connX = y;
                u.connY = A;
                if (this.options.size === null)
                  w = u.width, y - w < f ? H[3] = t(B(w - y + f), H[3]) : y + w > h - f && (H[1] = t(B(y + w - h + f), H[1])), A - b / 2 < 0 ? H[0] = t(B(-A + b / 2), H[0]) : A + b / 2 > i && (H[2] = t(B(A + b / 2 - i), H[2]));
              }
            }
          }
          if (Ga(H) === 0 || this.verifyDataLabelOverflow(H))
            this.placeDataLabels(), s && g && p(this.points, function(b) {
              k = b.connector;
              v = b.labelPos;
              if ((u = b.dataLabel) && u._pos && b.visible)
                D = u._attr.visibility, y = u.connX, A = u.connY, j = l ? ["M", y + (v[6] === "left" ? 5 : -5), A, "C", y, A, 2 * v[2] - v[4], 2 * v[3] - v[5], v[2], v[3], "L", v[4], v[5]] : ["M", y + (v[6] === "left" ? 5 : -5), A, "L", v[2], v[3], "L", v[4], v[5]], k ? (k.animate({d: j}), k.attr("visibility", D)) : b.connector = k = a.chart.renderer.path(j).attr({
                  "stroke-width": g,
                  stroke: e.connectorColor || b.color || "#606060",
                  visibility: D
                }).add(a.dataLabelsGroup);
              else if (k)
                b.connector = k.destroy();
            });
        }
      }, L.pie.prototype.placeDataLabels = function() {
        p(this.points, function(a) {
          var b = a.dataLabel;
          if (b && a.visible)
            (a = b._pos) ? (b.attr(b._attr), b[b.moved ? "animate" : "attr"](a), b.moved = !0) : b && b.attr({y: -9999});
        });
      }, L.pie.prototype.alignDataLabel = Aa, L.pie.prototype.verifyDataLabelOverflow = function(a) {
        var b = this.center,
            c = this.options,
            d = c.center,
            e = c.minSize || 80,
            f = e,
            g;
        d[0] !== null ? f = t(b[2] - t(a[1], a[3]), e) : (f = t(b[2] - a[1] - a[3], e), b[0] += (a[3] - a[1]) / 2);
        d[1] !== null ? f = t(F(f, b[2] - t(a[0], a[2])), e) : (f = t(F(f, b[2] - a[0] - a[2]), e), b[1] += (a[0] - a[2]) / 2);
        f < b[2] ? (b[2] = f, b[3] = Math.min(/%$/.test(c.innerSize || 0) ? f * parseFloat(c.innerSize || 0) / 100 : parseFloat(c.innerSize || 0), f), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : g = !0;
        return g;
      };
    if (L.column)
      L.column.prototype.alignDataLabel = function(a, b, c, d, e) {
        var f = this.chart.inverted,
            g = a.series,
            h = a.dlBox || a.shapeArgs,
            i = o(a.below, a.plotY > o(this.translatedThreshold, g.yAxis.len)),
            k = o(c.inside, !!this.options.stacking);
        if (h) {
          d = E(h);
          if (d.y < 0)
            d.height += d.y, d.y = 0;
          h = d.y + d.height - g.yAxis.len;
          h > 0 && (d.height -= h);
          f && (d = {
            x: g.yAxis.len - d.y - d.height,
            y: g.xAxis.len - d.x - d.width,
            width: d.height,
            height: d.width
          });
          if (!k)
            f ? (d.x += i ? 0 : d.width, d.width = 0) : (d.y += i ? d.height : 0, d.height = 0);
        }
        c.align = o(c.align, !f || k ? "center" : i ? "right" : "left");
        c.verticalAlign = o(c.verticalAlign, f || k ? "middle" : i ? "top" : "bottom");
        R.prototype.alignDataLabel.call(this, a, b, c, d, e);
      };
    (function(a) {
      var b = a.Chart,
          c = a.each,
          d = a.pick,
          e = a.addEvent;
      b.prototype.callbacks.push(function(a) {
        function b() {
          var e = [];
          c(a.series, function(a) {
            var b = a.options.dataLabels,
                f = a.dataLabelCollections || ["dataLabel"];
            (b.enabled || a._hasPointLabels) && !b.allowOverlap && a.visible && c(f, function(b) {
              c(a.points, function(a) {
                if (a[b])
                  a[b].labelrank = d(a.labelrank, a.shapeArgs && a.shapeArgs.height), e.push(a[b]);
              });
            });
          });
          a.hideOverlappingLabels(e);
        }
        b();
        e(a, "redraw", b);
      });
      b.prototype.hideOverlappingLabels = function(a) {
        var b = a.length,
            d,
            e,
            k,
            j,
            l,
            m,
            n,
            q,
            o;
        for (e = 0; e < b; e++)
          if (d = a[e])
            d.oldOpacity = d.opacity, d.newOpacity = 1;
        a.sort(function(a, b) {
          return (b.labelrank || 0) - (a.labelrank || 0);
        });
        for (e = 0; e < b; e++) {
          k = a[e];
          for (d = e + 1; d < b; ++d)
            if (j = a[d], k && j && k.placed && j.placed && k.newOpacity !== 0 && j.newOpacity !== 0 && (l = k.alignAttr, m = j.alignAttr, n = k.parentGroup, q = j.parentGroup, o = 2 * (k.box ? 0 : k.padding), l = !(m.x + q.translateX > l.x + n.translateX + (k.width - o) || m.x + q.translateX + (j.width - o) < l.x + n.translateX || m.y + q.translateY > l.y + n.translateY + (k.height - o) || m.y + q.translateY + (j.height - o) < l.y + n.translateY)))
              (k.labelrank < j.labelrank ? k : j).newOpacity = 0;
        }
        c(a, function(a) {
          var b,
              c;
          if (a) {
            c = a.newOpacity;
            if (a.oldOpacity !== c && a.placed)
              c ? a.show(!0) : b = function() {
                a.hide();
              }, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b);
            a.isOld = !0;
          }
        });
      };
    })(x);
    ga = x.TrackerMixin = {
      drawTrackerPoint: function() {
        var a = this,
            b = a.chart,
            c = b.pointer,
            d = a.options.cursor,
            e = d && {cursor: d},
            f = function(a) {
              for (var c = a.target,
                  d; c && !d; )
                d = c.point, c = c.parentNode;
              if (d !== y && d !== b.hoverPoint)
                d.onMouseOver(a);
            };
        p(a.points, function(a) {
          if (a.graphic)
            a.graphic.element.point = a;
          if (a.dataLabel)
            a.dataLabel.element.point = a;
        });
        if (!a._hasTracking)
          p(a.trackerGroups, function(b) {
            if (a[b] && (a[b].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function(a) {
              c.onTrackerMouseOut(a);
            }).css(e), db))
              a[b].on("touchstart", f);
          }), a._hasTracking = !0;
      },
      drawTrackerGraph: function() {
        var a = this,
            b = a.options,
            c = b.trackByArea,
            d = [].concat(c ? a.areaPath : a.graphPath),
            e = d.length,
            f = a.chart,
            g = f.pointer,
            h = f.renderer,
            i = f.options.tooltip.snap,
            k = a.tracker,
            j = b.cursor,
            l = j && {cursor: j},
            m = function() {
              if (f.hoverSeries !== a)
                a.onMouseOver();
            },
            n = "rgba(192,192,192," + (fa ? 1.0E-4 : 0.002) + ")";
        if (e && !c)
          for (j = e + 1; j--; )
            d[j] === "M" && d.splice(j + 1, 0, d[j + 1] - i, d[j + 2], "L"), (j && d[j] === "M" || j === e) && d.splice(j, 0, "L", d[j - 2] + i, d[j - 1]);
        k ? k.attr({d: d}) : (a.tracker = h.path(d).attr({
          "stroke-linejoin": "round",
          visibility: a.visible ? "visible" : "hidden",
          stroke: n,
          fill: c ? n : "none",
          "stroke-width": b.lineWidth + (c ? 0 : 2 * i),
          zIndex: 2
        }).add(a.group), p([a.tracker, a.markerGroup], function(a) {
          a.addClass("highcharts-tracker").on("mouseover", m).on("mouseout", function(a) {
            g.onTrackerMouseOut(a);
          }).css(l);
          if (db)
            a.on("touchstart", m);
        }));
      }
    };
    if (L.column)
      wa.prototype.drawTracker = ga.drawTrackerPoint;
    if (L.pie)
      L.pie.prototype.drawTracker = ga.drawTrackerPoint;
    if (L.scatter)
      oa.prototype.drawTracker = ga.drawTrackerPoint;
    u(ob.prototype, {
      setItemEvents: function(a, b, c, d, e) {
        var f = this;
        (c ? b : a.legendGroup).on("mouseover", function() {
          a.setState("hover");
          b.css(f.options.itemHoverStyle);
        }).on("mouseout", function() {
          b.css(a.visible ? d : e);
          a.setState();
        }).on("click", function(b) {
          var c = function() {
            a.setVisible && a.setVisible();
          },
              b = {browserEvent: b};
          a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : I(a, "legendItemClick", b, c);
        });
      },
      createCheckboxForItem: function(a) {
        a.checkbox = ba("input", {
          type: "checkbox",
          checked: a.selected,
          defaultChecked: a.selected
        }, this.options.itemCheckboxStyle, this.chart.container);
        N(a.checkbox, "click", function(b) {
          I(a.series || a, "checkboxClick", {
            checked: b.target.checked,
            item: a
          }, function() {
            a.select();
          });
        });
      }
    });
    U.legend.itemStyle.cursor = "pointer";
    u(gb.prototype, {
      showResetZoom: function() {
        var a = this,
            b = U.lang,
            c = a.options.chart.resetZoomButton,
            d = c.theme,
            e = d.states,
            f = c.relativeTo === "chart" ? null : "plotBox";
        this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function() {
          a.zoomOut();
        }, d, e && e.hover).attr({
          align: c.position.align,
          title: b.resetZoomTitle
        }).add().align(c.position, !1, f);
      },
      zoomOut: function() {
        var a = this;
        I(a, "selection", {resetSelection: !0}, function() {
          a.zoom();
        });
      },
      zoom: function(a) {
        var b,
            c = this.pointer,
            d = !1,
            e;
        !a || a.resetSelection ? p(this.axes, function(a) {
          b = a.zoom();
        }) : p(a.xAxis.concat(a.yAxis), function(a) {
          var e = a.axis,
              h = e.isXAxis;
          if (c[h ? "zoomX" : "zoomY"] || c[h ? "pinchX" : "pinchY"])
            b = e.zoom(a.min, a.max), e.displayBtn && (d = !0);
        });
        e = this.resetZoomButton;
        if (d && !e)
          this.showResetZoom();
        else if (!d && Z(e))
          this.resetZoomButton = e.destroy();
        b && this.redraw(o(this.options.chart.animation, a && a.animation, this.pointCount < 100));
      },
      pan: function(a, b) {
        var c = this,
            d = c.hoverPoints,
            e;
        d && p(d, function(a) {
          a.setState();
        });
        p(b === "xy" ? [1, 0] : [1], function(b) {
          var b = c[b ? "xAxis" : "yAxis"][0],
              d = b.horiz,
              h = a[d ? "chartX" : "chartY"],
              d = d ? "mouseDownX" : "mouseDownY",
              i = c[d],
              k = (b.pointRange || 0) / 2,
              j = b.getExtremes(),
              l = b.toValue(i - h, !0) + k,
              k = b.toValue(i + b.len - h, !0) - k,
              i = i > h;
          if (b.series.length && (i || l > F(j.dataMin, j.min)) && (!i || k < t(j.dataMax, j.max)))
            b.setExtremes(l, k, !1, !1, {trigger: "pan"}), e = !0;
          c[d] = h;
        });
        e && c.redraw(!1);
        M(c.container, {cursor: "move"});
      }
    });
    u(Ja.prototype, {
      select: function(a, b) {
        var c = this,
            d = c.series,
            e = d.chart,
            a = o(a, !c.selected);
        c.firePointEvent(a ? "select" : "unselect", {accumulate: b}, function() {
          c.selected = c.options.selected = a;
          d.options.data[sa(c, d.data)] = c.options;
          c.setState(a && "select");
          b || p(e.getSelectedPoints(), function(a) {
            if (a.selected && a !== c)
              a.selected = a.options.selected = !1, d.options.data[sa(a, d.data)] = a.options, a.setState(""), a.firePointEvent("unselect");
          });
        });
      },
      onMouseOver: function(a, b) {
        var c = this.series,
            d = c.chart,
            e = d.tooltip,
            f = d.hoverPoint;
        if (d.hoverSeries !== c)
          c.onMouseOver();
        if (f && f !== this)
          f.onMouseOut();
        if (this.series && (this.firePointEvent("mouseOver"), e && (!e.shared || c.noSharedTooltip) && e.refresh(this, a), this.setState("hover"), !b))
          d.hoverPoint = this;
      },
      onMouseOut: function() {
        var a = this.series.chart,
            b = a.hoverPoints;
        this.firePointEvent("mouseOut");
        if (!b || sa(this, b) === -1)
          this.setState(), a.hoverPoint = null;
      },
      importEvents: function() {
        if (!this.hasImportedEvents) {
          var a = E(this.series.options.point, this.options).events,
              b;
          this.events = a;
          for (b in a)
            N(this, b, a[b]);
          this.hasImportedEvents = !0;
        }
      },
      setState: function(a, b) {
        var c = V(this.plotX),
            d = this.plotY,
            e = this.series,
            f = e.options.states,
            g = ea[e.type].marker && e.options.marker,
            h = g && !g.enabled,
            i = g && g.states[a],
            k = i && i.enabled === !1,
            j = e.stateMarkerGraphic,
            l = this.marker || {},
            m = e.chart,
            n = e.halo,
            o,
            a = a || "";
        o = this.pointAttr[a] || e.pointAttr[a];
        if (!(a === this.state && !b || this.selected && a !== "select" || f[a] && f[a].enabled === !1 || a && (k || h && i.enabled === !1) || a && l.states && l.states[a] && l.states[a].enabled === !1)) {
          if (this.graphic)
            g = g && this.graphic.symbolName && o.r, this.graphic.attr(E(o, g ? {
              x: c - g,
              y: d - g,
              width: 2 * g,
              height: 2 * g
            } : {})), j && j.hide();
          else {
            if (a && i)
              if (g = i.radius, l = l.symbol || e.symbol, j && j.currentSymbol !== l && (j = j.destroy()), j)
                j[b ? "animate" : "attr"]({
                  x: c - g,
                  y: d - g
                });
              else if (l)
                e.stateMarkerGraphic = j = m.renderer.symbol(l, c - g, d - g, 2 * g, 2 * g).attr(o).add(e.markerGroup), j.currentSymbol = l;
            if (j)
              j[a && m.isInsidePlot(c, d, m.inverted) ? "show" : "hide"](), j.element.point = this;
          }
          if ((c = f[a] && f[a].halo) && c.size) {
            if (!n)
              e.halo = n = m.renderer.path().add(m.seriesGroup);
            n.attr(u({
              fill: this.color || e.color,
              "fill-opacity": c.opacity,
              zIndex: -1
            }, c.attributes))[b ? "animate" : "attr"]({d: this.haloPath(c.size)});
          } else
            n && n.attr({d: []});
          this.state = a;
        }
      },
      haloPath: function(a) {
        var b = this.series,
            c = b.chart,
            d = b.getPlotBox(),
            e = c.inverted,
            f = Math.floor(this.plotX);
        return c.renderer.symbols.circle(d.translateX + (e ? b.yAxis.len - this.plotY : f) - a, d.translateY + (e ? b.xAxis.len - f : this.plotY) - a, a * 2, a * 2);
      }
    });
    u(R.prototype, {
      onMouseOver: function() {
        var a = this.chart,
            b = a.hoverSeries;
        if (b && b !== this)
          b.onMouseOut();
        this.options.events.mouseOver && I(this, "mouseOver");
        this.setState("hover");
        a.hoverSeries = this;
      },
      onMouseOut: function() {
        var a = this.options,
            b = this.chart,
            c = b.tooltip,
            d = b.hoverPoint;
        b.hoverSeries = null;
        if (d)
          d.onMouseOut();
        this && a.events.mouseOut && I(this, "mouseOut");
        c && !a.stickyTracking && (!c.shared || this.noSharedTooltip) && c.hide();
        this.setState();
      },
      setState: function(a) {
        var b = this.options,
            c = this.graph,
            d = b.states,
            e = b.lineWidth,
            b = 0,
            a = a || "";
        if (this.state !== a && (this.state = a, !(d[a] && d[a].enabled === !1) && (a && (e = d[a].lineWidth || e + (d[a].lineWidthPlus || 0)), c && !c.dashstyle))) {
          a = {"stroke-width": e};
          for (c.attr(a); this["zoneGraph" + b]; )
            this["zoneGraph" + b].attr(a), b += 1;
        }
      },
      setVisible: function(a, b) {
        var c = this,
            d = c.chart,
            e = c.legendItem,
            f,
            g = d.options.chart.ignoreHiddenSeries,
            h = c.visible;
        f = (c.visible = a = c.userOptions.visible = a === y ? !h : a) ? "show" : "hide";
        p(["group", "dataLabelsGroup", "markerGroup", "tracker"], function(a) {
          if (c[a])
            c[a][f]();
        });
        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c)
          c.onMouseOut();
        e && d.legend.colorizeItem(c, a);
        c.isDirty = !0;
        c.options.stacking && p(d.series, function(a) {
          if (a.options.stacking && a.visible)
            a.isDirty = !0;
        });
        p(c.linkedSeries, function(b) {
          b.setVisible(a, !1);
        });
        if (g)
          d.isDirtyBox = !0;
        b !== !1 && d.redraw();
        I(c, f);
      },
      show: function() {
        this.setVisible(!0);
      },
      hide: function() {
        this.setVisible(!1);
      },
      select: function(a) {
        this.selected = a = a === y ? !this.selected : a;
        if (this.checkbox)
          this.checkbox.checked = a;
        I(this, a ? "select" : "unselect");
      },
      drawTracker: ga.drawTrackerGraph
    });
    u(x, {
      Color: ma,
      Point: Ja,
      Tick: Va,
      Renderer: cb,
      SVGElement: O,
      SVGRenderer: Da,
      arrayMin: La,
      arrayMax: Ga,
      charts: T,
      correctFloat: ca,
      dateFormat: Qa,
      error: aa,
      format: Ka,
      pathAnim: void 0,
      getOptions: function() {
        return U;
      },
      hasBidiBug: Pb,
      isTouchDevice: Lb,
      setOptions: function(a) {
        U = E(!0, U, a);
        Eb();
        return U;
      },
      addEvent: N,
      removeEvent: X,
      createElement: ba,
      discardElement: Sa,
      css: M,
      each: p,
      map: Ca,
      merge: E,
      splat: ta,
      stableSort: hb,
      extendClass: qa,
      pInt: C,
      svg: fa,
      canvas: ka,
      vml: !fa && !ka,
      product: "Highcharts",
      version: "4.2.5"
    });
    return x;
  });
  return module.exports;
});

$__System.registerDynamic("14", ["1c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Highcharts = $__require('1c');
  exports.Highcharts = Highcharts;
  return module.exports;
});

$__System.registerDynamic("1d", ["19", "1a", "1b", "14"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ChartComponent_1 = $__require('19');
  exports.ChartComponent = ChartComponent_1.ChartComponent;
  var ChartSeriesComponent_1 = $__require('1a');
  exports.ChartSeriesComponent = ChartSeriesComponent_1.ChartSeriesComponent;
  var ChartPointComponent_1 = $__require('1b');
  exports.ChartPointComponent = ChartPointComponent_1.ChartPointComponent;
  var Highcharts_1 = $__require('14');
  exports.Highcharts = Highcharts_1.Highcharts;
  exports.CHART_DIRECTIVES = [ChartComponent_1.ChartComponent, ChartSeriesComponent_1.ChartSeriesComponent, ChartPointComponent_1.ChartPointComponent];
  return module.exports;
});

$__System.registerDynamic("1e", ["1d"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  function __export(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  __export($__require('1d'));
  return module.exports;
});

$__System.registerDynamic("1f", ["3", "1e"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var core_1 = $__require('3');
  var angular2_highcharts_1 = $__require('1e');
  var PieChartExample = (function() {
    function PieChartExample() {
      this.sizeData = [];
      this.populationData = [];
    }
    PieChartExample.prototype.ngOnInit = function() {
      var _this = this;
      var totalForSize = 0;
      var totalPopulation = 0;
      this.pieData.forEach(function(ele) {
        totalForSize += Number(ele.areaInSqKm);
        totalPopulation += Number(ele.population);
      });
      this.sizeData = [];
      this.populationData = [];
      this.pieData.forEach(function(item) {
        _this.sizeData.push({
          name: item.countryName,
          y: Number((Number(item.areaInSqKm) / totalForSize * 100).toFixed(2))
        });
        _this.populationData.push({
          name: item.countryName,
          y: Number((Number(item.population) / totalPopulation * 100).toFixed(2))
        });
      });
      this.options = this.caculateOption(this.sizeData, 'areaInSqKm');
      this.anotherOption = this.caculateOption(this.populationData, 'population');
    };
    PieChartExample.prototype.ngOnChanges = function(changes) {
      for (var propName in changes) {
        console.log(propName);
        if (propName == 'num' || propName == 'continentCode') {
          this.ngOnInit();
        }
      }
    };
    PieChartExample.prototype.caculateOption = function(value, pietitle) {
      console.log('is it running');
      return {
        title: {text: pietitle},
        chart: {
          plotBackgroundColor: null,
          plotBorderWidth: null,
          plotShadow: false,
          type: 'pie'
        },
        tooltip: {pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'},
        plotOptions: {pie: {
            allowPointSelect: true,
            cursor: 'pointer',
            dataLabels: {
              enabled: true,
              format: '<b>{point.name}</b>: {point.percentage:.1f} %',
              style: {color: ('red' && 'whit') || 'black'}
            }
          }},
        series: [{
          name: 'Brands',
          colorByPoint: true,
          data: value
        }]
      };
    };
    PieChartExample = __decorate([core_1.Component({
      selector: 'pie-chart',
      directives: [angular2_highcharts_1.CHART_DIRECTIVES],
      template: "\n        <chart *ngIf=\"pietitle=='ALL' || pietitle=='areaInSqKm'\" [options]=\"options\"  class='chart'></chart>\n        <chart *ngIf=\"pietitle=='ALL' || pietitle=='population'\" [options]=\"anotherOption\"  class='chart'></chart>\n    ",
      inputs: ['pieData', 'pietitle', 'num', 'continentCode']
    }), __metadata('design:paramtypes', [])], PieChartExample);
    return PieChartExample;
  }());
  exports.PieChartExample = PieChartExample;
  return module.exports;
});

$__System.registerDynamic("20", ["3", "12", "1f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var core_1 = $__require('3');
  var sort_pipe_1 = $__require('12');
  var pai_component_1 = $__require('1f');
  var ResultComponent = (function() {
    function ResultComponent() {}
    ResultComponent.prototype.sortTable = function(value) {
      this.sortedBy = value;
    };
    ResultComponent.prototype.ngOnInit = function() {
      var siezeTotal = 0;
      var sizePopulation = 0;
      this.filtered.forEach(function(item) {
        siezeTotal += Number(item.areaInSqKm);
        sizePopulation += Number(item.population);
      });
      this.totalPopulation = sizePopulation;
      this.totalSize = siezeTotal;
    };
    ResultComponent.prototype.ngOnChanges = function(changes) {
      for (var propName in changes) {
        this.ngOnInit();
      }
    };
    ResultComponent = __decorate([core_1.Component({
      selector: 'my-result',
      template: "\n    <div class='tablewrapper'>\n    <table>\n      <tr>\n        <th>Continent</th>\n        <th>Country</th>\n        <th *ngIf=\"type=='areaInSqKm' || type=='ALL'\" (click)='sortTable(\"areaInSqKm\")'>AreaInSqKm (click me)</th>\n        <th *ngIf=\"type=='population' || type=='ALL'\" (click)='sortTable(\"population\")'>Population (click me)</th>\n      </tr>\n      <tr *ngFor=\"#item of filtered | sortBy:sortedBy \">\n        <td >{{item.continent}}</td>\n        <td>{{item.countryName}}</td>\n        <td *ngIf=\"type=='areaInSqKm' || type=='ALL'\">{{item.areaInSqKm}}</td>\n        <td *ngIf=\"type=='population' || type=='ALL'\">{{item.population}}</td>\n      </tr>\n      <tr>\n        <td colspan=\"2\">Total:</td>\n        <td *ngIf=\"type=='areaInSqKm' || type=='ALL'\" (click)='sortTable(\"areaInSqKm\")'>{{totalSize}}</td>\n        <td *ngIf=\"type=='population' || type=='ALL'\" (click)='sortTable(\"population\")'>{{totalPopulation}}</td>\n      </tr>\n    </table>\n    </div>\n    <pie-chart [pieData]=\"(filtered | sortBy:sortedBy).slice(0,num)\" [pietitle]=\"type\" [num]='num' [continentCode]='continentCode'></pie-chart>\n    ",
      inputs: ['filtered', 'type', 'num', 'continentCode'],
      pipes: [sort_pipe_1.SortPipe],
      directives: [pai_component_1.PieChartExample]
    }), __metadata('design:paramtypes', [])], ResultComponent);
    return ResultComponent;
  }());
  exports.ResultComponent = ResultComponent;
  return module.exports;
});

$__System.registerDynamic("21", ["3", "e", "10", "11", "20"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  var core_1 = $__require('3');
  var loadData_1 = $__require('e');
  var search_component_1 = $__require('10');
  var filter_pipe_1 = $__require('11');
  var result_component_1 = $__require('20');
  var AppComponent = (function() {
    function AppComponent(_loadDataService) {
      this._loadDataService = _loadDataService;
      this.loading = false;
      this.selectedType = 'ALL';
      this.selectedNum = 5;
    }
    AppComponent.prototype.onClick = function() {
      var _this = this;
      var that = this;
      this.loading = true;
      this._loadDataService.loadAll().subscribe(function(data) {
        that.data = data.geonames.map(function(obj) {
          return {
            continent: obj.continent,
            population: obj.population,
            areaInSqKm: obj.areaInSqKm,
            countryName: obj.countryName
          };
        });
        _this.loading = false;
        that.getContinents();
      }, function(err) {
        return alert(err);
      }, function() {
        return console.log('Finished');
      });
    };
    AppComponent.prototype.getContinents = function() {
      var selected = [];
      this.data.forEach(function(item) {
        selected.indexOf(item.continent) < 0 ? selected.push(item.continent) : selected;
      });
      this.continents = selected.sort();
    };
    AppComponent.prototype.updateQuery = function(value) {
      if (value.hasOwnProperty('continent')) {
        this.selectedContinent = value['continent'];
      } else if (value.hasOwnProperty('type')) {
        this.selectedType = value['type'];
      } else if (value.hasOwnProperty('num')) {
        this.selectedNum = Number(value['num']);
      }
    };
    AppComponent = __decorate([core_1.Component({
      selector: 'my-app',
      template: "\n        <button (click)=\"onClick()\" class='btn btn-lg btn-info'>GO</button>\n        <my-search [continents]=\"continents\" (childChanged)=\"updateQuery($event)\"></my-search>\n        <h2 *ngIf='loading'>Loading Data...</h2>\n        <my-result *ngIf=\"data\" [type]='selectedType' [num]='selectedNum' [filtered]=\"data | search:selectedContinent\" [continentCode]='selectedContinent'></my-result>\n    ",
      providers: [loadData_1.LoadDataService],
      directives: [search_component_1.SearchComponent, result_component_1.ResultComponent],
      pipes: [filter_pipe_1.FilterPipe]
    }), __metadata('design:paramtypes', [loadData_1.LoadDataService])], AppComponent);
    return AppComponent;
  }());
  exports.AppComponent = AppComponent;
  return module.exports;
});

$__System.registerDynamic("22", ["23"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var Subscription_1 = $__require('23');
  var SubjectSubscription = (function(_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, observer) {
      _super.call(this);
      this.subject = subject;
      this.observer = observer;
      this.isUnsubscribed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function() {
      if (this.isUnsubscribed) {
        return;
      }
      this.isUnsubscribed = true;
      var subject = this.subject;
      var observers = subject.observers;
      this.subject = null;
      if (!observers || observers.length === 0 || subject.isUnsubscribed) {
        return;
      }
      var subscriberIndex = observers.indexOf(this.observer);
      if (subscriberIndex !== -1) {
        observers.splice(subscriberIndex, 1);
      }
    };
    return SubjectSubscription;
  }(Subscription_1.Subscription));
  exports.SubjectSubscription = SubjectSubscription;
  return module.exports;
});

$__System.registerDynamic("24", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  function throwError(e) {
    throw e;
  }
  exports.throwError = throwError;
  return module.exports;
});

$__System.registerDynamic("25", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var ObjectUnsubscribedError = (function(_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
      _super.call(this, 'object unsubscribed');
      this.name = 'ObjectUnsubscribedError';
    }
    return ObjectUnsubscribedError;
  }(Error));
  exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
  return module.exports;
});

$__System.registerDynamic("4", ["7", "c", "23", "22", "26", "24", "25"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var Observable_1 = $__require('7');
  var Subscriber_1 = $__require('c');
  var Subscription_1 = $__require('23');
  var SubjectSubscription_1 = $__require('22');
  var rxSubscriber_1 = $__require('26');
  var throwError_1 = $__require('24');
  var ObjectUnsubscribedError_1 = $__require('25');
  var Subject = (function(_super) {
    __extends(Subject, _super);
    function Subject(destination, source) {
      _super.call(this);
      this.destination = destination;
      this.source = source;
      this.observers = [];
      this.isUnsubscribed = false;
      this.isStopped = false;
      this.hasErrored = false;
      this.dispatching = false;
      this.hasCompleted = false;
      this.source = source;
    }
    Subject.prototype.lift = function(operator) {
      var subject = new Subject(this.destination || this, this);
      subject.operator = operator;
      return subject;
    };
    Subject.prototype.add = function(subscription) {
      return Subscription_1.Subscription.prototype.add.call(this, subscription);
    };
    Subject.prototype.remove = function(subscription) {
      Subscription_1.Subscription.prototype.remove.call(this, subscription);
    };
    Subject.prototype.unsubscribe = function() {
      Subscription_1.Subscription.prototype.unsubscribe.call(this);
    };
    Subject.prototype._subscribe = function(subscriber) {
      if (this.source) {
        return this.source.subscribe(subscriber);
      } else {
        if (subscriber.isUnsubscribed) {
          return;
        } else if (this.hasErrored) {
          return subscriber.error(this.errorValue);
        } else if (this.hasCompleted) {
          return subscriber.complete();
        }
        this.throwIfUnsubscribed();
        var subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        this.observers.push(subscriber);
        return subscription;
      }
    };
    Subject.prototype._unsubscribe = function() {
      this.source = null;
      this.isStopped = true;
      this.observers = null;
      this.destination = null;
    };
    Subject.prototype.next = function(value) {
      this.throwIfUnsubscribed();
      if (this.isStopped) {
        return;
      }
      this.dispatching = true;
      this._next(value);
      this.dispatching = false;
      if (this.hasErrored) {
        this._error(this.errorValue);
      } else if (this.hasCompleted) {
        this._complete();
      }
    };
    Subject.prototype.error = function(err) {
      this.throwIfUnsubscribed();
      if (this.isStopped) {
        return;
      }
      this.isStopped = true;
      this.hasErrored = true;
      this.errorValue = err;
      if (this.dispatching) {
        return;
      }
      this._error(err);
    };
    Subject.prototype.complete = function() {
      this.throwIfUnsubscribed();
      if (this.isStopped) {
        return;
      }
      this.isStopped = true;
      this.hasCompleted = true;
      if (this.dispatching) {
        return;
      }
      this._complete();
    };
    Subject.prototype.asObservable = function() {
      var observable = new SubjectObservable(this);
      return observable;
    };
    Subject.prototype._next = function(value) {
      if (this.destination) {
        this.destination.next(value);
      } else {
        this._finalNext(value);
      }
    };
    Subject.prototype._finalNext = function(value) {
      var index = -1;
      var observers = this.observers.slice(0);
      var len = observers.length;
      while (++index < len) {
        observers[index].next(value);
      }
    };
    Subject.prototype._error = function(err) {
      if (this.destination) {
        this.destination.error(err);
      } else {
        this._finalError(err);
      }
    };
    Subject.prototype._finalError = function(err) {
      var index = -1;
      var observers = this.observers;
      this.observers = null;
      this.isUnsubscribed = true;
      if (observers) {
        var len = observers.length;
        while (++index < len) {
          observers[index].error(err);
        }
      }
      this.isUnsubscribed = false;
      this.unsubscribe();
    };
    Subject.prototype._complete = function() {
      if (this.destination) {
        this.destination.complete();
      } else {
        this._finalComplete();
      }
    };
    Subject.prototype._finalComplete = function() {
      var index = -1;
      var observers = this.observers;
      this.observers = null;
      this.isUnsubscribed = true;
      if (observers) {
        var len = observers.length;
        while (++index < len) {
          observers[index].complete();
        }
      }
      this.isUnsubscribed = false;
      this.unsubscribe();
    };
    Subject.prototype.throwIfUnsubscribed = function() {
      if (this.isUnsubscribed) {
        throwError_1.throwError(new ObjectUnsubscribedError_1.ObjectUnsubscribedError());
      }
    };
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function() {
      return new Subscriber_1.Subscriber(this);
    };
    Subject.create = function(destination, source) {
      return new Subject(destination, source);
    };
    return Subject;
  }(Observable_1.Observable));
  exports.Subject = Subject;
  var SubjectObservable = (function(_super) {
    __extends(SubjectObservable, _super);
    function SubjectObservable(source) {
      _super.call(this);
      this.source = source;
    }
    return SubjectObservable;
  }(Observable_1.Observable));
  return module.exports;
});

$__System.registerDynamic("5", ["27", "7"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var root_1 = $__require('27');
  var Observable_1 = $__require('7');
  var PromiseObservable = (function(_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
      if (scheduler === void 0) {
        scheduler = null;
      }
      _super.call(this);
      this.promise = promise;
      this.scheduler = scheduler;
    }
    PromiseObservable.create = function(promise, scheduler) {
      if (scheduler === void 0) {
        scheduler = null;
      }
      return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function(subscriber) {
      var _this = this;
      var promise = this.promise;
      var scheduler = this.scheduler;
      if (scheduler == null) {
        if (this._isScalar) {
          if (!subscriber.isUnsubscribed) {
            subscriber.next(this.value);
            subscriber.complete();
          }
        } else {
          promise.then(function(value) {
            _this.value = value;
            _this._isScalar = true;
            if (!subscriber.isUnsubscribed) {
              subscriber.next(value);
              subscriber.complete();
            }
          }, function(err) {
            if (!subscriber.isUnsubscribed) {
              subscriber.error(err);
            }
          }).then(null, function(err) {
            root_1.root.setTimeout(function() {
              throw err;
            });
          });
        }
      } else {
        if (this._isScalar) {
          if (!subscriber.isUnsubscribed) {
            return scheduler.schedule(dispatchNext, 0, {
              value: this.value,
              subscriber: subscriber
            });
          }
        } else {
          promise.then(function(value) {
            _this.value = value;
            _this._isScalar = true;
            if (!subscriber.isUnsubscribed) {
              subscriber.add(scheduler.schedule(dispatchNext, 0, {
                value: value,
                subscriber: subscriber
              }));
            }
          }, function(err) {
            if (!subscriber.isUnsubscribed) {
              subscriber.add(scheduler.schedule(dispatchError, 0, {
                err: err,
                subscriber: subscriber
              }));
            }
          }).then(null, function(err) {
            root_1.root.setTimeout(function() {
              throw err;
            });
          });
        }
      }
    };
    return PromiseObservable;
  }(Observable_1.Observable));
  exports.PromiseObservable = PromiseObservable;
  function dispatchNext(arg) {
    var value = arg.value,
        subscriber = arg.subscriber;
    if (!subscriber.isUnsubscribed) {
      subscriber.next(value);
      subscriber.complete();
    }
  }
  function dispatchError(arg) {
    var err = arg.err,
        subscriber = arg.subscriber;
    if (!subscriber.isUnsubscribed) {
      subscriber.error(err);
    }
  }
  return module.exports;
});

$__System.registerDynamic("6", ["27"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var root_1 = $__require('27');
  function toPromise(PromiseCtor) {
    var _this = this;
    if (!PromiseCtor) {
      if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
        PromiseCtor = root_1.root.Rx.config.Promise;
      } else if (root_1.root.Promise) {
        PromiseCtor = root_1.root.Promise;
      }
    }
    if (!PromiseCtor) {
      throw new Error('no Promise impl found');
    }
    return new PromiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  }
  exports.toPromise = toPromise;
  return module.exports;
});

(function() {
var define = $__System.amdDefine;
var __extends = (this && this.__extends) || function(d, b) {
  for (var p in b)
    if (b.hasOwnProperty(p))
      d[p] = b[p];
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/Subject'), require('rxjs/observable/PromiseObservable'), require('rxjs/operator/toPromise'), require('rxjs/Observable')) : typeof define === 'function' && define.amd ? define("3", ["exports", "4", "5", "6", "7"], factory) : (factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}), global.Rx, global.Rx, global.Rx.Observable.prototype, global.Rx));
}(this, function(exports, rxjs_Subject, rxjs_observable_PromiseObservable, rxjs_operator_toPromise, rxjs_Observable) {
  'use strict';
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
  }
  var global$1 = globalScope;
  var Type = Function;
  function getTypeNameForDebugging(type) {
    if (type['name']) {
      return type['name'];
    }
    return typeof type;
  }
  var Math = global$1.Math;
  var _devMode = true;
  var _modeLocked = false;
  function lockMode() {
    _modeLocked = true;
  }
  function enableProdMode() {
    if (_modeLocked) {
      throw 'Cannot enable prod mode after platform setup.';
    }
    _devMode = false;
  }
  function assertionsEnabled() {
    return _devMode;
  }
  global$1.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  function isString(obj) {
    return typeof obj === "string";
  }
  function isFunction(obj) {
    return typeof obj === "function";
  }
  function isType(obj) {
    return isFunction(obj);
  }
  function isPromise(obj) {
    return obj instanceof global$1.Promise;
  }
  function isArray(obj) {
    return Array.isArray(obj);
  }
  function noop() {}
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.name) {
      return token.name;
    }
    if (token.overriddenName) {
      return token.overriddenName;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  var StringWrapper = (function() {
    function StringWrapper() {}
    StringWrapper.fromCharCode = function(code) {
      return String.fromCharCode(code);
    };
    StringWrapper.charCodeAt = function(s, index) {
      return s.charCodeAt(index);
    };
    StringWrapper.split = function(s, regExp) {
      return s.split(regExp);
    };
    StringWrapper.equals = function(s, s2) {
      return s === s2;
    };
    StringWrapper.stripLeft = function(s, charVal) {
      if (s && s.length) {
        var pos = 0;
        for (var i = 0; i < s.length; i++) {
          if (s[i] != charVal)
            break;
          pos++;
        }
        s = s.substring(pos);
      }
      return s;
    };
    StringWrapper.stripRight = function(s, charVal) {
      if (s && s.length) {
        var pos = s.length;
        for (var i = s.length - 1; i >= 0; i--) {
          if (s[i] != charVal)
            break;
          pos--;
        }
        s = s.substring(0, pos);
      }
      return s;
    };
    StringWrapper.replace = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.slice = function(s, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function(s, from, cb) {
      return s.replace(from, function() {
        var matches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          matches[_i - 0] = arguments[_i];
        }
        matches.splice(-2, 2);
        return cb(matches);
      });
    };
    StringWrapper.contains = function(s, substr) {
      return s.indexOf(substr) != -1;
    };
    StringWrapper.compare = function(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    return StringWrapper;
  }());
  function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
  }
  function getMapKey(value) {
    return value;
  }
  function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
  }
  function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
  }
  function print(obj) {
    console.log(obj);
  }
  function warn(obj) {
    console.warn(obj);
  }
  var _symbolIterator = null;
  function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
      if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
        _symbolIterator = Symbol.iterator;
      } else {
        var keys = Object.getOwnPropertyNames(Map.prototype);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  function isPrimitive(obj) {
    return !isJsObject(obj);
  }
  var InjectMetadata = (function() {
    function InjectMetadata(token) {
      this.token = token;
    }
    InjectMetadata.prototype.toString = function() {
      return "@Inject(" + stringify(this.token) + ")";
    };
    return InjectMetadata;
  }());
  var OptionalMetadata = (function() {
    function OptionalMetadata() {}
    OptionalMetadata.prototype.toString = function() {
      return "@Optional()";
    };
    return OptionalMetadata;
  }());
  var DependencyMetadata = (function() {
    function DependencyMetadata() {}
    Object.defineProperty(DependencyMetadata.prototype, "token", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return DependencyMetadata;
  }());
  var InjectableMetadata = (function() {
    function InjectableMetadata() {}
    return InjectableMetadata;
  }());
  var SelfMetadata = (function() {
    function SelfMetadata() {}
    SelfMetadata.prototype.toString = function() {
      return "@Self()";
    };
    return SelfMetadata;
  }());
  var SkipSelfMetadata = (function() {
    function SkipSelfMetadata() {}
    SkipSelfMetadata.prototype.toString = function() {
      return "@SkipSelf()";
    };
    return SkipSelfMetadata;
  }());
  var HostMetadata = (function() {
    function HostMetadata() {}
    HostMetadata.prototype.toString = function() {
      return "@Host()";
    };
    return HostMetadata;
  }());
  function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function() {
      return stringify(this());
    };
    return forwardRefFn;
  }
  function resolveForwardRef(type) {
    if (isFunction(type) && type.hasOwnProperty('__forward_ref__') && type.__forward_ref__ === forwardRef) {
      return type();
    } else {
      return type;
    }
  }
  var AttributeMetadata = (function(_super) {
    __extends(AttributeMetadata, _super);
    function AttributeMetadata(attributeName) {
      _super.call(this);
      this.attributeName = attributeName;
    }
    Object.defineProperty(AttributeMetadata.prototype, "token", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    AttributeMetadata.prototype.toString = function() {
      return "@Attribute(" + stringify(this.attributeName) + ")";
    };
    return AttributeMetadata;
  }(DependencyMetadata));
  var QueryMetadata = (function(_super) {
    __extends(QueryMetadata, _super);
    function QueryMetadata(_selector, _a) {
      var _b = _a === void 0 ? {} : _a,
          _c = _b.descendants,
          descendants = _c === void 0 ? false : _c,
          _d = _b.first,
          first = _d === void 0 ? false : _d,
          _e = _b.read,
          read = _e === void 0 ? null : _e;
      _super.call(this);
      this._selector = _selector;
      this.descendants = descendants;
      this.first = first;
      this.read = read;
    }
    Object.defineProperty(QueryMetadata.prototype, "isViewQuery", {
      get: function() {
        return false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "selector", {
      get: function() {
        return resolveForwardRef(this._selector);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "isVarBindingQuery", {
      get: function() {
        return isString(this.selector);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "varBindings", {
      get: function() {
        return this.selector.split(',');
      },
      enumerable: true,
      configurable: true
    });
    QueryMetadata.prototype.toString = function() {
      return "@Query(" + stringify(this.selector) + ")";
    };
    return QueryMetadata;
  }(DependencyMetadata));
  var ContentChildrenMetadata = (function(_super) {
    __extends(ContentChildrenMetadata, _super);
    function ContentChildrenMetadata(_selector, _a) {
      var _b = _a === void 0 ? {} : _a,
          _c = _b.descendants,
          descendants = _c === void 0 ? false : _c,
          _d = _b.read,
          read = _d === void 0 ? null : _d;
      _super.call(this, _selector, {
        descendants: descendants,
        read: read
      });
    }
    return ContentChildrenMetadata;
  }(QueryMetadata));
  var ContentChildMetadata = (function(_super) {
    __extends(ContentChildMetadata, _super);
    function ContentChildMetadata(_selector, _a) {
      var _b = (_a === void 0 ? {} : _a).read,
          read = _b === void 0 ? null : _b;
      _super.call(this, _selector, {
        descendants: true,
        first: true,
        read: read
      });
    }
    return ContentChildMetadata;
  }(QueryMetadata));
  var ViewQueryMetadata = (function(_super) {
    __extends(ViewQueryMetadata, _super);
    function ViewQueryMetadata(_selector, _a) {
      var _b = _a === void 0 ? {} : _a,
          _c = _b.descendants,
          descendants = _c === void 0 ? false : _c,
          _d = _b.first,
          first = _d === void 0 ? false : _d,
          _e = _b.read,
          read = _e === void 0 ? null : _e;
      _super.call(this, _selector, {
        descendants: descendants,
        first: first,
        read: read
      });
    }
    Object.defineProperty(ViewQueryMetadata.prototype, "isViewQuery", {
      get: function() {
        return true;
      },
      enumerable: true,
      configurable: true
    });
    ViewQueryMetadata.prototype.toString = function() {
      return "@ViewQuery(" + stringify(this.selector) + ")";
    };
    return ViewQueryMetadata;
  }(QueryMetadata));
  var ViewChildrenMetadata = (function(_super) {
    __extends(ViewChildrenMetadata, _super);
    function ViewChildrenMetadata(_selector, _a) {
      var _b = (_a === void 0 ? {} : _a).read,
          read = _b === void 0 ? null : _b;
      _super.call(this, _selector, {
        descendants: true,
        read: read
      });
    }
    return ViewChildrenMetadata;
  }(ViewQueryMetadata));
  var ViewChildMetadata = (function(_super) {
    __extends(ViewChildMetadata, _super);
    function ViewChildMetadata(_selector, _a) {
      var _b = (_a === void 0 ? {} : _a).read,
          read = _b === void 0 ? null : _b;
      _super.call(this, _selector, {
        descendants: true,
        first: true,
        read: read
      });
    }
    return ViewChildMetadata;
  }(ViewQueryMetadata));
  var ChangeDetectorState;
  (function(ChangeDetectorState) {
    ChangeDetectorState[ChangeDetectorState["NeverChecked"] = 0] = "NeverChecked";
    ChangeDetectorState[ChangeDetectorState["CheckedBefore"] = 1] = "CheckedBefore";
    ChangeDetectorState[ChangeDetectorState["Errored"] = 2] = "Errored";
  })(ChangeDetectorState || (ChangeDetectorState = {}));
  exports.ChangeDetectionStrategy;
  (function(ChangeDetectionStrategy) {
    ChangeDetectionStrategy[ChangeDetectionStrategy["CheckOnce"] = 0] = "CheckOnce";
    ChangeDetectionStrategy[ChangeDetectionStrategy["Checked"] = 1] = "Checked";
    ChangeDetectionStrategy[ChangeDetectionStrategy["CheckAlways"] = 2] = "CheckAlways";
    ChangeDetectionStrategy[ChangeDetectionStrategy["Detached"] = 3] = "Detached";
    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 4] = "OnPush";
    ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 5] = "Default";
  })(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
  var CHANGE_DETECTION_STRATEGY_VALUES = [exports.ChangeDetectionStrategy.CheckOnce, exports.ChangeDetectionStrategy.Checked, exports.ChangeDetectionStrategy.CheckAlways, exports.ChangeDetectionStrategy.Detached, exports.ChangeDetectionStrategy.OnPush, exports.ChangeDetectionStrategy.Default];
  function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
    return isBlank(changeDetectionStrategy) || changeDetectionStrategy === exports.ChangeDetectionStrategy.Default;
  }
  var DirectiveMetadata = (function(_super) {
    __extends(DirectiveMetadata, _super);
    function DirectiveMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          selector = _b.selector,
          inputs = _b.inputs,
          outputs = _b.outputs,
          properties = _b.properties,
          events = _b.events,
          host = _b.host,
          bindings = _b.bindings,
          providers = _b.providers,
          exportAs = _b.exportAs,
          queries = _b.queries;
      _super.call(this);
      this.selector = selector;
      this._inputs = inputs;
      this._properties = properties;
      this._outputs = outputs;
      this._events = events;
      this.host = host;
      this.exportAs = exportAs;
      this.queries = queries;
      this._providers = providers;
      this._bindings = bindings;
    }
    Object.defineProperty(DirectiveMetadata.prototype, "inputs", {
      get: function() {
        return isPresent(this._properties) && this._properties.length > 0 ? this._properties : this._inputs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "properties", {
      get: function() {
        return this.inputs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "outputs", {
      get: function() {
        return isPresent(this._events) && this._events.length > 0 ? this._events : this._outputs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "events", {
      get: function() {
        return this.outputs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "providers", {
      get: function() {
        return isPresent(this._bindings) && this._bindings.length > 0 ? this._bindings : this._providers;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "bindings", {
      get: function() {
        return this.providers;
      },
      enumerable: true,
      configurable: true
    });
    return DirectiveMetadata;
  }(InjectableMetadata));
  var ComponentMetadata = (function(_super) {
    __extends(ComponentMetadata, _super);
    function ComponentMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          selector = _b.selector,
          inputs = _b.inputs,
          outputs = _b.outputs,
          properties = _b.properties,
          events = _b.events,
          host = _b.host,
          exportAs = _b.exportAs,
          moduleId = _b.moduleId,
          bindings = _b.bindings,
          providers = _b.providers,
          viewBindings = _b.viewBindings,
          viewProviders = _b.viewProviders,
          _c = _b.changeDetection,
          changeDetection = _c === void 0 ? exports.ChangeDetectionStrategy.Default : _c,
          queries = _b.queries,
          templateUrl = _b.templateUrl,
          template = _b.template,
          styleUrls = _b.styleUrls,
          styles = _b.styles,
          directives = _b.directives,
          pipes = _b.pipes,
          encapsulation = _b.encapsulation;
      _super.call(this, {
        selector: selector,
        inputs: inputs,
        outputs: outputs,
        properties: properties,
        events: events,
        host: host,
        exportAs: exportAs,
        bindings: bindings,
        providers: providers,
        queries: queries
      });
      this.changeDetection = changeDetection;
      this._viewProviders = viewProviders;
      this._viewBindings = viewBindings;
      this.templateUrl = templateUrl;
      this.template = template;
      this.styleUrls = styleUrls;
      this.styles = styles;
      this.directives = directives;
      this.pipes = pipes;
      this.encapsulation = encapsulation;
      this.moduleId = moduleId;
    }
    Object.defineProperty(ComponentMetadata.prototype, "viewProviders", {
      get: function() {
        return isPresent(this._viewBindings) && this._viewBindings.length > 0 ? this._viewBindings : this._viewProviders;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentMetadata.prototype, "viewBindings", {
      get: function() {
        return this.viewProviders;
      },
      enumerable: true,
      configurable: true
    });
    return ComponentMetadata;
  }(DirectiveMetadata));
  var PipeMetadata = (function(_super) {
    __extends(PipeMetadata, _super);
    function PipeMetadata(_a) {
      var name = _a.name,
          pure = _a.pure;
      _super.call(this);
      this.name = name;
      this._pure = pure;
    }
    Object.defineProperty(PipeMetadata.prototype, "pure", {
      get: function() {
        return isPresent(this._pure) ? this._pure : true;
      },
      enumerable: true,
      configurable: true
    });
    return PipeMetadata;
  }(InjectableMetadata));
  var InputMetadata = (function() {
    function InputMetadata(bindingPropertyName) {
      this.bindingPropertyName = bindingPropertyName;
    }
    return InputMetadata;
  }());
  var OutputMetadata = (function() {
    function OutputMetadata(bindingPropertyName) {
      this.bindingPropertyName = bindingPropertyName;
    }
    return OutputMetadata;
  }());
  var HostBindingMetadata = (function() {
    function HostBindingMetadata(hostPropertyName) {
      this.hostPropertyName = hostPropertyName;
    }
    return HostBindingMetadata;
  }());
  var HostListenerMetadata = (function() {
    function HostListenerMetadata(eventName, args) {
      this.eventName = eventName;
      this.args = args;
    }
    return HostListenerMetadata;
  }());
  exports.ViewEncapsulation;
  (function(ViewEncapsulation) {
    ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
    ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
    ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
  })(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
  var VIEW_ENCAPSULATION_VALUES = [exports.ViewEncapsulation.Emulated, exports.ViewEncapsulation.Native, exports.ViewEncapsulation.None];
  var ViewMetadata = (function() {
    function ViewMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          templateUrl = _b.templateUrl,
          template = _b.template,
          directives = _b.directives,
          pipes = _b.pipes,
          encapsulation = _b.encapsulation,
          styles = _b.styles,
          styleUrls = _b.styleUrls;
      this.templateUrl = templateUrl;
      this.template = template;
      this.styleUrls = styleUrls;
      this.styles = styles;
      this.directives = directives;
      this.pipes = pipes;
      this.encapsulation = encapsulation;
    }
    return ViewMetadata;
  }());
  var _nextClassId = 0;
  function extractAnnotation(annotation) {
    if (isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
      annotation = annotation.annotation;
    }
    return annotation;
  }
  function applyParams(fnOrArray, key) {
    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function || fnOrArray === Number || fnOrArray === Array) {
      throw new Error("Can not use native " + stringify(fnOrArray) + " as constructor");
    }
    if (isFunction(fnOrArray)) {
      return fnOrArray;
    } else if (fnOrArray instanceof Array) {
      var annotations = fnOrArray;
      var fn = fnOrArray[fnOrArray.length - 1];
      if (!isFunction(fn)) {
        throw new Error("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'");
      }
      var annoLength = annotations.length - 1;
      if (annoLength != fn.length) {
        throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn));
      }
      var paramsAnnotations = [];
      for (var i = 0,
          ii = annotations.length - 1; i < ii; i++) {
        var paramAnnotations = [];
        paramsAnnotations.push(paramAnnotations);
        var annotation = annotations[i];
        if (annotation instanceof Array) {
          for (var j = 0; j < annotation.length; j++) {
            paramAnnotations.push(extractAnnotation(annotation[j]));
          }
        } else if (isFunction(annotation)) {
          paramAnnotations.push(extractAnnotation(annotation));
        } else {
          paramAnnotations.push(annotation);
        }
      }
      Reflect.defineMetadata('parameters', paramsAnnotations, fn);
      return fn;
    } else {
      throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'");
    }
  }
  function Class(clsDef) {
    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
    var proto = constructor.prototype;
    if (clsDef.hasOwnProperty('extends')) {
      if (isFunction(clsDef.extends)) {
        constructor.prototype = proto = Object.create(clsDef.extends.prototype);
      } else {
        throw new Error("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends));
      }
    }
    for (var key in clsDef) {
      if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
        proto[key] = applyParams(clsDef[key], key);
      }
    }
    if (this && this.annotations instanceof Array) {
      Reflect.defineMetadata('annotations', this.annotations, constructor);
    }
    if (!constructor['name']) {
      constructor['overriddenName'] = "class" + _nextClassId++;
    }
    return constructor;
  }
  var Reflect = global$1.Reflect;
  function makeDecorator(annotationCls, chainFn) {
    if (chainFn === void 0) {
      chainFn = null;
    }
    function DecoratorFactory(objOrType) {
      var annotationInstance = new annotationCls(objOrType);
      if (this instanceof annotationCls) {
        return annotationInstance;
      } else {
        var chainAnnotation = isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
        chainAnnotation.push(annotationInstance);
        var TypeDecorator = function TypeDecorator(cls) {
          var annotations = Reflect.getOwnMetadata('annotations', cls);
          annotations = annotations || [];
          annotations.push(annotationInstance);
          Reflect.defineMetadata('annotations', annotations, cls);
          return cls;
        };
        TypeDecorator.annotations = chainAnnotation;
        TypeDecorator.Class = Class;
        if (chainFn)
          chainFn(TypeDecorator);
        return TypeDecorator;
      }
    }
    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
    DecoratorFactory.annotationCls = annotationCls;
    return DecoratorFactory;
  }
  function makeParamDecorator(annotationCls) {
    function ParamDecoratorFactory() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
      }
      var annotationInstance = Object.create(annotationCls.prototype);
      annotationCls.apply(annotationInstance, args);
      if (this instanceof annotationCls) {
        return annotationInstance;
      } else {
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;
      }
      function ParamDecorator(cls, unusedKey, index) {
        var parameters = Reflect.getMetadata('parameters', cls);
        parameters = parameters || [];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        parameters[index] = parameters[index] || [];
        var annotationsForParam = parameters[index];
        annotationsForParam.push(annotationInstance);
        Reflect.defineMetadata('parameters', parameters, cls);
        return cls;
      }
    }
    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    ParamDecoratorFactory.annotationCls = annotationCls;
    return ParamDecoratorFactory;
  }
  function makePropDecorator(annotationCls) {
    function PropDecoratorFactory() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
      }
      var decoratorInstance = Object.create(annotationCls.prototype);
      annotationCls.apply(decoratorInstance, args);
      if (this instanceof annotationCls) {
        return decoratorInstance;
      } else {
        return function PropDecorator(target, name) {
          var meta = Reflect.getOwnMetadata('propMetadata', target.constructor);
          meta = meta || {};
          meta[name] = meta[name] || [];
          meta[name].unshift(decoratorInstance);
          Reflect.defineMetadata('propMetadata', meta, target.constructor);
        };
      }
    }
    PropDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    PropDecoratorFactory.annotationCls = annotationCls;
    return PropDecoratorFactory;
  }
  var Component = makeDecorator(ComponentMetadata, function(fn) {
    return fn.View = View;
  });
  var Directive = makeDecorator(DirectiveMetadata);
  var View = makeDecorator(ViewMetadata, function(fn) {
    return fn.View = View;
  });
  var Attribute = makeParamDecorator(AttributeMetadata);
  var Query = makeParamDecorator(QueryMetadata);
  var ContentChildren = makePropDecorator(ContentChildrenMetadata);
  var ContentChild = makePropDecorator(ContentChildMetadata);
  var ViewChildren = makePropDecorator(ViewChildrenMetadata);
  var ViewChild = makePropDecorator(ViewChildMetadata);
  var ViewQuery = makeParamDecorator(ViewQueryMetadata);
  var Pipe = makeDecorator(PipeMetadata);
  var Input = makePropDecorator(InputMetadata);
  var Output = makePropDecorator(OutputMetadata);
  var HostBinding = makePropDecorator(HostBindingMetadata);
  var HostListener = makePropDecorator(HostListenerMetadata);
  var Inject = makeParamDecorator(InjectMetadata);
  var Optional = makeParamDecorator(OptionalMetadata);
  var Injectable = makeDecorator(InjectableMetadata);
  var Self = makeParamDecorator(SelfMetadata);
  var Host = makeParamDecorator(HostMetadata);
  var SkipSelf = makeParamDecorator(SkipSelfMetadata);
  var BaseWrappedException = (function(_super) {
    __extends(BaseWrappedException, _super);
    function BaseWrappedException(message) {
      _super.call(this, message);
    }
    Object.defineProperty(BaseWrappedException.prototype, "wrapperMessage", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "wrapperStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalException", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "context", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "message", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    return BaseWrappedException;
  }(Error));
  var Map$1 = global$1.Map;
  var Set = global$1.Set;
  var createMapFromPairs = (function() {
    try {
      if (new Map$1([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new Map$1(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new Map$1();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new Map$1(new Map$1())) {
        return function createMapFromMap(m) {
          return new Map$1(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new Map$1();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new Map$1()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new Map$1()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var MapWrapper = (function() {
    function MapWrapper() {}
    MapWrapper.clone = function(m) {
      return createMapFromMap(m);
    };
    MapWrapper.createFromStringMap = function(stringMap) {
      var result = new Map$1();
      for (var prop in stringMap) {
        result.set(prop, stringMap[prop]);
      }
      return result;
    };
    MapWrapper.toStringMap = function(m) {
      var r = {};
      m.forEach(function(v, k) {
        return r[k] = v;
      });
      return r;
    };
    MapWrapper.createFromPairs = function(pairs) {
      return createMapFromPairs(pairs);
    };
    MapWrapper.clearValues = function(m) {
      _clearValues(m);
    };
    MapWrapper.iterable = function(m) {
      return m;
    };
    MapWrapper.keys = function(m) {
      return _arrayFromMap(m, false);
    };
    MapWrapper.values = function(m) {
      return _arrayFromMap(m, true);
    };
    return MapWrapper;
  }());
  var StringMapWrapper = (function() {
    function StringMapWrapper() {}
    StringMapWrapper.create = function() {
      return {};
    };
    StringMapWrapper.contains = function(map, key) {
      return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function(map, key) {
      return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function(map, key, value) {
      map[key] = value;
    };
    StringMapWrapper.keys = function(map) {
      return Object.keys(map);
    };
    StringMapWrapper.values = function(map) {
      return Object.keys(map).reduce(function(r, a) {
        r.push(map[a]);
        return r;
      }, []);
    };
    StringMapWrapper.isEmpty = function(map) {
      for (var prop in map) {
        return false;
      }
      return true;
    };
    StringMapWrapper.delete = function(map, key) {
      delete map[key];
    };
    StringMapWrapper.forEach = function(map, callback) {
      for (var prop in map) {
        if (map.hasOwnProperty(prop)) {
          callback(map[prop], prop);
        }
      }
    };
    StringMapWrapper.merge = function(m1, m2) {
      var m = {};
      for (var attr in m1) {
        if (m1.hasOwnProperty(attr)) {
          m[attr] = m1[attr];
        }
      }
      for (var attr in m2) {
        if (m2.hasOwnProperty(attr)) {
          m[attr] = m2[attr];
        }
      }
      return m;
    };
    StringMapWrapper.equals = function(m1, m2) {
      var k1 = Object.keys(m1);
      var k2 = Object.keys(m2);
      if (k1.length != k2.length) {
        return false;
      }
      var key;
      for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (m1[key] !== m2[key]) {
          return false;
        }
      }
      return true;
    };
    return StringMapWrapper;
  }());
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  function _flattenArray(source, target) {
    if (isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  function isListLikeIterable(obj) {
    if (!isJsObject(obj))
      return false;
    return isArray(obj) || (!(obj instanceof Map$1) && getSymbolIterator() in obj);
  }
  function areIterablesEqual(a, b, comparator) {
    var iterator1 = a[getSymbolIterator()]();
    var iterator2 = b[getSymbolIterator()]();
    while (true) {
      var item1 = iterator1.next();
      var item2 = iterator2.next();
      if (item1.done && item2.done)
        return true;
      if (item1.done || item2.done)
        return false;
      if (!comparator(item1.value, item2.value))
        return false;
    }
  }
  function iterateListLike(obj, fn) {
    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[getSymbolIterator()]();
      var item;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  var createSetFromList = (function() {
    var test = new Set([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new Set(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new Set(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var SetWrapper = (function() {
    function SetWrapper() {}
    SetWrapper.createFromList = function(lst) {
      return createSetFromList(lst);
    };
    SetWrapper.has = function(s, key) {
      return s.has(key);
    };
    SetWrapper.delete = function(m, k) {
      m.delete(k);
    };
    return SetWrapper;
  }());
  var _ArrayLogger = (function() {
    function _ArrayLogger() {
      this.res = [];
    }
    _ArrayLogger.prototype.log = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logError = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroup = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroupEnd = function() {};
    ;
    return _ArrayLogger;
  }());
  var ExceptionHandler = (function() {
    function ExceptionHandler(_logger, _rethrowException) {
      if (_rethrowException === void 0) {
        _rethrowException = true;
      }
      this._logger = _logger;
      this._rethrowException = _rethrowException;
    }
    ExceptionHandler.exceptionToString = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var l = new _ArrayLogger();
      var e = new ExceptionHandler(l, false);
      e.call(exception, stackTrace, reason);
      return l.res.join("\n");
    };
    ExceptionHandler.prototype.call = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var originalException = this._findOriginalException(exception);
      var originalStack = this._findOriginalStack(exception);
      var context = this._findContext(exception);
      this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
      if (isPresent(stackTrace) && isBlank(originalStack)) {
        this._logger.logError("STACKTRACE:");
        this._logger.logError(this._longStackTrace(stackTrace));
      }
      if (isPresent(reason)) {
        this._logger.logError("REASON: " + reason);
      }
      if (isPresent(originalException)) {
        this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
      }
      if (isPresent(originalStack)) {
        this._logger.logError("ORIGINAL STACKTRACE:");
        this._logger.logError(this._longStackTrace(originalStack));
      }
      if (isPresent(context)) {
        this._logger.logError("ERROR CONTEXT:");
        this._logger.logError(context);
      }
      this._logger.logGroupEnd();
      if (this._rethrowException)
        throw exception;
    };
    ExceptionHandler.prototype._extractMessage = function(exception) {
      return exception instanceof BaseWrappedException ? exception.wrapperMessage : exception.toString();
    };
    ExceptionHandler.prototype._longStackTrace = function(stackTrace) {
      return isListLikeIterable(stackTrace) ? stackTrace.join("\n\n-----async gap-----\n") : stackTrace.toString();
    };
    ExceptionHandler.prototype._findContext = function(exception) {
      try {
        if (!(exception instanceof BaseWrappedException))
          return null;
        return isPresent(exception.context) ? exception.context : this._findContext(exception.originalException);
      } catch (e) {
        return null;
      }
    };
    ExceptionHandler.prototype._findOriginalException = function(exception) {
      if (!(exception instanceof BaseWrappedException))
        return null;
      var e = exception.originalException;
      while (e instanceof BaseWrappedException && isPresent(e.originalException)) {
        e = e.originalException;
      }
      return e;
    };
    ExceptionHandler.prototype._findOriginalStack = function(exception) {
      if (!(exception instanceof BaseWrappedException))
        return null;
      var e = exception;
      var stack = exception.originalStack;
      while (e instanceof BaseWrappedException && isPresent(e.originalException)) {
        e = e.originalException;
        if (e instanceof BaseWrappedException && isPresent(e.originalException)) {
          stack = e.originalStack;
        }
      }
      return stack;
    };
    return ExceptionHandler;
  }());
  var BaseException = (function(_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
      if (message === void 0) {
        message = "--";
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function() {
      return this.message;
    };
    return BaseException;
  }(Error));
  var WrappedException = (function(_super) {
    __extends(WrappedException, _super);
    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {
      _super.call(this, _wrapperMessage);
      this._wrapperMessage = _wrapperMessage;
      this._originalException = _originalException;
      this._originalStack = _originalStack;
      this._context = _context;
      this._wrapperStack = (new Error(_wrapperMessage)).stack;
    }
    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
      get: function() {
        return this._wrapperMessage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
      get: function() {
        return this._wrapperStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalException", {
      get: function() {
        return this._originalException;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalStack", {
      get: function() {
        return this._originalStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "context", {
      get: function() {
        return this._context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "message", {
      get: function() {
        return ExceptionHandler.exceptionToString(this);
      },
      enumerable: true,
      configurable: true
    });
    WrappedException.prototype.toString = function() {
      return this.message;
    };
    return WrappedException;
  }(BaseWrappedException));
  function unimplemented() {
    throw new BaseException('unimplemented');
  }
  var _THROW_IF_NOT_FOUND = new Object();
  var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  var Injector = (function() {
    function Injector() {}
    Injector.prototype.get = function(token, notFoundValue) {
      return unimplemented();
    };
    return Injector;
  }());
  Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  var ReflectorReader = (function() {
    function ReflectorReader() {}
    return ReflectorReader;
  }());
  var ReflectionInfo = (function() {
    function ReflectionInfo(annotations, parameters, factory, interfaces, propMetadata) {
      this.annotations = annotations;
      this.parameters = parameters;
      this.factory = factory;
      this.interfaces = interfaces;
      this.propMetadata = propMetadata;
    }
    return ReflectionInfo;
  }());
  var Reflector = (function(_super) {
    __extends(Reflector, _super);
    function Reflector(reflectionCapabilities) {
      _super.call(this);
      this._injectableInfo = new Map$1();
      this._getters = new Map$1();
      this._setters = new Map$1();
      this._methods = new Map$1();
      this._usedKeys = null;
      this.reflectionCapabilities = reflectionCapabilities;
    }
    Reflector.prototype.isReflectionEnabled = function() {
      return this.reflectionCapabilities.isReflectionEnabled();
    };
    Reflector.prototype.trackUsage = function() {
      this._usedKeys = new Set();
    };
    Reflector.prototype.listUnusedKeys = function() {
      var _this = this;
      if (this._usedKeys == null) {
        throw new BaseException('Usage tracking is disabled');
      }
      var allTypes = MapWrapper.keys(this._injectableInfo);
      return allTypes.filter(function(key) {
        return !SetWrapper.has(_this._usedKeys, key);
      });
    };
    Reflector.prototype.registerFunction = function(func, funcInfo) {
      this._injectableInfo.set(func, funcInfo);
    };
    Reflector.prototype.registerType = function(type, typeInfo) {
      this._injectableInfo.set(type, typeInfo);
    };
    Reflector.prototype.registerGetters = function(getters) {
      _mergeMaps(this._getters, getters);
    };
    Reflector.prototype.registerSetters = function(setters) {
      _mergeMaps(this._setters, setters);
    };
    Reflector.prototype.registerMethods = function(methods) {
      _mergeMaps(this._methods, methods);
    };
    Reflector.prototype.factory = function(type) {
      if (this._containsReflectionInfo(type)) {
        var res = this._getReflectionInfo(type).factory;
        return isPresent(res) ? res : null;
      } else {
        return this.reflectionCapabilities.factory(type);
      }
    };
    Reflector.prototype.parameters = function(typeOrFunc) {
      if (this._injectableInfo.has(typeOrFunc)) {
        var res = this._getReflectionInfo(typeOrFunc).parameters;
        return isPresent(res) ? res : [];
      } else {
        return this.reflectionCapabilities.parameters(typeOrFunc);
      }
    };
    Reflector.prototype.annotations = function(typeOrFunc) {
      if (this._injectableInfo.has(typeOrFunc)) {
        var res = this._getReflectionInfo(typeOrFunc).annotations;
        return isPresent(res) ? res : [];
      } else {
        return this.reflectionCapabilities.annotations(typeOrFunc);
      }
    };
    Reflector.prototype.propMetadata = function(typeOrFunc) {
      if (this._injectableInfo.has(typeOrFunc)) {
        var res = this._getReflectionInfo(typeOrFunc).propMetadata;
        return isPresent(res) ? res : {};
      } else {
        return this.reflectionCapabilities.propMetadata(typeOrFunc);
      }
    };
    Reflector.prototype.interfaces = function(type) {
      if (this._injectableInfo.has(type)) {
        var res = this._getReflectionInfo(type).interfaces;
        return isPresent(res) ? res : [];
      } else {
        return this.reflectionCapabilities.interfaces(type);
      }
    };
    Reflector.prototype.getter = function(name) {
      if (this._getters.has(name)) {
        return this._getters.get(name);
      } else {
        return this.reflectionCapabilities.getter(name);
      }
    };
    Reflector.prototype.setter = function(name) {
      if (this._setters.has(name)) {
        return this._setters.get(name);
      } else {
        return this.reflectionCapabilities.setter(name);
      }
    };
    Reflector.prototype.method = function(name) {
      if (this._methods.has(name)) {
        return this._methods.get(name);
      } else {
        return this.reflectionCapabilities.method(name);
      }
    };
    Reflector.prototype._getReflectionInfo = function(typeOrFunc) {
      if (isPresent(this._usedKeys)) {
        this._usedKeys.add(typeOrFunc);
      }
      return this._injectableInfo.get(typeOrFunc);
    };
    Reflector.prototype._containsReflectionInfo = function(typeOrFunc) {
      return this._injectableInfo.has(typeOrFunc);
    };
    Reflector.prototype.importUri = function(type) {
      return this.reflectionCapabilities.importUri(type);
    };
    return Reflector;
  }(ReflectorReader));
  function _mergeMaps(target, config) {
    StringMapWrapper.forEach(config, function(v, k) {
      return target.set(k, v);
    });
  }
  var ReflectionCapabilities = (function() {
    function ReflectionCapabilities(reflect) {
      this._reflect = isPresent(reflect) ? reflect : global$1.Reflect;
    }
    ReflectionCapabilities.prototype.isReflectionEnabled = function() {
      return true;
    };
    ReflectionCapabilities.prototype.factory = function(t) {
      switch (t.length) {
        case 0:
          return function() {
            return new t();
          };
        case 1:
          return function(a1) {
            return new t(a1);
          };
        case 2:
          return function(a1, a2) {
            return new t(a1, a2);
          };
        case 3:
          return function(a1, a2, a3) {
            return new t(a1, a2, a3);
          };
        case 4:
          return function(a1, a2, a3, a4) {
            return new t(a1, a2, a3, a4);
          };
        case 5:
          return function(a1, a2, a3, a4, a5) {
            return new t(a1, a2, a3, a4, a5);
          };
        case 6:
          return function(a1, a2, a3, a4, a5, a6) {
            return new t(a1, a2, a3, a4, a5, a6);
          };
        case 7:
          return function(a1, a2, a3, a4, a5, a6, a7) {
            return new t(a1, a2, a3, a4, a5, a6, a7);
          };
        case 8:
          return function(a1, a2, a3, a4, a5, a6, a7, a8) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8);
          };
        case 9:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9);
          };
        case 10:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          };
        case 11:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          };
        case 12:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          };
        case 13:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
          };
        case 14:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
          };
        case 15:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
          };
        case 16:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
          };
        case 17:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
          };
        case 18:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
          };
        case 19:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
          };
        case 20:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
          };
      }
      ;
      throw new Error("Cannot create a factory for '" + stringify(t) + "' because its constructor has more than 20 arguments");
    };
    ReflectionCapabilities.prototype._zipTypesAndAnnotations = function(paramTypes, paramAnnotations) {
      var result;
      if (typeof paramTypes === 'undefined') {
        result = new Array(paramAnnotations.length);
      } else {
        result = new Array(paramTypes.length);
      }
      for (var i = 0; i < result.length; i++) {
        if (typeof paramTypes === 'undefined') {
          result[i] = [];
        } else if (paramTypes[i] != Object) {
          result[i] = [paramTypes[i]];
        } else {
          result[i] = [];
        }
        if (isPresent(paramAnnotations) && isPresent(paramAnnotations[i])) {
          result[i] = result[i].concat(paramAnnotations[i]);
        }
      }
      return result;
    };
    ReflectionCapabilities.prototype.parameters = function(typeOrFunc) {
      if (isPresent(typeOrFunc.parameters)) {
        return typeOrFunc.parameters;
      }
      if (isPresent(typeOrFunc.ctorParameters)) {
        var ctorParameters = typeOrFunc.ctorParameters;
        var paramTypes_1 = ctorParameters.map(function(ctorParam) {
          return ctorParam && ctorParam.type;
        });
        var paramAnnotations_1 = ctorParameters.map(function(ctorParam) {
          return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
        });
        return this._zipTypesAndAnnotations(paramTypes_1, paramAnnotations_1);
      }
      if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
        var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);
        var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);
        if (isPresent(paramTypes) || isPresent(paramAnnotations)) {
          return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
        }
      }
      var parameters = new Array(typeOrFunc.length);
      parameters.fill(undefined);
      return parameters;
    };
    ReflectionCapabilities.prototype.annotations = function(typeOrFunc) {
      if (isPresent(typeOrFunc.annotations)) {
        var annotations = typeOrFunc.annotations;
        if (isFunction(annotations) && annotations.annotations) {
          annotations = annotations.annotations;
        }
        return annotations;
      }
      if (isPresent(typeOrFunc.decorators)) {
        return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
      }
      if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
        var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
        if (isPresent(annotations))
          return annotations;
      }
      return [];
    };
    ReflectionCapabilities.prototype.propMetadata = function(typeOrFunc) {
      if (isPresent(typeOrFunc.propMetadata)) {
        var propMetadata = typeOrFunc.propMetadata;
        if (isFunction(propMetadata) && propMetadata.propMetadata) {
          propMetadata = propMetadata.propMetadata;
        }
        return propMetadata;
      }
      if (isPresent(typeOrFunc.propDecorators)) {
        var propDecorators_1 = typeOrFunc.propDecorators;
        var propMetadata_1 = {};
        Object.keys(propDecorators_1).forEach(function(prop) {
          propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
        });
        return propMetadata_1;
      }
      if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
        var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
        if (isPresent(propMetadata))
          return propMetadata;
      }
      return {};
    };
    ReflectionCapabilities.prototype.interfaces = function(type) {
      throw new BaseException("JavaScript does not support interfaces");
    };
    ReflectionCapabilities.prototype.getter = function(name) {
      return new Function('o', 'return o.' + name + ';');
    };
    ReflectionCapabilities.prototype.setter = function(name) {
      return new Function('o', 'v', 'return o.' + name + ' = v;');
    };
    ReflectionCapabilities.prototype.method = function(name) {
      var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
      return new Function('o', 'args', functionBody);
    };
    ReflectionCapabilities.prototype.importUri = function(type) {
      return "./" + stringify(type);
    };
    return ReflectionCapabilities;
  }());
  function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
    if (!decoratorInvocations) {
      return [];
    }
    return decoratorInvocations.map(function(decoratorInvocation) {
      var decoratorType = decoratorInvocation.type;
      var annotationCls = decoratorType.annotationCls;
      var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
      var annotation = Object.create(annotationCls.prototype);
      annotationCls.apply(annotation, annotationArgs);
      return annotation;
    });
  }
  var reflector = new Reflector(new ReflectionCapabilities());
  var ReflectiveKey = (function() {
    function ReflectiveKey(token, id) {
      this.token = token;
      this.id = id;
      if (isBlank(token)) {
        throw new BaseException('Token must be defined!');
      }
    }
    Object.defineProperty(ReflectiveKey.prototype, "displayName", {
      get: function() {
        return stringify(this.token);
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveKey.get = function(token) {
      return _globalKeyRegistry.get(resolveForwardRef(token));
    };
    Object.defineProperty(ReflectiveKey, "numberOfKeys", {
      get: function() {
        return _globalKeyRegistry.numberOfKeys;
      },
      enumerable: true,
      configurable: true
    });
    return ReflectiveKey;
  }());
  var KeyRegistry = (function() {
    function KeyRegistry() {
      this._allKeys = new Map();
    }
    KeyRegistry.prototype.get = function(token) {
      if (token instanceof ReflectiveKey)
        return token;
      if (this._allKeys.has(token)) {
        return this._allKeys.get(token);
      }
      var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
      this._allKeys.set(token, newKey);
      return newKey;
    };
    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
      get: function() {
        return this._allKeys.size;
      },
      enumerable: true,
      configurable: true
    });
    return KeyRegistry;
  }());
  var _globalKeyRegistry = new KeyRegistry();
  function findFirstClosedCycle(keys) {
    var res = [];
    for (var i = 0; i < keys.length; ++i) {
      if (ListWrapper.contains(res, keys[i])) {
        res.push(keys[i]);
        return res;
      } else {
        res.push(keys[i]);
      }
    }
    return res;
  }
  function constructResolvingPath(keys) {
    if (keys.length > 1) {
      var reversed = findFirstClosedCycle(ListWrapper.reversed(keys));
      var tokenStrs = reversed.map(function(k) {
        return stringify(k.token);
      });
      return " (" + tokenStrs.join(' -> ') + ")";
    } else {
      return "";
    }
  }
  var AbstractProviderError = (function(_super) {
    __extends(AbstractProviderError, _super);
    function AbstractProviderError(injector, key, constructResolvingMessage) {
      _super.call(this, "DI Exception");
      this.keys = [key];
      this.injectors = [injector];
      this.constructResolvingMessage = constructResolvingMessage;
      this.message = this.constructResolvingMessage(this.keys);
    }
    AbstractProviderError.prototype.addKey = function(injector, key) {
      this.injectors.push(injector);
      this.keys.push(key);
      this.message = this.constructResolvingMessage(this.keys);
    };
    Object.defineProperty(AbstractProviderError.prototype, "context", {
      get: function() {
        return this.injectors[this.injectors.length - 1].debugContext();
      },
      enumerable: true,
      configurable: true
    });
    return AbstractProviderError;
  }(BaseException));
  var NoProviderError = (function(_super) {
    __extends(NoProviderError, _super);
    function NoProviderError(injector, key) {
      _super.call(this, injector, key, function(keys) {
        var first = stringify(ListWrapper.first(keys).token);
        return "No provider for " + first + "!" + constructResolvingPath(keys);
      });
    }
    return NoProviderError;
  }(AbstractProviderError));
  var CyclicDependencyError = (function(_super) {
    __extends(CyclicDependencyError, _super);
    function CyclicDependencyError(injector, key) {
      _super.call(this, injector, key, function(keys) {
        return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
      });
    }
    return CyclicDependencyError;
  }(AbstractProviderError));
  var InstantiationError = (function(_super) {
    __extends(InstantiationError, _super);
    function InstantiationError(injector, originalException, originalStack, key) {
      _super.call(this, "DI Exception", originalException, originalStack, null);
      this.keys = [key];
      this.injectors = [injector];
    }
    InstantiationError.prototype.addKey = function(injector, key) {
      this.injectors.push(injector);
      this.keys.push(key);
    };
    Object.defineProperty(InstantiationError.prototype, "wrapperMessage", {
      get: function() {
        var first = stringify(ListWrapper.first(this.keys).token);
        return "Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InstantiationError.prototype, "causeKey", {
      get: function() {
        return this.keys[0];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InstantiationError.prototype, "context", {
      get: function() {
        return this.injectors[this.injectors.length - 1].debugContext();
      },
      enumerable: true,
      configurable: true
    });
    return InstantiationError;
  }(WrappedException));
  var InvalidProviderError = (function(_super) {
    __extends(InvalidProviderError, _super);
    function InvalidProviderError(provider) {
      _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " + provider.toString());
    }
    return InvalidProviderError;
  }(BaseException));
  var NoAnnotationError = (function(_super) {
    __extends(NoAnnotationError, _super);
    function NoAnnotationError(typeOrFunc, params) {
      _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
    }
    NoAnnotationError._genMessage = function(typeOrFunc, params) {
      var signature = [];
      for (var i = 0,
          ii = params.length; i < ii; i++) {
        var parameter = params[i];
        if (isBlank(parameter) || parameter.length == 0) {
          signature.push('?');
        } else {
          signature.push(parameter.map(stringify).join(' '));
        }
      }
      return "Cannot resolve all parameters for '" + stringify(typeOrFunc) + "'(" + signature.join(', ') + "). " + "Make sure that all the parameters are decorated with Inject or have valid type annotations and that '" + stringify(typeOrFunc) + "' is decorated with Injectable.";
    };
    return NoAnnotationError;
  }(BaseException));
  var OutOfBoundsError = (function(_super) {
    __extends(OutOfBoundsError, _super);
    function OutOfBoundsError(index) {
      _super.call(this, "Index " + index + " is out-of-bounds.");
    }
    return OutOfBoundsError;
  }(BaseException));
  var MixingMultiProvidersWithRegularProvidersError = (function(_super) {
    __extends(MixingMultiProvidersWithRegularProvidersError, _super);
    function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
      _super.call(this, "Cannot mix multi providers and regular providers, got: " + provider1.toString() + " " + provider2.toString());
    }
    return MixingMultiProvidersWithRegularProvidersError;
  }(BaseException));
  var Provider = (function() {
    function Provider(token, _a) {
      var useClass = _a.useClass,
          useValue = _a.useValue,
          useExisting = _a.useExisting,
          useFactory = _a.useFactory,
          deps = _a.deps,
          multi = _a.multi;
      this.token = token;
      this.useClass = useClass;
      this.useValue = useValue;
      this.useExisting = useExisting;
      this.useFactory = useFactory;
      this.dependencies = deps;
      this._multi = multi;
    }
    Object.defineProperty(Provider.prototype, "multi", {
      get: function() {
        return normalizeBool(this._multi);
      },
      enumerable: true,
      configurable: true
    });
    return Provider;
  }());
  var Binding = (function(_super) {
    __extends(Binding, _super);
    function Binding(token, _a) {
      var toClass = _a.toClass,
          toValue = _a.toValue,
          toAlias = _a.toAlias,
          toFactory = _a.toFactory,
          deps = _a.deps,
          multi = _a.multi;
      _super.call(this, token, {
        useClass: toClass,
        useValue: toValue,
        useExisting: toAlias,
        useFactory: toFactory,
        deps: deps,
        multi: multi
      });
    }
    Object.defineProperty(Binding.prototype, "toClass", {
      get: function() {
        return this.useClass;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Binding.prototype, "toAlias", {
      get: function() {
        return this.useExisting;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Binding.prototype, "toFactory", {
      get: function() {
        return this.useFactory;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Binding.prototype, "toValue", {
      get: function() {
        return this.useValue;
      },
      enumerable: true,
      configurable: true
    });
    return Binding;
  }(Provider));
  function bind(token) {
    return new ProviderBuilder(token);
  }
  var ProviderBuilder = (function() {
    function ProviderBuilder(token) {
      this.token = token;
    }
    ProviderBuilder.prototype.toClass = function(type) {
      if (!isType(type)) {
        throw new BaseException("Trying to create a class provider but \"" + stringify(type) + "\" is not a class!");
      }
      return new Provider(this.token, {useClass: type});
    };
    ProviderBuilder.prototype.toValue = function(value) {
      return new Provider(this.token, {useValue: value});
    };
    ProviderBuilder.prototype.toAlias = function(aliasToken) {
      if (isBlank(aliasToken)) {
        throw new BaseException("Can not alias " + stringify(this.token) + " to a blank value!");
      }
      return new Provider(this.token, {useExisting: aliasToken});
    };
    ProviderBuilder.prototype.toFactory = function(factory, dependencies) {
      if (!isFunction(factory)) {
        throw new BaseException("Trying to create a factory provider but \"" + stringify(factory) + "\" is not a function!");
      }
      return new Provider(this.token, {
        useFactory: factory,
        deps: dependencies
      });
    };
    return ProviderBuilder;
  }());
  function provide(token, _a) {
    var useClass = _a.useClass,
        useValue = _a.useValue,
        useExisting = _a.useExisting,
        useFactory = _a.useFactory,
        deps = _a.deps,
        multi = _a.multi;
    return new Provider(token, {
      useClass: useClass,
      useValue: useValue,
      useExisting: useExisting,
      useFactory: useFactory,
      deps: deps,
      multi: multi
    });
  }
  function isProviderLiteral(obj) {
    return obj && typeof obj == 'object' && obj.provide;
  }
  function createProvider(obj) {
    return new Provider(obj.provide, obj);
  }
  var ReflectiveDependency = (function() {
    function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
      this.key = key;
      this.optional = optional;
      this.lowerBoundVisibility = lowerBoundVisibility;
      this.upperBoundVisibility = upperBoundVisibility;
      this.properties = properties;
    }
    ReflectiveDependency.fromKey = function(key) {
      return new ReflectiveDependency(key, false, null, null, []);
    };
    return ReflectiveDependency;
  }());
  var _EMPTY_LIST = [];
  var ResolvedReflectiveProvider_ = (function() {
    function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
      this.key = key;
      this.resolvedFactories = resolvedFactories;
      this.multiProvider = multiProvider;
    }
    Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
      get: function() {
        return this.resolvedFactories[0];
      },
      enumerable: true,
      configurable: true
    });
    return ResolvedReflectiveProvider_;
  }());
  var ResolvedReflectiveFactory = (function() {
    function ResolvedReflectiveFactory(factory, dependencies) {
      this.factory = factory;
      this.dependencies = dependencies;
    }
    return ResolvedReflectiveFactory;
  }());
  function resolveReflectiveFactory(provider) {
    var factoryFn;
    var resolvedDeps;
    if (isPresent(provider.useClass)) {
      var useClass = resolveForwardRef(provider.useClass);
      factoryFn = reflector.factory(useClass);
      resolvedDeps = _dependenciesFor(useClass);
    } else if (isPresent(provider.useExisting)) {
      factoryFn = function(aliasInstance) {
        return aliasInstance;
      };
      resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
    } else if (isPresent(provider.useFactory)) {
      factoryFn = provider.useFactory;
      resolvedDeps = constructDependencies(provider.useFactory, provider.dependencies);
    } else {
      factoryFn = function() {
        return provider.useValue;
      };
      resolvedDeps = _EMPTY_LIST;
    }
    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
  }
  function resolveReflectiveProvider(provider) {
    return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.token), [resolveReflectiveFactory(provider)], provider.multi);
  }
  function resolveReflectiveProviders(providers) {
    var normalized = _normalizeProviders(providers, []);
    var resolved = normalized.map(resolveReflectiveProvider);
    return MapWrapper.values(mergeResolvedReflectiveProviders(resolved, new Map()));
  }
  function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
    for (var i = 0; i < providers.length; i++) {
      var provider = providers[i];
      var existing = normalizedProvidersMap.get(provider.key.id);
      if (isPresent(existing)) {
        if (provider.multiProvider !== existing.multiProvider) {
          throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);
        }
        if (provider.multiProvider) {
          for (var j = 0; j < provider.resolvedFactories.length; j++) {
            existing.resolvedFactories.push(provider.resolvedFactories[j]);
          }
        } else {
          normalizedProvidersMap.set(provider.key.id, provider);
        }
      } else {
        var resolvedProvider;
        if (provider.multiProvider) {
          resolvedProvider = new ResolvedReflectiveProvider_(provider.key, ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);
        } else {
          resolvedProvider = provider;
        }
        normalizedProvidersMap.set(provider.key.id, resolvedProvider);
      }
    }
    return normalizedProvidersMap;
  }
  function _normalizeProviders(providers, res) {
    providers.forEach(function(b) {
      if (b instanceof Type) {
        res.push(provide(b, {useClass: b}));
      } else if (b instanceof Provider) {
        res.push(b);
      } else if (isProviderLiteral(b)) {
        res.push(createProvider(b));
      } else if (b instanceof Array) {
        _normalizeProviders(b, res);
      } else if (b instanceof ProviderBuilder) {
        throw new InvalidProviderError(b.token);
      } else {
        throw new InvalidProviderError(b);
      }
    });
    return res;
  }
  function constructDependencies(typeOrFunc, dependencies) {
    if (isBlank(dependencies)) {
      return _dependenciesFor(typeOrFunc);
    } else {
      var params = dependencies.map(function(t) {
        return [t];
      });
      return dependencies.map(function(t) {
        return _extractToken(typeOrFunc, t, params);
      });
    }
  }
  function _dependenciesFor(typeOrFunc) {
    var params = reflector.parameters(typeOrFunc);
    if (isBlank(params))
      return [];
    if (params.some(isBlank)) {
      throw new NoAnnotationError(typeOrFunc, params);
    }
    return params.map(function(p) {
      return _extractToken(typeOrFunc, p, params);
    });
  }
  function _extractToken(typeOrFunc, metadata, params) {
    var depProps = [];
    var token = null;
    var optional = false;
    if (!isArray(metadata)) {
      if (metadata instanceof InjectMetadata) {
        return _createDependency(metadata.token, optional, null, null, depProps);
      } else {
        return _createDependency(metadata, optional, null, null, depProps);
      }
    }
    var lowerBoundVisibility = null;
    var upperBoundVisibility = null;
    for (var i = 0; i < metadata.length; ++i) {
      var paramMetadata = metadata[i];
      if (paramMetadata instanceof Type) {
        token = paramMetadata;
      } else if (paramMetadata instanceof InjectMetadata) {
        token = paramMetadata.token;
      } else if (paramMetadata instanceof OptionalMetadata) {
        optional = true;
      } else if (paramMetadata instanceof SelfMetadata) {
        upperBoundVisibility = paramMetadata;
      } else if (paramMetadata instanceof HostMetadata) {
        upperBoundVisibility = paramMetadata;
      } else if (paramMetadata instanceof SkipSelfMetadata) {
        lowerBoundVisibility = paramMetadata;
      } else if (paramMetadata instanceof DependencyMetadata) {
        if (isPresent(paramMetadata.token)) {
          token = paramMetadata.token;
        }
        depProps.push(paramMetadata);
      }
    }
    token = resolveForwardRef(token);
    if (isPresent(token)) {
      return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
    } else {
      throw new NoAnnotationError(typeOrFunc, params);
    }
  }
  function _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {
    return new ReflectiveDependency(ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
  }
  var _MAX_CONSTRUCTION_COUNTER = 10;
  var UNDEFINED = new Object();
  var ReflectiveProtoInjectorInlineStrategy = (function() {
    function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
      this.provider0 = null;
      this.provider1 = null;
      this.provider2 = null;
      this.provider3 = null;
      this.provider4 = null;
      this.provider5 = null;
      this.provider6 = null;
      this.provider7 = null;
      this.provider8 = null;
      this.provider9 = null;
      this.keyId0 = null;
      this.keyId1 = null;
      this.keyId2 = null;
      this.keyId3 = null;
      this.keyId4 = null;
      this.keyId5 = null;
      this.keyId6 = null;
      this.keyId7 = null;
      this.keyId8 = null;
      this.keyId9 = null;
      var length = providers.length;
      if (length > 0) {
        this.provider0 = providers[0];
        this.keyId0 = providers[0].key.id;
      }
      if (length > 1) {
        this.provider1 = providers[1];
        this.keyId1 = providers[1].key.id;
      }
      if (length > 2) {
        this.provider2 = providers[2];
        this.keyId2 = providers[2].key.id;
      }
      if (length > 3) {
        this.provider3 = providers[3];
        this.keyId3 = providers[3].key.id;
      }
      if (length > 4) {
        this.provider4 = providers[4];
        this.keyId4 = providers[4].key.id;
      }
      if (length > 5) {
        this.provider5 = providers[5];
        this.keyId5 = providers[5].key.id;
      }
      if (length > 6) {
        this.provider6 = providers[6];
        this.keyId6 = providers[6].key.id;
      }
      if (length > 7) {
        this.provider7 = providers[7];
        this.keyId7 = providers[7].key.id;
      }
      if (length > 8) {
        this.provider8 = providers[8];
        this.keyId8 = providers[8].key.id;
      }
      if (length > 9) {
        this.provider9 = providers[9];
        this.keyId9 = providers[9].key.id;
      }
    }
    ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function(index) {
      if (index == 0)
        return this.provider0;
      if (index == 1)
        return this.provider1;
      if (index == 2)
        return this.provider2;
      if (index == 3)
        return this.provider3;
      if (index == 4)
        return this.provider4;
      if (index == 5)
        return this.provider5;
      if (index == 6)
        return this.provider6;
      if (index == 7)
        return this.provider7;
      if (index == 8)
        return this.provider8;
      if (index == 9)
        return this.provider9;
      throw new OutOfBoundsError(index);
    };
    ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function(injector) {
      return new ReflectiveInjectorInlineStrategy(injector, this);
    };
    return ReflectiveProtoInjectorInlineStrategy;
  }());
  var ReflectiveProtoInjectorDynamicStrategy = (function() {
    function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
      this.providers = providers;
      var len = providers.length;
      this.keyIds = ListWrapper.createFixedSize(len);
      for (var i = 0; i < len; i++) {
        this.keyIds[i] = providers[i].key.id;
      }
    }
    ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function(index) {
      if (index < 0 || index >= this.providers.length) {
        throw new OutOfBoundsError(index);
      }
      return this.providers[index];
    };
    ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function(ei) {
      return new ReflectiveInjectorDynamicStrategy(this, ei);
    };
    return ReflectiveProtoInjectorDynamicStrategy;
  }());
  var ReflectiveProtoInjector = (function() {
    function ReflectiveProtoInjector(providers) {
      this.numberOfProviders = providers.length;
      this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ? new ReflectiveProtoInjectorDynamicStrategy(this, providers) : new ReflectiveProtoInjectorInlineStrategy(this, providers);
    }
    ReflectiveProtoInjector.fromResolvedProviders = function(providers) {
      return new ReflectiveProtoInjector(providers);
    };
    ReflectiveProtoInjector.prototype.getProviderAtIndex = function(index) {
      return this._strategy.getProviderAtIndex(index);
    };
    return ReflectiveProtoInjector;
  }());
  var ReflectiveInjectorInlineStrategy = (function() {
    function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
      this.injector = injector;
      this.protoStrategy = protoStrategy;
      this.obj0 = UNDEFINED;
      this.obj1 = UNDEFINED;
      this.obj2 = UNDEFINED;
      this.obj3 = UNDEFINED;
      this.obj4 = UNDEFINED;
      this.obj5 = UNDEFINED;
      this.obj6 = UNDEFINED;
      this.obj7 = UNDEFINED;
      this.obj8 = UNDEFINED;
      this.obj9 = UNDEFINED;
    }
    ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function() {
      this.injector._constructionCounter = 0;
    };
    ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function(provider) {
      return this.injector._new(provider);
    };
    ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function(keyId) {
      var p = this.protoStrategy;
      var inj = this.injector;
      if (p.keyId0 === keyId) {
        if (this.obj0 === UNDEFINED) {
          this.obj0 = inj._new(p.provider0);
        }
        return this.obj0;
      }
      if (p.keyId1 === keyId) {
        if (this.obj1 === UNDEFINED) {
          this.obj1 = inj._new(p.provider1);
        }
        return this.obj1;
      }
      if (p.keyId2 === keyId) {
        if (this.obj2 === UNDEFINED) {
          this.obj2 = inj._new(p.provider2);
        }
        return this.obj2;
      }
      if (p.keyId3 === keyId) {
        if (this.obj3 === UNDEFINED) {
          this.obj3 = inj._new(p.provider3);
        }
        return this.obj3;
      }
      if (p.keyId4 === keyId) {
        if (this.obj4 === UNDEFINED) {
          this.obj4 = inj._new(p.provider4);
        }
        return this.obj4;
      }
      if (p.keyId5 === keyId) {
        if (this.obj5 === UNDEFINED) {
          this.obj5 = inj._new(p.provider5);
        }
        return this.obj5;
      }
      if (p.keyId6 === keyId) {
        if (this.obj6 === UNDEFINED) {
          this.obj6 = inj._new(p.provider6);
        }
        return this.obj6;
      }
      if (p.keyId7 === keyId) {
        if (this.obj7 === UNDEFINED) {
          this.obj7 = inj._new(p.provider7);
        }
        return this.obj7;
      }
      if (p.keyId8 === keyId) {
        if (this.obj8 === UNDEFINED) {
          this.obj8 = inj._new(p.provider8);
        }
        return this.obj8;
      }
      if (p.keyId9 === keyId) {
        if (this.obj9 === UNDEFINED) {
          this.obj9 = inj._new(p.provider9);
        }
        return this.obj9;
      }
      return UNDEFINED;
    };
    ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function(index) {
      if (index == 0)
        return this.obj0;
      if (index == 1)
        return this.obj1;
      if (index == 2)
        return this.obj2;
      if (index == 3)
        return this.obj3;
      if (index == 4)
        return this.obj4;
      if (index == 5)
        return this.obj5;
      if (index == 6)
        return this.obj6;
      if (index == 7)
        return this.obj7;
      if (index == 8)
        return this.obj8;
      if (index == 9)
        return this.obj9;
      throw new OutOfBoundsError(index);
    };
    ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function() {
      return _MAX_CONSTRUCTION_COUNTER;
    };
    return ReflectiveInjectorInlineStrategy;
  }());
  var ReflectiveInjectorDynamicStrategy = (function() {
    function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
      this.protoStrategy = protoStrategy;
      this.injector = injector;
      this.objs = ListWrapper.createFixedSize(protoStrategy.providers.length);
      ListWrapper.fill(this.objs, UNDEFINED);
    }
    ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function() {
      this.injector._constructionCounter = 0;
    };
    ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function(provider) {
      return this.injector._new(provider);
    };
    ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function(keyId) {
      var p = this.protoStrategy;
      for (var i = 0; i < p.keyIds.length; i++) {
        if (p.keyIds[i] === keyId) {
          if (this.objs[i] === UNDEFINED) {
            this.objs[i] = this.injector._new(p.providers[i]);
          }
          return this.objs[i];
        }
      }
      return UNDEFINED;
    };
    ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function(index) {
      if (index < 0 || index >= this.objs.length) {
        throw new OutOfBoundsError(index);
      }
      return this.objs[index];
    };
    ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function() {
      return this.objs.length;
    };
    return ReflectiveInjectorDynamicStrategy;
  }());
  var ReflectiveInjector = (function() {
    function ReflectiveInjector() {}
    ReflectiveInjector.resolve = function(providers) {
      return resolveReflectiveProviders(providers);
    };
    ReflectiveInjector.resolveAndCreate = function(providers, parent) {
      if (parent === void 0) {
        parent = null;
      }
      var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
    };
    ReflectiveInjector.fromResolvedProviders = function(providers, parent) {
      if (parent === void 0) {
        parent = null;
      }
      return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
    };
    ReflectiveInjector.fromResolvedBindings = function(providers) {
      return ReflectiveInjector.fromResolvedProviders(providers);
    };
    Object.defineProperty(ReflectiveInjector.prototype, "parent", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveInjector.prototype.debugContext = function() {
      return null;
    };
    ReflectiveInjector.prototype.resolveAndCreateChild = function(providers) {
      return unimplemented();
    };
    ReflectiveInjector.prototype.createChildFromResolved = function(providers) {
      return unimplemented();
    };
    ReflectiveInjector.prototype.resolveAndInstantiate = function(provider) {
      return unimplemented();
    };
    ReflectiveInjector.prototype.instantiateResolved = function(provider) {
      return unimplemented();
    };
    return ReflectiveInjector;
  }());
  var ReflectiveInjector_ = (function() {
    function ReflectiveInjector_(_proto, _parent, _debugContext) {
      if (_parent === void 0) {
        _parent = null;
      }
      if (_debugContext === void 0) {
        _debugContext = null;
      }
      this._debugContext = _debugContext;
      this._constructionCounter = 0;
      this._proto = _proto;
      this._parent = _parent;
      this._strategy = _proto._strategy.createInjectorStrategy(this);
    }
    ReflectiveInjector_.prototype.debugContext = function() {
      return this._debugContext();
    };
    ReflectiveInjector_.prototype.get = function(token, notFoundValue) {
      if (notFoundValue === void 0) {
        notFoundValue = THROW_IF_NOT_FOUND;
      }
      return this._getByKey(ReflectiveKey.get(token), null, null, notFoundValue);
    };
    ReflectiveInjector_.prototype.getAt = function(index) {
      return this._strategy.getObjAtIndex(index);
    };
    Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
      get: function() {
        return this._parent;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReflectiveInjector_.prototype, "internalStrategy", {
      get: function() {
        return this._strategy;
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveInjector_.prototype.resolveAndCreateChild = function(providers) {
      var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return this.createChildFromResolved(ResolvedReflectiveProviders);
    };
    ReflectiveInjector_.prototype.createChildFromResolved = function(providers) {
      var proto = new ReflectiveProtoInjector(providers);
      var inj = new ReflectiveInjector_(proto);
      inj._parent = this;
      return inj;
    };
    ReflectiveInjector_.prototype.resolveAndInstantiate = function(provider) {
      return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
    };
    ReflectiveInjector_.prototype.instantiateResolved = function(provider) {
      return this._instantiateProvider(provider);
    };
    ReflectiveInjector_.prototype._new = function(provider) {
      if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
        throw new CyclicDependencyError(this, provider.key);
      }
      return this._instantiateProvider(provider);
    };
    ReflectiveInjector_.prototype._instantiateProvider = function(provider) {
      if (provider.multiProvider) {
        var res = ListWrapper.createFixedSize(provider.resolvedFactories.length);
        for (var i = 0; i < provider.resolvedFactories.length; ++i) {
          res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
        }
        return res;
      } else {
        return this._instantiate(provider, provider.resolvedFactories[0]);
      }
    };
    ReflectiveInjector_.prototype._instantiate = function(provider, ResolvedReflectiveFactory) {
      var factory = ResolvedReflectiveFactory.factory;
      var deps = ResolvedReflectiveFactory.dependencies;
      var length = deps.length;
      var d0;
      var d1;
      var d2;
      var d3;
      var d4;
      var d5;
      var d6;
      var d7;
      var d8;
      var d9;
      var d10;
      var d11;
      var d12;
      var d13;
      var d14;
      var d15;
      var d16;
      var d17;
      var d18;
      var d19;
      try {
        d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
        d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
        d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
        d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
        d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
        d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
        d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
        d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
        d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
        d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
        d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
        d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
        d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
        d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
        d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
        d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
        d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
        d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
        d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
        d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
      } catch (e) {
        if (e instanceof AbstractProviderError || e instanceof InstantiationError) {
          e.addKey(this, provider.key);
        }
        throw e;
      }
      var obj;
      try {
        switch (length) {
          case 0:
            obj = factory();
            break;
          case 1:
            obj = factory(d0);
            break;
          case 2:
            obj = factory(d0, d1);
            break;
          case 3:
            obj = factory(d0, d1, d2);
            break;
          case 4:
            obj = factory(d0, d1, d2, d3);
            break;
          case 5:
            obj = factory(d0, d1, d2, d3, d4);
            break;
          case 6:
            obj = factory(d0, d1, d2, d3, d4, d5);
            break;
          case 7:
            obj = factory(d0, d1, d2, d3, d4, d5, d6);
            break;
          case 8:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
            break;
          case 9:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
            break;
          case 10:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
            break;
          case 11:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
            break;
          case 12:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
            break;
          case 13:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
            break;
          case 14:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
            break;
          case 15:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
            break;
          case 16:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
            break;
          case 17:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
            break;
          case 18:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
            break;
          case 19:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
            break;
          case 20:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
            break;
          default:
            throw new BaseException("Cannot instantiate '" + provider.key.displayName + "' because it has more than 20 dependencies");
        }
      } catch (e) {
        throw new InstantiationError(this, e, e.stack, provider.key);
      }
      return obj;
    };
    ReflectiveInjector_.prototype._getByReflectiveDependency = function(provider, dep) {
      return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : THROW_IF_NOT_FOUND);
    };
    ReflectiveInjector_.prototype._getByKey = function(key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
      if (key === INJECTOR_KEY) {
        return this;
      }
      if (upperBoundVisibility instanceof SelfMetadata) {
        return this._getByKeySelf(key, notFoundValue);
      } else {
        return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
      }
    };
    ReflectiveInjector_.prototype._throwOrNull = function(key, notFoundValue) {
      if (notFoundValue !== THROW_IF_NOT_FOUND) {
        return notFoundValue;
      } else {
        throw new NoProviderError(this, key);
      }
    };
    ReflectiveInjector_.prototype._getByKeySelf = function(key, notFoundValue) {
      var obj = this._strategy.getObjByKeyId(key.id);
      return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
    };
    ReflectiveInjector_.prototype._getByKeyDefault = function(key, notFoundValue, lowerBoundVisibility) {
      var inj;
      if (lowerBoundVisibility instanceof SkipSelfMetadata) {
        inj = this._parent;
      } else {
        inj = this;
      }
      while (inj instanceof ReflectiveInjector_) {
        var inj_ = inj;
        var obj = inj_._strategy.getObjByKeyId(key.id);
        if (obj !== UNDEFINED)
          return obj;
        inj = inj_._parent;
      }
      if (inj !== null) {
        return inj.get(key.token, notFoundValue);
      } else {
        return this._throwOrNull(key, notFoundValue);
      }
    };
    Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
      get: function() {
        return "ReflectiveInjector(providers: [" + _mapProviders(this, function(b) {
          return (" \"" + b.key.displayName + "\" ");
        }).join(", ") + "])";
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveInjector_.prototype.toString = function() {
      return this.displayName;
    };
    return ReflectiveInjector_;
  }());
  var INJECTOR_KEY = ReflectiveKey.get(Injector);
  function _mapProviders(injector, fn) {
    var res = [];
    for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
      res.push(fn(injector._proto.getProviderAtIndex(i)));
    }
    return res;
  }
  var OpaqueToken = (function() {
    function OpaqueToken(_desc) {
      this._desc = _desc;
    }
    OpaqueToken.prototype.toString = function() {
      return "Token " + this._desc;
    };
    return OpaqueToken;
  }());
  var PromiseCompleter = (function() {
    function PromiseCompleter() {
      var _this = this;
      this.promise = new Promise(function(res, rej) {
        _this.resolve = res;
        _this.reject = rej;
      });
    }
    return PromiseCompleter;
  }());
  var PromiseWrapper = (function() {
    function PromiseWrapper() {}
    PromiseWrapper.resolve = function(obj) {
      return Promise.resolve(obj);
    };
    PromiseWrapper.reject = function(obj, _) {
      return Promise.reject(obj);
    };
    PromiseWrapper.catchError = function(promise, onError) {
      return promise.catch(onError);
    };
    PromiseWrapper.all = function(promises) {
      if (promises.length == 0)
        return Promise.resolve([]);
      return Promise.all(promises);
    };
    PromiseWrapper.then = function(promise, success, rejection) {
      return promise.then(success, rejection);
    };
    PromiseWrapper.wrap = function(computation) {
      return new Promise(function(res, rej) {
        try {
          res(computation());
        } catch (e) {
          rej(e);
        }
      });
    };
    PromiseWrapper.scheduleMicrotask = function(computation) {
      PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function(_) {});
    };
    PromiseWrapper.isPromise = function(obj) {
      return obj instanceof Promise;
    };
    PromiseWrapper.completer = function() {
      return new PromiseCompleter();
    };
    return PromiseWrapper;
  }());
  var ObservableWrapper = (function() {
    function ObservableWrapper() {}
    ObservableWrapper.subscribe = function(emitter, onNext, onError, onComplete) {
      if (onComplete === void 0) {
        onComplete = function() {};
      }
      onError = (typeof onError === "function") && onError || noop;
      onComplete = (typeof onComplete === "function") && onComplete || noop;
      return emitter.subscribe({
        next: onNext,
        error: onError,
        complete: onComplete
      });
    };
    ObservableWrapper.isObservable = function(obs) {
      return !!obs.subscribe;
    };
    ObservableWrapper.hasSubscribers = function(obs) {
      return obs.observers.length > 0;
    };
    ObservableWrapper.dispose = function(subscription) {
      subscription.unsubscribe();
    };
    ObservableWrapper.callNext = function(emitter, value) {
      emitter.next(value);
    };
    ObservableWrapper.callEmit = function(emitter, value) {
      emitter.emit(value);
    };
    ObservableWrapper.callError = function(emitter, error) {
      emitter.error(error);
    };
    ObservableWrapper.callComplete = function(emitter) {
      emitter.complete();
    };
    ObservableWrapper.fromPromise = function(promise) {
      return rxjs_observable_PromiseObservable.PromiseObservable.create(promise);
    };
    ObservableWrapper.toPromise = function(obj) {
      return rxjs_operator_toPromise.toPromise.call(obj);
    };
    return ObservableWrapper;
  }());
  var EventEmitter = (function(_super) {
    __extends(EventEmitter, _super);
    function EventEmitter(isAsync) {
      if (isAsync === void 0) {
        isAsync = true;
      }
      _super.call(this);
      this._isAsync = isAsync;
    }
    EventEmitter.prototype.emit = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.next = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.subscribe = function(generatorOrNext, error, complete) {
      var schedulerFn;
      var errorFn = function(err) {
        return null;
      };
      var completeFn = function() {
        return null;
      };
      if (generatorOrNext && typeof generatorOrNext === 'object') {
        schedulerFn = this._isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext.next(value);
          });
        } : function(value) {
          generatorOrNext.next(value);
        };
        if (generatorOrNext.error) {
          errorFn = this._isAsync ? function(err) {
            setTimeout(function() {
              return generatorOrNext.error(err);
            });
          } : function(err) {
            generatorOrNext.error(err);
          };
        }
        if (generatorOrNext.complete) {
          completeFn = this._isAsync ? function() {
            setTimeout(function() {
              return generatorOrNext.complete();
            });
          } : function() {
            generatorOrNext.complete();
          };
        }
      } else {
        schedulerFn = this._isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext(value);
          });
        } : function(value) {
          generatorOrNext(value);
        };
        if (error) {
          errorFn = this._isAsync ? function(err) {
            setTimeout(function() {
              return error(err);
            });
          } : function(err) {
            error(err);
          };
        }
        if (complete) {
          completeFn = this._isAsync ? function() {
            setTimeout(function() {
              return complete();
            });
          } : function() {
            complete();
          };
        }
      }
      return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
    };
    return EventEmitter;
  }(rxjs_Subject.Subject));
  var NgZoneError = (function() {
    function NgZoneError(error, stackTrace) {
      this.error = error;
      this.stackTrace = stackTrace;
    }
    return NgZoneError;
  }());
  var NgZoneImpl = (function() {
    function NgZoneImpl(_a) {
      var _this = this;
      var trace = _a.trace,
          onEnter = _a.onEnter,
          onLeave = _a.onLeave,
          setMicrotask = _a.setMicrotask,
          setMacrotask = _a.setMacrotask,
          onError = _a.onError;
      this.onEnter = onEnter;
      this.onLeave = onLeave;
      this.setMicrotask = setMicrotask;
      this.setMacrotask = setMacrotask;
      this.onError = onError;
      if (Zone) {
        this.outer = this.inner = Zone.current;
        if (Zone['wtfZoneSpec']) {
          this.inner = this.inner.fork(Zone['wtfZoneSpec']);
        }
        if (trace && Zone['longStackTraceZoneSpec']) {
          this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
        }
        this.inner = this.inner.fork({
          name: 'angular',
          properties: {'isAngularZone': true},
          onInvokeTask: function(delegate, current, target, task, applyThis, applyArgs) {
            try {
              _this.onEnter();
              return delegate.invokeTask(target, task, applyThis, applyArgs);
            } finally {
              _this.onLeave();
            }
          },
          onInvoke: function(delegate, current, target, callback, applyThis, applyArgs, source) {
            try {
              _this.onEnter();
              return delegate.invoke(target, callback, applyThis, applyArgs, source);
            } finally {
              _this.onLeave();
            }
          },
          onHasTask: function(delegate, current, target, hasTaskState) {
            delegate.hasTask(target, hasTaskState);
            if (current == target) {
              if (hasTaskState.change == 'microTask') {
                _this.setMicrotask(hasTaskState.microTask);
              } else if (hasTaskState.change == 'macroTask') {
                _this.setMacrotask(hasTaskState.macroTask);
              }
            }
          },
          onHandleError: function(delegate, current, target, error) {
            delegate.handleError(target, error);
            _this.onError(new NgZoneError(error, error.stack));
            return false;
          }
        });
      } else {
        throw new Error('Angular requires Zone.js polyfill.');
      }
    }
    NgZoneImpl.isInAngularZone = function() {
      return Zone.current.get('isAngularZone') === true;
    };
    NgZoneImpl.prototype.runInner = function(fn) {
      return this.inner.run(fn);
    };
    ;
    NgZoneImpl.prototype.runInnerGuarded = function(fn) {
      return this.inner.runGuarded(fn);
    };
    ;
    NgZoneImpl.prototype.runOuter = function(fn) {
      return this.outer.run(fn);
    };
    ;
    return NgZoneImpl;
  }());
  var NgZone = (function() {
    function NgZone(_a) {
      var _this = this;
      var _b = _a.enableLongStackTrace,
          enableLongStackTrace = _b === void 0 ? false : _b;
      this._hasPendingMicrotasks = false;
      this._hasPendingMacrotasks = false;
      this._isStable = true;
      this._nesting = 0;
      this._onUnstable = new EventEmitter(false);
      this._onMicrotaskEmpty = new EventEmitter(false);
      this._onStable = new EventEmitter(false);
      this._onErrorEvents = new EventEmitter(false);
      this._zoneImpl = new NgZoneImpl({
        trace: enableLongStackTrace,
        onEnter: function() {
          _this._nesting++;
          if (_this._isStable) {
            _this._isStable = false;
            _this._onUnstable.emit(null);
          }
        },
        onLeave: function() {
          _this._nesting--;
          _this._checkStable();
        },
        setMicrotask: function(hasMicrotasks) {
          _this._hasPendingMicrotasks = hasMicrotasks;
          _this._checkStable();
        },
        setMacrotask: function(hasMacrotasks) {
          _this._hasPendingMacrotasks = hasMacrotasks;
        },
        onError: function(error) {
          return _this._onErrorEvents.emit(error);
        }
      });
    }
    NgZone.isInAngularZone = function() {
      return NgZoneImpl.isInAngularZone();
    };
    NgZone.assertInAngularZone = function() {
      if (!NgZoneImpl.isInAngularZone()) {
        throw new BaseException('Expected to be in Angular Zone, but it is not!');
      }
    };
    NgZone.assertNotInAngularZone = function() {
      if (NgZoneImpl.isInAngularZone()) {
        throw new BaseException('Expected to not be in Angular Zone, but it is!');
      }
    };
    NgZone.prototype._checkStable = function() {
      var _this = this;
      if (this._nesting == 0) {
        if (!this._hasPendingMicrotasks && !this._isStable) {
          try {
            this._nesting++;
            this._onMicrotaskEmpty.emit(null);
          } finally {
            this._nesting--;
            if (!this._hasPendingMicrotasks) {
              try {
                this.runOutsideAngular(function() {
                  return _this._onStable.emit(null);
                });
              } finally {
                this._isStable = true;
              }
            }
          }
        }
      }
    };
    ;
    Object.defineProperty(NgZone.prototype, "onUnstable", {
      get: function() {
        return this._onUnstable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
      get: function() {
        return this._onMicrotaskEmpty;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "onStable", {
      get: function() {
        return this._onStable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "onError", {
      get: function() {
        return this._onErrorEvents;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
      get: function() {
        return this._hasPendingMicrotasks;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
      get: function() {
        return this._hasPendingMacrotasks;
      },
      enumerable: true,
      configurable: true
    });
    NgZone.prototype.run = function(fn) {
      return this._zoneImpl.runInner(fn);
    };
    NgZone.prototype.runGuarded = function(fn) {
      return this._zoneImpl.runInnerGuarded(fn);
    };
    NgZone.prototype.runOutsideAngular = function(fn) {
      return this._zoneImpl.runOuter(fn);
    };
    return NgZone;
  }());
  var APP_ID = new OpaqueToken('AppId');
  function _appIdRandomProviderFactory() {
    return "" + _randomChar() + _randomChar() + _randomChar();
  }
  var APP_ID_RANDOM_PROVIDER = {
    provide: APP_ID,
    useFactory: _appIdRandomProviderFactory,
    deps: []
  };
  function _randomChar() {
    return StringWrapper.fromCharCode(97 + Math.floor(Math.random() * 25));
  }
  var PLATFORM_INITIALIZER = new OpaqueToken("Platform Initializer");
  var APP_INITIALIZER = new OpaqueToken("Application Initializer");
  var PACKAGE_ROOT_URL = new OpaqueToken("Application Packages Root URL");
  var Testability = (function() {
    function Testability(_ngZone) {
      this._ngZone = _ngZone;
      this._pendingCount = 0;
      this._isZoneStable = true;
      this._didWork = false;
      this._callbacks = [];
      this._watchAngularEvents();
    }
    Testability.prototype._watchAngularEvents = function() {
      var _this = this;
      ObservableWrapper.subscribe(this._ngZone.onUnstable, function(_) {
        _this._didWork = true;
        _this._isZoneStable = false;
      });
      this._ngZone.runOutsideAngular(function() {
        ObservableWrapper.subscribe(_this._ngZone.onStable, function(_) {
          NgZone.assertNotInAngularZone();
          scheduleMicroTask(function() {
            _this._isZoneStable = true;
            _this._runCallbacksIfReady();
          });
        });
      });
    };
    Testability.prototype.increasePendingRequestCount = function() {
      this._pendingCount += 1;
      this._didWork = true;
      return this._pendingCount;
    };
    Testability.prototype.decreasePendingRequestCount = function() {
      this._pendingCount -= 1;
      if (this._pendingCount < 0) {
        throw new BaseException('pending async requests below zero');
      }
      this._runCallbacksIfReady();
      return this._pendingCount;
    };
    Testability.prototype.isStable = function() {
      return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
    };
    Testability.prototype._runCallbacksIfReady = function() {
      var _this = this;
      if (this.isStable()) {
        scheduleMicroTask(function() {
          while (_this._callbacks.length !== 0) {
            (_this._callbacks.pop())(_this._didWork);
          }
          _this._didWork = false;
        });
      } else {
        this._didWork = true;
      }
    };
    Testability.prototype.whenStable = function(callback) {
      this._callbacks.push(callback);
      this._runCallbacksIfReady();
    };
    Testability.prototype.getPendingRequestCount = function() {
      return this._pendingCount;
    };
    Testability.prototype.findBindings = function(using, provider, exactMatch) {
      return [];
    };
    Testability.prototype.findProviders = function(using, provider, exactMatch) {
      return [];
    };
    return Testability;
  }());
  Testability.decorators = [{type: Injectable}];
  Testability.ctorParameters = [{type: NgZone}];
  var TestabilityRegistry = (function() {
    function TestabilityRegistry() {
      this._applications = new Map$1();
      _testabilityGetter.addToWindow(this);
    }
    TestabilityRegistry.prototype.registerApplication = function(token, testability) {
      this._applications.set(token, testability);
    };
    TestabilityRegistry.prototype.getTestability = function(elem) {
      return this._applications.get(elem);
    };
    TestabilityRegistry.prototype.getAllTestabilities = function() {
      return MapWrapper.values(this._applications);
    };
    TestabilityRegistry.prototype.getAllRootElements = function() {
      return MapWrapper.keys(this._applications);
    };
    TestabilityRegistry.prototype.findTestabilityInTree = function(elem, findInAncestors) {
      if (findInAncestors === void 0) {
        findInAncestors = true;
      }
      return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
    };
    return TestabilityRegistry;
  }());
  TestabilityRegistry.decorators = [{type: Injectable}];
  TestabilityRegistry.ctorParameters = [];
  var _NoopGetTestability = (function() {
    function _NoopGetTestability() {}
    _NoopGetTestability.prototype.addToWindow = function(registry) {};
    _NoopGetTestability.prototype.findTestabilityInTree = function(registry, elem, findInAncestors) {
      return null;
    };
    return _NoopGetTestability;
  }());
  function setTestabilityGetter(getter) {
    _testabilityGetter = getter;
  }
  var _testabilityGetter = new _NoopGetTestability();
  var SecurityContext;
  (function(SecurityContext) {
    SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
    SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
    SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
    SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
    SecurityContext[SecurityContext["URL"] = 4] = "URL";
    SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
  })(SecurityContext || (SecurityContext = {}));
  var SanitizationService = (function() {
    function SanitizationService() {}
    return SanitizationService;
  }());
  var ViewType;
  (function(ViewType) {
    ViewType[ViewType["HOST"] = 0] = "HOST";
    ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
    ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
  })(ViewType || (ViewType = {}));
  var ElementRef = (function() {
    function ElementRef(nativeElement) {
      this.nativeElement = nativeElement;
    }
    return ElementRef;
  }());
  var trace;
  var events;
  function detectWTF() {
    var wtf = global$1['wtf'];
    if (wtf) {
      trace = wtf['trace'];
      if (trace) {
        events = trace['events'];
        return true;
      }
    }
    return false;
  }
  function createScope(signature, flags) {
    if (flags === void 0) {
      flags = null;
    }
    return events.createScope(signature, flags);
  }
  function leave(scope, returnValue) {
    trace.leaveScope(scope, returnValue);
    return returnValue;
  }
  function startTimeRange(rangeType, action) {
    return trace.beginTimeRange(rangeType, action);
  }
  function endTimeRange(range) {
    trace.endTimeRange(range);
  }
  var wtfEnabled = detectWTF();
  function noopScope(arg0, arg1) {
    return null;
  }
  var wtfCreateScope = wtfEnabled ? createScope : function(signature, flags) {
    return noopScope;
  };
  var wtfLeave = wtfEnabled ? leave : function(s, r) {
    return r;
  };
  var wtfStartTimeRange = wtfEnabled ? startTimeRange : function(rangeType, action) {
    return null;
  };
  var wtfEndTimeRange = wtfEnabled ? endTimeRange : function(r) {
    return null;
  };
  var ViewContainerRef = (function() {
    function ViewContainerRef() {}
    Object.defineProperty(ViewContainerRef.prototype, "element", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef.prototype, "injector", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef.prototype, "parentInjector", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef.prototype, "length", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    return ViewContainerRef;
  }());
  var ViewContainerRef_ = (function() {
    function ViewContainerRef_(_element) {
      this._element = _element;
      this._createComponentInContainerScope = wtfCreateScope('ViewContainerRef#createComponent()');
      this._insertScope = wtfCreateScope('ViewContainerRef#insert()');
      this._removeScope = wtfCreateScope('ViewContainerRef#remove()');
      this._detachScope = wtfCreateScope('ViewContainerRef#detach()');
    }
    ViewContainerRef_.prototype.get = function(index) {
      return this._element.nestedViews[index].ref;
    };
    Object.defineProperty(ViewContainerRef_.prototype, "length", {
      get: function() {
        var views = this._element.nestedViews;
        return isPresent(views) ? views.length : 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "element", {
      get: function() {
        return this._element.elementRef;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "injector", {
      get: function() {
        return this._element.injector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
      get: function() {
        return this._element.parentInjector;
      },
      enumerable: true,
      configurable: true
    });
    ViewContainerRef_.prototype.createEmbeddedView = function(templateRef, context, index) {
      if (context === void 0) {
        context = null;
      }
      if (index === void 0) {
        index = -1;
      }
      var viewRef = templateRef.createEmbeddedView(context);
      this.insert(viewRef, index);
      return viewRef;
    };
    ViewContainerRef_.prototype.createComponent = function(componentFactory, index, injector, projectableNodes) {
      if (index === void 0) {
        index = -1;
      }
      if (injector === void 0) {
        injector = null;
      }
      if (projectableNodes === void 0) {
        projectableNodes = null;
      }
      var s = this._createComponentInContainerScope();
      var contextInjector = isPresent(injector) ? injector : this._element.parentInjector;
      var componentRef = componentFactory.create(contextInjector, projectableNodes);
      this.insert(componentRef.hostView, index);
      return wtfLeave(s, componentRef);
    };
    ViewContainerRef_.prototype.insert = function(viewRef, index) {
      if (index === void 0) {
        index = -1;
      }
      var s = this._insertScope();
      if (index == -1)
        index = this.length;
      var viewRef_ = viewRef;
      this._element.attachView(viewRef_.internalView, index);
      return wtfLeave(s, viewRef_);
    };
    ViewContainerRef_.prototype.indexOf = function(viewRef) {
      return ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);
    };
    ViewContainerRef_.prototype.remove = function(index) {
      if (index === void 0) {
        index = -1;
      }
      var s = this._removeScope();
      if (index == -1)
        index = this.length - 1;
      var view = this._element.detachView(index);
      view.destroy();
      wtfLeave(s);
    };
    ViewContainerRef_.prototype.detach = function(index) {
      if (index === void 0) {
        index = -1;
      }
      var s = this._detachScope();
      if (index == -1)
        index = this.length - 1;
      var view = this._element.detachView(index);
      return wtfLeave(s, view.ref);
    };
    ViewContainerRef_.prototype.clear = function() {
      for (var i = this.length - 1; i >= 0; i--) {
        this.remove(i);
      }
    };
    return ViewContainerRef_;
  }());
  var AppElement = (function() {
    function AppElement(index, parentIndex, parentView, nativeElement) {
      this.index = index;
      this.parentIndex = parentIndex;
      this.parentView = parentView;
      this.nativeElement = nativeElement;
      this.nestedViews = null;
      this.componentView = null;
    }
    Object.defineProperty(AppElement.prototype, "elementRef", {
      get: function() {
        return new ElementRef(this.nativeElement);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AppElement.prototype, "vcRef", {
      get: function() {
        return new ViewContainerRef_(this);
      },
      enumerable: true,
      configurable: true
    });
    AppElement.prototype.initComponent = function(component, componentConstructorViewQueries, view) {
      this.component = component;
      this.componentConstructorViewQueries = componentConstructorViewQueries;
      this.componentView = view;
    };
    Object.defineProperty(AppElement.prototype, "parentInjector", {
      get: function() {
        return this.parentView.injector(this.parentIndex);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AppElement.prototype, "injector", {
      get: function() {
        return this.parentView.injector(this.index);
      },
      enumerable: true,
      configurable: true
    });
    AppElement.prototype.mapNestedViews = function(nestedViewClass, callback) {
      var result = [];
      if (isPresent(this.nestedViews)) {
        this.nestedViews.forEach(function(nestedView) {
          if (nestedView.clazz === nestedViewClass) {
            result.push(callback(nestedView));
          }
        });
      }
      return result;
    };
    AppElement.prototype.attachView = function(view, viewIndex) {
      if (view.type === ViewType.COMPONENT) {
        throw new BaseException("Component views can't be moved!");
      }
      var nestedViews = this.nestedViews;
      if (nestedViews == null) {
        nestedViews = [];
        this.nestedViews = nestedViews;
      }
      ListWrapper.insert(nestedViews, viewIndex, view);
      var refRenderNode;
      if (viewIndex > 0) {
        var prevView = nestedViews[viewIndex - 1];
        refRenderNode = prevView.lastRootNode;
      } else {
        refRenderNode = this.nativeElement;
      }
      if (isPresent(refRenderNode)) {
        view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
      }
      view.addToContentChildren(this);
    };
    AppElement.prototype.detachView = function(viewIndex) {
      var view = ListWrapper.removeAt(this.nestedViews, viewIndex);
      if (view.type === ViewType.COMPONENT) {
        throw new BaseException("Component views can't be moved!");
      }
      view.renderer.detachView(view.flatRootNodes);
      view.removeFromContentChildren(this);
      return view;
    };
    return AppElement;
  }());
  var ExpressionChangedAfterItHasBeenCheckedException = (function(_super) {
    __extends(ExpressionChangedAfterItHasBeenCheckedException, _super);
    function ExpressionChangedAfterItHasBeenCheckedException(oldValue, currValue, context) {
      _super.call(this, "Expression has changed after it was checked. " + ("Previous value: '" + oldValue + "'. Current value: '" + currValue + "'"));
    }
    return ExpressionChangedAfterItHasBeenCheckedException;
  }(BaseException));
  var ViewWrappedException = (function(_super) {
    __extends(ViewWrappedException, _super);
    function ViewWrappedException(originalException, originalStack, context) {
      _super.call(this, "Error in " + context.source, originalException, originalStack, context);
    }
    return ViewWrappedException;
  }(WrappedException));
  var ViewDestroyedException = (function(_super) {
    __extends(ViewDestroyedException, _super);
    function ViewDestroyedException(details) {
      _super.call(this, "Attempt to use a destroyed view: " + details);
    }
    return ViewDestroyedException;
  }(BaseException));
  var IterableDiffers = (function() {
    function IterableDiffers(factories) {
      this.factories = factories;
    }
    IterableDiffers.create = function(factories, parent) {
      if (isPresent(parent)) {
        var copied = ListWrapper.clone(parent.factories);
        factories = factories.concat(copied);
        return new IterableDiffers(factories);
      } else {
        return new IterableDiffers(factories);
      }
    };
    IterableDiffers.extend = function(factories) {
      return new Provider(IterableDiffers, {
        useFactory: function(parent) {
          if (isBlank(parent)) {
            throw new BaseException('Cannot extend IterableDiffers without a parent injector');
          }
          return IterableDiffers.create(factories, parent);
        },
        deps: [[IterableDiffers, new SkipSelfMetadata(), new OptionalMetadata()]]
      });
    };
    IterableDiffers.prototype.find = function(iterable) {
      var factory = this.factories.find(function(f) {
        return f.supports(iterable);
      });
      if (isPresent(factory)) {
        return factory;
      } else {
        throw new BaseException("Cannot find a differ supporting object '" + iterable + "' of type '" + getTypeNameForDebugging(iterable) + "'");
      }
    };
    return IterableDiffers;
  }());
  var DefaultIterableDifferFactory = (function() {
    function DefaultIterableDifferFactory() {}
    DefaultIterableDifferFactory.prototype.supports = function(obj) {
      return isListLikeIterable(obj);
    };
    DefaultIterableDifferFactory.prototype.create = function(cdRef, trackByFn) {
      return new DefaultIterableDiffer(trackByFn);
    };
    return DefaultIterableDifferFactory;
  }());
  var trackByIdentity = function(index, item) {
    return item;
  };
  var DefaultIterableDiffer = (function() {
    function DefaultIterableDiffer(_trackByFn) {
      this._trackByFn = _trackByFn;
      this._length = null;
      this._collection = null;
      this._linkedRecords = null;
      this._unlinkedRecords = null;
      this._previousItHead = null;
      this._itHead = null;
      this._itTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._movesHead = null;
      this._movesTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
      this._identityChangesHead = null;
      this._identityChangesTail = null;
      this._trackByFn = isPresent(this._trackByFn) ? this._trackByFn : trackByIdentity;
    }
    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
      get: function() {
        return this._collection;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
      get: function() {
        return this._length;
      },
      enumerable: true,
      configurable: true
    });
    DefaultIterableDiffer.prototype.forEachItem = function(fn) {
      var record;
      for (record = this._itHead; record !== null; record = record._next) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachPreviousItem = function(fn) {
      var record;
      for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachAddedItem = function(fn) {
      var record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachMovedItem = function(fn) {
      var record;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachRemovedItem = function(fn) {
      var record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachIdentityChange = function(fn) {
      var record;
      for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.diff = function(collection) {
      if (isBlank(collection))
        collection = [];
      if (!isListLikeIterable(collection)) {
        throw new BaseException("Error trying to diff '" + collection + "'");
      }
      if (this.check(collection)) {
        return this;
      } else {
        return null;
      }
    };
    DefaultIterableDiffer.prototype.onDestroy = function() {};
    DefaultIterableDiffer.prototype.check = function(collection) {
      var _this = this;
      this._reset();
      var record = this._itHead;
      var mayBeDirty = false;
      var index;
      var item;
      var itemTrackBy;
      if (isArray(collection)) {
        var list = collection;
        this._length = collection.length;
        for (index = 0; index < this._length; index++) {
          item = list[index];
          itemTrackBy = this._trackByFn(index, item);
          if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
            record = this._mismatch(record, item, itemTrackBy, index);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = this._verifyReinsertion(record, item, itemTrackBy, index);
            }
            if (!looseIdentical(record.item, item))
              this._addIdentityChange(record, item);
          }
          record = record._next;
        }
      } else {
        index = 0;
        iterateListLike(collection, function(item) {
          itemTrackBy = _this._trackByFn(index, item);
          if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
            record = _this._mismatch(record, item, itemTrackBy, index);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = _this._verifyReinsertion(record, item, itemTrackBy, index);
            }
            if (!looseIdentical(record.item, item))
              _this._addIdentityChange(record, item);
          }
          record = record._next;
          index++;
        });
        this._length = index;
      }
      this._truncate(record);
      this._collection = collection;
      return this.isDirty;
    };
    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
      get: function() {
        return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
      },
      enumerable: true,
      configurable: true
    });
    DefaultIterableDiffer.prototype._reset = function() {
      if (this.isDirty) {
        var record;
        var nextRecord;
        for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          record.previousIndex = record.currentIndex;
        }
        this._additionsHead = this._additionsTail = null;
        for (record = this._movesHead; record !== null; record = nextRecord) {
          record.previousIndex = record.currentIndex;
          nextRecord = record._nextMoved;
        }
        this._movesHead = this._movesTail = null;
        this._removalsHead = this._removalsTail = null;
        this._identityChangesHead = this._identityChangesTail = null;
      }
    };
    DefaultIterableDiffer.prototype._mismatch = function(record, item, itemTrackBy, index) {
      var previousRecord;
      if (record === null) {
        previousRecord = this._itTail;
      } else {
        previousRecord = record._prev;
        this._remove(record);
      }
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
      if (record !== null) {
        if (!looseIdentical(record.item, item))
          this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index);
      } else {
        record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
        if (record !== null) {
          if (!looseIdentical(record.item, item))
            this._addIdentityChange(record, item);
          this._reinsertAfter(record, previousRecord, index);
        } else {
          record = this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
        }
      }
      return record;
    };
    DefaultIterableDiffer.prototype._verifyReinsertion = function(record, item, itemTrackBy, index) {
      var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
      if (reinsertRecord !== null) {
        record = this._reinsertAfter(reinsertRecord, record._prev, index);
      } else if (record.currentIndex != index) {
        record.currentIndex = index;
        this._addToMoves(record, index);
      }
      return record;
    };
    DefaultIterableDiffer.prototype._truncate = function(record) {
      while (record !== null) {
        var nextRecord = record._next;
        this._addToRemovals(this._unlink(record));
        record = nextRecord;
      }
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.clear();
      }
      if (this._additionsTail !== null) {
        this._additionsTail._nextAdded = null;
      }
      if (this._movesTail !== null) {
        this._movesTail._nextMoved = null;
      }
      if (this._itTail !== null) {
        this._itTail._next = null;
      }
      if (this._removalsTail !== null) {
        this._removalsTail._nextRemoved = null;
      }
      if (this._identityChangesTail !== null) {
        this._identityChangesTail._nextIdentityChange = null;
      }
    };
    DefaultIterableDiffer.prototype._reinsertAfter = function(record, prevRecord, index) {
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.remove(record);
      }
      var prev = record._prevRemoved;
      var next = record._nextRemoved;
      if (prev === null) {
        this._removalsHead = next;
      } else {
        prev._nextRemoved = next;
      }
      if (next === null) {
        this._removalsTail = prev;
      } else {
        next._prevRemoved = prev;
      }
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    };
    DefaultIterableDiffer.prototype._moveAfter = function(record, prevRecord, index) {
      this._unlink(record);
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    };
    DefaultIterableDiffer.prototype._addAfter = function(record, prevRecord, index) {
      this._insertAfter(record, prevRecord, index);
      if (this._additionsTail === null) {
        this._additionsTail = this._additionsHead = record;
      } else {
        this._additionsTail = this._additionsTail._nextAdded = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._insertAfter = function(record, prevRecord, index) {
      var next = prevRecord === null ? this._itHead : prevRecord._next;
      record._next = next;
      record._prev = prevRecord;
      if (next === null) {
        this._itTail = record;
      } else {
        next._prev = record;
      }
      if (prevRecord === null) {
        this._itHead = record;
      } else {
        prevRecord._next = record;
      }
      if (this._linkedRecords === null) {
        this._linkedRecords = new _DuplicateMap();
      }
      this._linkedRecords.put(record);
      record.currentIndex = index;
      return record;
    };
    DefaultIterableDiffer.prototype._remove = function(record) {
      return this._addToRemovals(this._unlink(record));
    };
    DefaultIterableDiffer.prototype._unlink = function(record) {
      if (this._linkedRecords !== null) {
        this._linkedRecords.remove(record);
      }
      var prev = record._prev;
      var next = record._next;
      if (prev === null) {
        this._itHead = next;
      } else {
        prev._next = next;
      }
      if (next === null) {
        this._itTail = prev;
      } else {
        next._prev = prev;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._addToMoves = function(record, toIndex) {
      if (record.previousIndex === toIndex) {
        return record;
      }
      if (this._movesTail === null) {
        this._movesTail = this._movesHead = record;
      } else {
        this._movesTail = this._movesTail._nextMoved = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._addToRemovals = function(record) {
      if (this._unlinkedRecords === null) {
        this._unlinkedRecords = new _DuplicateMap();
      }
      this._unlinkedRecords.put(record);
      record.currentIndex = null;
      record._nextRemoved = null;
      if (this._removalsTail === null) {
        this._removalsTail = this._removalsHead = record;
        record._prevRemoved = null;
      } else {
        record._prevRemoved = this._removalsTail;
        this._removalsTail = this._removalsTail._nextRemoved = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._addIdentityChange = function(record, item) {
      record.item = item;
      if (this._identityChangesTail === null) {
        this._identityChangesTail = this._identityChangesHead = record;
      } else {
        this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype.toString = function() {
      var list = [];
      this.forEachItem(function(record) {
        return list.push(record);
      });
      var previous = [];
      this.forEachPreviousItem(function(record) {
        return previous.push(record);
      });
      var additions = [];
      this.forEachAddedItem(function(record) {
        return additions.push(record);
      });
      var moves = [];
      this.forEachMovedItem(function(record) {
        return moves.push(record);
      });
      var removals = [];
      this.forEachRemovedItem(function(record) {
        return removals.push(record);
      });
      var identityChanges = [];
      this.forEachIdentityChange(function(record) {
        return identityChanges.push(record);
      });
      return "collection: " + list.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" + "additions: " + additions.join(', ') + "\n" + "moves: " + moves.join(', ') + "\n" + "removals: " + removals.join(', ') + "\n" + "identityChanges: " + identityChanges.join(', ') + "\n";
    };
    return DefaultIterableDiffer;
  }());
  var CollectionChangeRecord = (function() {
    function CollectionChangeRecord(item, trackById) {
      this.item = item;
      this.trackById = trackById;
      this.currentIndex = null;
      this.previousIndex = null;
      this._nextPrevious = null;
      this._prev = null;
      this._next = null;
      this._prevDup = null;
      this._nextDup = null;
      this._prevRemoved = null;
      this._nextRemoved = null;
      this._nextAdded = null;
      this._nextMoved = null;
      this._nextIdentityChange = null;
    }
    CollectionChangeRecord.prototype.toString = function() {
      return this.previousIndex === this.currentIndex ? stringify(this.item) : stringify(this.item) + '[' + stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
    };
    return CollectionChangeRecord;
  }());
  var _DuplicateItemRecordList = (function() {
    function _DuplicateItemRecordList() {
      this._head = null;
      this._tail = null;
    }
    _DuplicateItemRecordList.prototype.add = function(record) {
      if (this._head === null) {
        this._head = this._tail = record;
        record._nextDup = null;
        record._prevDup = null;
      } else {
        this._tail._nextDup = record;
        record._prevDup = this._tail;
        record._nextDup = null;
        this._tail = record;
      }
    };
    _DuplicateItemRecordList.prototype.get = function(trackById, afterIndex) {
      var record;
      for (record = this._head; record !== null; record = record._nextDup) {
        if ((afterIndex === null || afterIndex < record.currentIndex) && looseIdentical(record.trackById, trackById)) {
          return record;
        }
      }
      return null;
    };
    _DuplicateItemRecordList.prototype.remove = function(record) {
      var prev = record._prevDup;
      var next = record._nextDup;
      if (prev === null) {
        this._head = next;
      } else {
        prev._nextDup = next;
      }
      if (next === null) {
        this._tail = prev;
      } else {
        next._prevDup = prev;
      }
      return this._head === null;
    };
    return _DuplicateItemRecordList;
  }());
  var _DuplicateMap = (function() {
    function _DuplicateMap() {
      this.map = new Map();
    }
    _DuplicateMap.prototype.put = function(record) {
      var key = getMapKey(record.trackById);
      var duplicates = this.map.get(key);
      if (!isPresent(duplicates)) {
        duplicates = new _DuplicateItemRecordList();
        this.map.set(key, duplicates);
      }
      duplicates.add(record);
    };
    _DuplicateMap.prototype.get = function(trackById, afterIndex) {
      if (afterIndex === void 0) {
        afterIndex = null;
      }
      var key = getMapKey(trackById);
      var recordList = this.map.get(key);
      return isBlank(recordList) ? null : recordList.get(trackById, afterIndex);
    };
    _DuplicateMap.prototype.remove = function(record) {
      var key = getMapKey(record.trackById);
      var recordList = this.map.get(key);
      if (recordList.remove(record)) {
        this.map.delete(key);
      }
      return record;
    };
    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
      get: function() {
        return this.map.size === 0;
      },
      enumerable: true,
      configurable: true
    });
    _DuplicateMap.prototype.clear = function() {
      this.map.clear();
    };
    _DuplicateMap.prototype.toString = function() {
      return '_DuplicateMap(' + stringify(this.map) + ')';
    };
    return _DuplicateMap;
  }());
  var KeyValueDiffers = (function() {
    function KeyValueDiffers(factories) {
      this.factories = factories;
    }
    KeyValueDiffers.create = function(factories, parent) {
      if (isPresent(parent)) {
        var copied = ListWrapper.clone(parent.factories);
        factories = factories.concat(copied);
        return new KeyValueDiffers(factories);
      } else {
        return new KeyValueDiffers(factories);
      }
    };
    KeyValueDiffers.extend = function(factories) {
      return new Provider(KeyValueDiffers, {
        useFactory: function(parent) {
          if (isBlank(parent)) {
            throw new BaseException('Cannot extend KeyValueDiffers without a parent injector');
          }
          return KeyValueDiffers.create(factories, parent);
        },
        deps: [[KeyValueDiffers, new SkipSelfMetadata(), new OptionalMetadata()]]
      });
    };
    KeyValueDiffers.prototype.find = function(kv) {
      var factory = this.factories.find(function(f) {
        return f.supports(kv);
      });
      if (isPresent(factory)) {
        return factory;
      } else {
        throw new BaseException("Cannot find a differ supporting object '" + kv + "'");
      }
    };
    return KeyValueDiffers;
  }());
  var DefaultKeyValueDifferFactory = (function() {
    function DefaultKeyValueDifferFactory() {}
    DefaultKeyValueDifferFactory.prototype.supports = function(obj) {
      return obj instanceof Map || isJsObject(obj);
    };
    DefaultKeyValueDifferFactory.prototype.create = function(cdRef) {
      return new DefaultKeyValueDiffer();
    };
    return DefaultKeyValueDifferFactory;
  }());
  var DefaultKeyValueDiffer = (function() {
    function DefaultKeyValueDiffer() {
      this._records = new Map();
      this._mapHead = null;
      this._previousMapHead = null;
      this._changesHead = null;
      this._changesTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
    }
    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
      get: function() {
        return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
      },
      enumerable: true,
      configurable: true
    });
    DefaultKeyValueDiffer.prototype.forEachItem = function(fn) {
      var record;
      for (record = this._mapHead; record !== null; record = record._next) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function(fn) {
      var record;
      for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachChangedItem = function(fn) {
      var record;
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachAddedItem = function(fn) {
      var record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function(fn) {
      var record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.diff = function(map) {
      if (isBlank(map))
        map = MapWrapper.createFromPairs([]);
      if (!(map instanceof Map || isJsObject(map))) {
        throw new BaseException("Error trying to diff '" + map + "'");
      }
      if (this.check(map)) {
        return this;
      } else {
        return null;
      }
    };
    DefaultKeyValueDiffer.prototype.onDestroy = function() {};
    DefaultKeyValueDiffer.prototype.check = function(map) {
      var _this = this;
      this._reset();
      var records = this._records;
      var oldSeqRecord = this._mapHead;
      var lastOldSeqRecord = null;
      var lastNewSeqRecord = null;
      var seqChanged = false;
      this._forEach(map, function(value, key) {
        var newSeqRecord;
        if (oldSeqRecord !== null && key === oldSeqRecord.key) {
          newSeqRecord = oldSeqRecord;
          if (!looseIdentical(value, oldSeqRecord.currentValue)) {
            oldSeqRecord.previousValue = oldSeqRecord.currentValue;
            oldSeqRecord.currentValue = value;
            _this._addToChanges(oldSeqRecord);
          }
        } else {
          seqChanged = true;
          if (oldSeqRecord !== null) {
            oldSeqRecord._next = null;
            _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
            _this._addToRemovals(oldSeqRecord);
          }
          if (records.has(key)) {
            newSeqRecord = records.get(key);
          } else {
            newSeqRecord = new KeyValueChangeRecord(key);
            records.set(key, newSeqRecord);
            newSeqRecord.currentValue = value;
            _this._addToAdditions(newSeqRecord);
          }
        }
        if (seqChanged) {
          if (_this._isInRemovals(newSeqRecord)) {
            _this._removeFromRemovals(newSeqRecord);
          }
          if (lastNewSeqRecord == null) {
            _this._mapHead = newSeqRecord;
          } else {
            lastNewSeqRecord._next = newSeqRecord;
          }
        }
        lastOldSeqRecord = oldSeqRecord;
        lastNewSeqRecord = newSeqRecord;
        oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
      });
      this._truncate(lastOldSeqRecord, oldSeqRecord);
      return this.isDirty;
    };
    DefaultKeyValueDiffer.prototype._reset = function() {
      if (this.isDirty) {
        var record;
        for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
          record.previousValue = record.currentValue;
        }
        for (record = this._additionsHead; record != null; record = record._nextAdded) {
          record.previousValue = record.currentValue;
        }
        this._changesHead = this._changesTail = null;
        this._additionsHead = this._additionsTail = null;
        this._removalsHead = this._removalsTail = null;
      }
    };
    DefaultKeyValueDiffer.prototype._truncate = function(lastRecord, record) {
      while (record !== null) {
        if (lastRecord === null) {
          this._mapHead = null;
        } else {
          lastRecord._next = null;
        }
        var nextRecord = record._next;
        this._addToRemovals(record);
        lastRecord = record;
        record = nextRecord;
      }
      for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
        rec.previousValue = rec.currentValue;
        rec.currentValue = null;
        this._records.delete(rec.key);
      }
    };
    DefaultKeyValueDiffer.prototype._isInRemovals = function(record) {
      return record === this._removalsHead || record._nextRemoved !== null || record._prevRemoved !== null;
    };
    DefaultKeyValueDiffer.prototype._addToRemovals = function(record) {
      if (this._removalsHead === null) {
        this._removalsHead = this._removalsTail = record;
      } else {
        this._removalsTail._nextRemoved = record;
        record._prevRemoved = this._removalsTail;
        this._removalsTail = record;
      }
    };
    DefaultKeyValueDiffer.prototype._removeFromSeq = function(prev, record) {
      var next = record._next;
      if (prev === null) {
        this._mapHead = next;
      } else {
        prev._next = next;
      }
    };
    DefaultKeyValueDiffer.prototype._removeFromRemovals = function(record) {
      var prev = record._prevRemoved;
      var next = record._nextRemoved;
      if (prev === null) {
        this._removalsHead = next;
      } else {
        prev._nextRemoved = next;
      }
      if (next === null) {
        this._removalsTail = prev;
      } else {
        next._prevRemoved = prev;
      }
      record._prevRemoved = record._nextRemoved = null;
    };
    DefaultKeyValueDiffer.prototype._addToAdditions = function(record) {
      if (this._additionsHead === null) {
        this._additionsHead = this._additionsTail = record;
      } else {
        this._additionsTail._nextAdded = record;
        this._additionsTail = record;
      }
    };
    DefaultKeyValueDiffer.prototype._addToChanges = function(record) {
      if (this._changesHead === null) {
        this._changesHead = this._changesTail = record;
      } else {
        this._changesTail._nextChanged = record;
        this._changesTail = record;
      }
    };
    DefaultKeyValueDiffer.prototype.toString = function() {
      var items = [];
      var previous = [];
      var changes = [];
      var additions = [];
      var removals = [];
      var record;
      for (record = this._mapHead; record !== null; record = record._next) {
        items.push(stringify(record));
      }
      for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
        previous.push(stringify(record));
      }
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        changes.push(stringify(record));
      }
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        additions.push(stringify(record));
      }
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        removals.push(stringify(record));
      }
      return "map: " + items.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" + "additions: " + additions.join(', ') + "\n" + "changes: " + changes.join(', ') + "\n" + "removals: " + removals.join(', ') + "\n";
    };
    DefaultKeyValueDiffer.prototype._forEach = function(obj, fn) {
      if (obj instanceof Map) {
        obj.forEach(fn);
      } else {
        StringMapWrapper.forEach(obj, fn);
      }
    };
    return DefaultKeyValueDiffer;
  }());
  var KeyValueChangeRecord = (function() {
    function KeyValueChangeRecord(key) {
      this.key = key;
      this.previousValue = null;
      this.currentValue = null;
      this._nextPrevious = null;
      this._next = null;
      this._nextAdded = null;
      this._nextRemoved = null;
      this._prevRemoved = null;
      this._nextChanged = null;
    }
    KeyValueChangeRecord.prototype.toString = function() {
      return looseIdentical(this.previousValue, this.currentValue) ? stringify(this.key) : (stringify(this.key) + '[' + stringify(this.previousValue) + '->' + stringify(this.currentValue) + ']');
    };
    return KeyValueChangeRecord;
  }());
  var ChangeDetectorRef = (function() {
    function ChangeDetectorRef() {}
    return ChangeDetectorRef;
  }());
  var uninitialized = new Object();
  function devModeEqual(a, b) {
    if (isListLikeIterable(a) && isListLikeIterable(b)) {
      return areIterablesEqual(a, b, devModeEqual);
    } else if (!isListLikeIterable(a) && !isPrimitive(a) && !isListLikeIterable(b) && !isPrimitive(b)) {
      return true;
    } else {
      return looseIdentical(a, b);
    }
  }
  var WrappedValue = (function() {
    function WrappedValue(wrapped) {
      this.wrapped = wrapped;
    }
    WrappedValue.wrap = function(value) {
      return new WrappedValue(value);
    };
    return WrappedValue;
  }());
  var ValueUnwrapper = (function() {
    function ValueUnwrapper() {
      this.hasWrappedValue = false;
    }
    ValueUnwrapper.prototype.unwrap = function(value) {
      if (value instanceof WrappedValue) {
        this.hasWrappedValue = true;
        return value.wrapped;
      }
      return value;
    };
    ValueUnwrapper.prototype.reset = function() {
      this.hasWrappedValue = false;
    };
    return ValueUnwrapper;
  }());
  var SimpleChange = (function() {
    function SimpleChange(previousValue, currentValue) {
      this.previousValue = previousValue;
      this.currentValue = currentValue;
    }
    SimpleChange.prototype.isFirstChange = function() {
      return this.previousValue === uninitialized;
    };
    return SimpleChange;
  }());
  var keyValDiff = [new DefaultKeyValueDifferFactory()];
  var iterableDiff = [new DefaultIterableDifferFactory()];
  var defaultIterableDiffers = new IterableDiffers(iterableDiff);
  var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
  var RenderComponentType = (function() {
    function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles) {
      this.id = id;
      this.templateUrl = templateUrl;
      this.slotCount = slotCount;
      this.encapsulation = encapsulation;
      this.styles = styles;
    }
    return RenderComponentType;
  }());
  var RenderDebugInfo = (function() {
    function RenderDebugInfo() {}
    Object.defineProperty(RenderDebugInfo.prototype, "injector", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "component", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "providerTokens", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "references", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "context", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "source", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return RenderDebugInfo;
  }());
  var Renderer = (function() {
    function Renderer() {}
    return Renderer;
  }());
  var RootRenderer = (function() {
    function RootRenderer() {}
    return RootRenderer;
  }());
  var ViewUtils = (function() {
    function ViewUtils(_renderer, _appId, sanitizer) {
      this._renderer = _renderer;
      this._appId = _appId;
      this._nextCompTypeId = 0;
      this.sanitizer = sanitizer;
    }
    ViewUtils.prototype.createRenderComponentType = function(templateUrl, slotCount, encapsulation, styles) {
      return new RenderComponentType(this._appId + "-" + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles);
    };
    ViewUtils.prototype.renderComponent = function(renderComponentType) {
      return this._renderer.renderComponent(renderComponentType);
    };
    return ViewUtils;
  }());
  ViewUtils.decorators = [{type: Injectable}];
  ViewUtils.ctorParameters = [{type: RootRenderer}, {
    type: undefined,
    decorators: [{
      type: Inject,
      args: [APP_ID]
    }]
  }, {type: SanitizationService}];
  function flattenNestedViewRenderNodes(nodes) {
    return _flattenNestedViewRenderNodes(nodes, []);
  }
  function _flattenNestedViewRenderNodes(nodes, renderNodes) {
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (node instanceof AppElement) {
        var appEl = node;
        renderNodes.push(appEl.nativeElement);
        if (isPresent(appEl.nestedViews)) {
          for (var k = 0; k < appEl.nestedViews.length; k++) {
            _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
          }
        }
      } else {
        renderNodes.push(node);
      }
    }
    return renderNodes;
  }
  var EMPTY_ARR = [];
  function ensureSlotCount(projectableNodes, expectedSlotCount) {
    var res;
    if (isBlank(projectableNodes)) {
      res = EMPTY_ARR;
    } else if (projectableNodes.length < expectedSlotCount) {
      var givenSlotCount = projectableNodes.length;
      res = ListWrapper.createFixedSize(expectedSlotCount);
      for (var i = 0; i < expectedSlotCount; i++) {
        res[i] = (i < givenSlotCount) ? projectableNodes[i] : EMPTY_ARR;
      }
    } else {
      res = projectableNodes;
    }
    return res;
  }
  var MAX_INTERPOLATION_VALUES = 9;
  function interpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
    switch (valueCount) {
      case 1:
        return c0 + _toStringWithNull(a1) + c1;
      case 2:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
      case 3:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3;
      case 4:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4;
      case 5:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
      case 6:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
      case 7:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7;
      case 8:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
      case 9:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
      default:
        throw new BaseException("Does not support more than 9 expressions");
    }
  }
  function _toStringWithNull(v) {
    return v != null ? v.toString() : '';
  }
  function checkBinding(throwOnChange, oldValue, newValue) {
    if (throwOnChange) {
      if (!devModeEqual(oldValue, newValue)) {
        throw new ExpressionChangedAfterItHasBeenCheckedException(oldValue, newValue, null);
      }
      return false;
    } else {
      return !looseIdentical(oldValue, newValue);
    }
  }
  function castByValue(input, value) {
    return input;
  }
  var EMPTY_ARRAY = [];
  var EMPTY_MAP = {};
  function pureProxy1(fn) {
    var result;
    var v0;
    v0 = uninitialized;
    return function(p0) {
      if (!looseIdentical(v0, p0)) {
        v0 = p0;
        result = fn(p0);
      }
      return result;
    };
  }
  function pureProxy2(fn) {
    var result;
    var v0,
        v1;
    v0 = v1 = uninitialized;
    return function(p0, p1) {
      if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1)) {
        v0 = p0;
        v1 = p1;
        result = fn(p0, p1);
      }
      return result;
    };
  }
  function pureProxy3(fn) {
    var result;
    var v0,
        v1,
        v2;
    v0 = v1 = v2 = uninitialized;
    return function(p0, p1, p2) {
      if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        result = fn(p0, p1, p2);
      }
      return result;
    };
  }
  function pureProxy4(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3;
    v0 = v1 = v2 = v3 = uninitialized;
    return function(p0, p1, p2, p3) {
      if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        result = fn(p0, p1, p2, p3);
      }
      return result;
    };
  }
  function pureProxy5(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4;
    v0 = v1 = v2 = v3 = v4 = uninitialized;
    return function(p0, p1, p2, p3, p4) {
      if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        result = fn(p0, p1, p2, p3, p4);
      }
      return result;
    };
  }
  function pureProxy6(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4,
        v5;
    v0 = v1 = v2 = v3 = v4 = v5 = uninitialized;
    return function(p0, p1, p2, p3, p4, p5) {
      if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        v5 = p5;
        result = fn(p0, p1, p2, p3, p4, p5);
      }
      return result;
    };
  }
  function pureProxy7(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4,
        v5,
        v6;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = uninitialized;
    return function(p0, p1, p2, p3, p4, p5, p6) {
      if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) || !looseIdentical(v6, p6)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        v5 = p5;
        v6 = p6;
        result = fn(p0, p1, p2, p3, p4, p5, p6);
      }
      return result;
    };
  }
  function pureProxy8(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4,
        v5,
        v6,
        v7;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = uninitialized;
    return function(p0, p1, p2, p3, p4, p5, p6, p7) {
      if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) || !looseIdentical(v6, p6) || !looseIdentical(v7, p7)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        v5 = p5;
        v6 = p6;
        v7 = p7;
        result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
      }
      return result;
    };
  }
  function pureProxy9(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4,
        v5,
        v6,
        v7,
        v8;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = uninitialized;
    return function(p0, p1, p2, p3, p4, p5, p6, p7, p8) {
      if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) || !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        v5 = p5;
        v6 = p6;
        v7 = p7;
        v8 = p8;
        result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
      }
      return result;
    };
  }
  function pureProxy10(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4,
        v5,
        v6,
        v7,
        v8,
        v9;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = uninitialized;
    return function(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
      if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) || !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8) || !looseIdentical(v9, p9)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        v5 = p5;
        v6 = p6;
        v7 = p7;
        v8 = p8;
        v9 = p9;
        result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
      }
      return result;
    };
  }
  var ComponentRef = (function() {
    function ComponentRef() {}
    Object.defineProperty(ComponentRef.prototype, "location", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "injector", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "instance", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ComponentRef.prototype, "hostView", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ComponentRef.prototype, "changeDetectorRef", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "componentType", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return ComponentRef;
  }());
  var ComponentRef_ = (function(_super) {
    __extends(ComponentRef_, _super);
    function ComponentRef_(_hostElement, _componentType) {
      _super.call(this);
      this._hostElement = _hostElement;
      this._componentType = _componentType;
    }
    Object.defineProperty(ComponentRef_.prototype, "location", {
      get: function() {
        return this._hostElement.elementRef;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "injector", {
      get: function() {
        return this._hostElement.injector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "instance", {
      get: function() {
        return this._hostElement.component;
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ComponentRef_.prototype, "hostView", {
      get: function() {
        return this._hostElement.parentView.ref;
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
      get: function() {
        return this._hostElement.parentView.ref;
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ComponentRef_.prototype, "componentType", {
      get: function() {
        return this._componentType;
      },
      enumerable: true,
      configurable: true
    });
    ComponentRef_.prototype.destroy = function() {
      this._hostElement.parentView.destroy();
    };
    ComponentRef_.prototype.onDestroy = function(callback) {
      this.hostView.onDestroy(callback);
    };
    return ComponentRef_;
  }(ComponentRef));
  var EMPTY_CONTEXT = new Object();
  var ComponentFactory = (function() {
    function ComponentFactory(selector, _viewFactory, _componentType) {
      this.selector = selector;
      this._viewFactory = _viewFactory;
      this._componentType = _componentType;
    }
    Object.defineProperty(ComponentFactory.prototype, "componentType", {
      get: function() {
        return this._componentType;
      },
      enumerable: true,
      configurable: true
    });
    ComponentFactory.prototype.create = function(injector, projectableNodes, rootSelectorOrNode) {
      if (projectableNodes === void 0) {
        projectableNodes = null;
      }
      if (rootSelectorOrNode === void 0) {
        rootSelectorOrNode = null;
      }
      var vu = injector.get(ViewUtils);
      if (isBlank(projectableNodes)) {
        projectableNodes = [];
      }
      var hostView = this._viewFactory(vu, injector, null);
      var hostElement = hostView.create(EMPTY_CONTEXT, projectableNodes, rootSelectorOrNode);
      return new ComponentRef_(hostElement, this._componentType);
    };
    return ComponentFactory;
  }());
  var ComponentResolver = (function() {
    function ComponentResolver() {}
    return ComponentResolver;
  }());
  function _isComponentFactory(type) {
    return type instanceof ComponentFactory;
  }
  var ReflectorComponentResolver = (function(_super) {
    __extends(ReflectorComponentResolver, _super);
    function ReflectorComponentResolver() {
      _super.apply(this, arguments);
    }
    ReflectorComponentResolver.prototype.resolveComponent = function(componentType) {
      var metadatas = reflector.annotations(componentType);
      var componentFactory = metadatas.find(_isComponentFactory);
      if (isBlank(componentFactory)) {
        throw new BaseException("No precompiled component " + stringify(componentType) + " found");
      }
      return PromiseWrapper.resolve(componentFactory);
    };
    ReflectorComponentResolver.prototype.clearCache = function() {};
    return ReflectorComponentResolver;
  }(ComponentResolver));
  ReflectorComponentResolver.decorators = [{type: Injectable}];
  var _warnImpl = warn;
  var Console = (function() {
    function Console() {}
    Console.prototype.log = function(message) {
      print(message);
    };
    Console.prototype.warn = function(message) {
      _warnImpl(message);
    };
    return Console;
  }());
  Console.decorators = [{type: Injectable}];
  function createNgZone() {
    return new NgZone({enableLongStackTrace: assertionsEnabled()});
  }
  var _platform;
  var _inPlatformCreate = false;
  function createPlatform(injector) {
    if (_inPlatformCreate) {
      throw new BaseException('Already creating a platform...');
    }
    if (isPresent(_platform) && !_platform.disposed) {
      throw new BaseException("There can be only one platform. Destroy the previous one to create a new one.");
    }
    lockMode();
    _inPlatformCreate = true;
    try {
      _platform = injector.get(PlatformRef);
    } finally {
      _inPlatformCreate = false;
    }
    return _platform;
  }
  function assertPlatform(requiredToken) {
    var platform = getPlatform();
    if (isBlank(platform)) {
      throw new BaseException('Not platform exists!');
    }
    if (isPresent(platform) && isBlank(platform.injector.get(requiredToken, null))) {
      throw new BaseException('A platform with a different configuration has been created. Please destroy it first.');
    }
    return platform;
  }
  function disposePlatform() {
    if (isPresent(_platform) && !_platform.disposed) {
      _platform.dispose();
    }
  }
  function getPlatform() {
    return isPresent(_platform) && !_platform.disposed ? _platform : null;
  }
  function coreBootstrap(injector, componentFactory) {
    var appRef = injector.get(ApplicationRef);
    return appRef.bootstrap(componentFactory);
  }
  function coreLoadAndBootstrap(injector, componentType) {
    var appRef = injector.get(ApplicationRef);
    return appRef.run(function() {
      var componentResolver = injector.get(ComponentResolver);
      return PromiseWrapper.all([componentResolver.resolveComponent(componentType), appRef.waitForAsyncInitializers()]).then(function(arr) {
        return appRef.bootstrap(arr[0]);
      });
    });
  }
  var PlatformRef = (function() {
    function PlatformRef() {}
    Object.defineProperty(PlatformRef.prototype, "injector", {
      get: function() {
        throw unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(PlatformRef.prototype, "disposed", {
      get: function() {
        throw unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return PlatformRef;
  }());
  var PlatformRef_ = (function(_super) {
    __extends(PlatformRef_, _super);
    function PlatformRef_(_injector) {
      _super.call(this);
      this._injector = _injector;
      this._applications = [];
      this._disposeListeners = [];
      this._disposed = false;
      if (!_inPlatformCreate) {
        throw new BaseException('Platforms have to be created via `createPlatform`!');
      }
      var inits = _injector.get(PLATFORM_INITIALIZER, null);
      if (isPresent(inits))
        inits.forEach(function(init) {
          return init();
        });
    }
    PlatformRef_.prototype.registerDisposeListener = function(dispose) {
      this._disposeListeners.push(dispose);
    };
    Object.defineProperty(PlatformRef_.prototype, "injector", {
      get: function() {
        return this._injector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PlatformRef_.prototype, "disposed", {
      get: function() {
        return this._disposed;
      },
      enumerable: true,
      configurable: true
    });
    PlatformRef_.prototype.addApplication = function(appRef) {
      this._applications.push(appRef);
    };
    PlatformRef_.prototype.dispose = function() {
      ListWrapper.clone(this._applications).forEach(function(app) {
        return app.dispose();
      });
      this._disposeListeners.forEach(function(dispose) {
        return dispose();
      });
      this._disposed = true;
    };
    PlatformRef_.prototype._applicationDisposed = function(app) {
      ListWrapper.remove(this._applications, app);
    };
    return PlatformRef_;
  }(PlatformRef));
  PlatformRef_.decorators = [{type: Injectable}];
  PlatformRef_.ctorParameters = [{type: Injector}];
  var ApplicationRef = (function() {
    function ApplicationRef() {}
    Object.defineProperty(ApplicationRef.prototype, "injector", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "zone", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    return ApplicationRef;
  }());
  var ApplicationRef_ = (function(_super) {
    __extends(ApplicationRef_, _super);
    function ApplicationRef_(_platform, _zone, _injector) {
      var _this = this;
      _super.call(this);
      this._platform = _platform;
      this._zone = _zone;
      this._injector = _injector;
      this._bootstrapListeners = [];
      this._disposeListeners = [];
      this._rootComponents = [];
      this._rootComponentTypes = [];
      this._changeDetectorRefs = [];
      this._runningTick = false;
      this._enforceNoNewChanges = false;
      var zone = _injector.get(NgZone);
      this._enforceNoNewChanges = assertionsEnabled();
      zone.run(function() {
        _this._exceptionHandler = _injector.get(ExceptionHandler);
      });
      this._asyncInitDonePromise = this.run(function() {
        var inits = _injector.get(APP_INITIALIZER, null);
        var asyncInitResults = [];
        var asyncInitDonePromise;
        if (isPresent(inits)) {
          for (var i = 0; i < inits.length; i++) {
            var initResult = inits[i]();
            if (isPromise(initResult)) {
              asyncInitResults.push(initResult);
            }
          }
        }
        if (asyncInitResults.length > 0) {
          asyncInitDonePromise = PromiseWrapper.all(asyncInitResults).then(function(_) {
            return _this._asyncInitDone = true;
          });
          _this._asyncInitDone = false;
        } else {
          _this._asyncInitDone = true;
          asyncInitDonePromise = PromiseWrapper.resolve(true);
        }
        return asyncInitDonePromise;
      });
      ObservableWrapper.subscribe(zone.onError, function(error) {
        _this._exceptionHandler.call(error.error, error.stackTrace);
      });
      ObservableWrapper.subscribe(this._zone.onMicrotaskEmpty, function(_) {
        _this._zone.run(function() {
          _this.tick();
        });
      });
    }
    ApplicationRef_.prototype.registerBootstrapListener = function(listener) {
      this._bootstrapListeners.push(listener);
    };
    ApplicationRef_.prototype.registerDisposeListener = function(dispose) {
      this._disposeListeners.push(dispose);
    };
    ApplicationRef_.prototype.registerChangeDetector = function(changeDetector) {
      this._changeDetectorRefs.push(changeDetector);
    };
    ApplicationRef_.prototype.unregisterChangeDetector = function(changeDetector) {
      ListWrapper.remove(this._changeDetectorRefs, changeDetector);
    };
    ApplicationRef_.prototype.waitForAsyncInitializers = function() {
      return this._asyncInitDonePromise;
    };
    ApplicationRef_.prototype.run = function(callback) {
      var _this = this;
      var zone = this.injector.get(NgZone);
      var result;
      var completer = PromiseWrapper.completer();
      zone.run(function() {
        try {
          result = callback();
          if (isPromise(result)) {
            PromiseWrapper.then(result, function(ref) {
              completer.resolve(ref);
            }, function(err, stackTrace) {
              completer.reject(err, stackTrace);
              _this._exceptionHandler.call(err, stackTrace);
            });
          }
        } catch (e) {
          _this._exceptionHandler.call(e, e.stack);
          throw e;
        }
      });
      return isPromise(result) ? completer.promise : result;
    };
    ApplicationRef_.prototype.bootstrap = function(componentFactory) {
      var _this = this;
      if (!this._asyncInitDone) {
        throw new BaseException('Cannot bootstrap as there are still asynchronous initializers running. Wait for them using waitForAsyncInitializers().');
      }
      return this.run(function() {
        _this._rootComponentTypes.push(componentFactory.componentType);
        var compRef = componentFactory.create(_this._injector, [], componentFactory.selector);
        compRef.onDestroy(function() {
          _this._unloadComponent(compRef);
        });
        var testability = compRef.injector.get(Testability, null);
        if (isPresent(testability)) {
          compRef.injector.get(TestabilityRegistry).registerApplication(compRef.location.nativeElement, testability);
        }
        _this._loadComponent(compRef);
        var c = _this._injector.get(Console);
        if (assertionsEnabled()) {
          c.log("Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.");
        }
        return compRef;
      });
    };
    ApplicationRef_.prototype._loadComponent = function(componentRef) {
      this._changeDetectorRefs.push(componentRef.changeDetectorRef);
      this.tick();
      this._rootComponents.push(componentRef);
      this._bootstrapListeners.forEach(function(listener) {
        return listener(componentRef);
      });
    };
    ApplicationRef_.prototype._unloadComponent = function(componentRef) {
      if (!ListWrapper.contains(this._rootComponents, componentRef)) {
        return;
      }
      this.unregisterChangeDetector(componentRef.changeDetectorRef);
      ListWrapper.remove(this._rootComponents, componentRef);
    };
    Object.defineProperty(ApplicationRef_.prototype, "injector", {
      get: function() {
        return this._injector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ApplicationRef_.prototype, "zone", {
      get: function() {
        return this._zone;
      },
      enumerable: true,
      configurable: true
    });
    ApplicationRef_.prototype.tick = function() {
      if (this._runningTick) {
        throw new BaseException("ApplicationRef.tick is called recursively");
      }
      var s = ApplicationRef_._tickScope();
      try {
        this._runningTick = true;
        this._changeDetectorRefs.forEach(function(detector) {
          return detector.detectChanges();
        });
        if (this._enforceNoNewChanges) {
          this._changeDetectorRefs.forEach(function(detector) {
            return detector.checkNoChanges();
          });
        }
      } finally {
        this._runningTick = false;
        wtfLeave(s);
      }
    };
    ApplicationRef_.prototype.dispose = function() {
      ListWrapper.clone(this._rootComponents).forEach(function(ref) {
        return ref.destroy();
      });
      this._disposeListeners.forEach(function(dispose) {
        return dispose();
      });
      this._platform._applicationDisposed(this);
    };
    Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
      get: function() {
        return this._rootComponentTypes;
      },
      enumerable: true,
      configurable: true
    });
    return ApplicationRef_;
  }(ApplicationRef));
  ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
  ApplicationRef_.decorators = [{type: Injectable}];
  ApplicationRef_.ctorParameters = [{type: PlatformRef_}, {type: NgZone}, {type: Injector}];
  var PLATFORM_CORE_PROVIDERS = [PlatformRef_, ({
    provide: PlatformRef,
    useExisting: PlatformRef_
  })];
  var APPLICATION_CORE_PROVIDERS = [{
    provide: NgZone,
    useFactory: createNgZone,
    deps: []
  }, ApplicationRef_, {
    provide: ApplicationRef,
    useExisting: ApplicationRef_
  }];
  var QueryList = (function() {
    function QueryList() {
      this._dirty = true;
      this._results = [];
      this._emitter = new EventEmitter();
    }
    Object.defineProperty(QueryList.prototype, "changes", {
      get: function() {
        return this._emitter;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryList.prototype, "length", {
      get: function() {
        return this._results.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryList.prototype, "first", {
      get: function() {
        return ListWrapper.first(this._results);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryList.prototype, "last", {
      get: function() {
        return ListWrapper.last(this._results);
      },
      enumerable: true,
      configurable: true
    });
    QueryList.prototype.map = function(fn) {
      return this._results.map(fn);
    };
    QueryList.prototype.filter = function(fn) {
      return this._results.filter(fn);
    };
    QueryList.prototype.reduce = function(fn, init) {
      return this._results.reduce(fn, init);
    };
    QueryList.prototype.forEach = function(fn) {
      this._results.forEach(fn);
    };
    QueryList.prototype.toArray = function() {
      return ListWrapper.clone(this._results);
    };
    QueryList.prototype[getSymbolIterator()] = function() {
      return this._results[getSymbolIterator()]();
    };
    QueryList.prototype.toString = function() {
      return this._results.toString();
    };
    QueryList.prototype.reset = function(res) {
      this._results = ListWrapper.flatten(res);
      this._dirty = false;
    };
    QueryList.prototype.notifyOnChanges = function() {
      this._emitter.emit(this);
    };
    QueryList.prototype.setDirty = function() {
      this._dirty = true;
    };
    Object.defineProperty(QueryList.prototype, "dirty", {
      get: function() {
        return this._dirty;
      },
      enumerable: true,
      configurable: true
    });
    return QueryList;
  }());
  var DynamicComponentLoader = (function() {
    function DynamicComponentLoader() {}
    return DynamicComponentLoader;
  }());
  var DynamicComponentLoader_ = (function(_super) {
    __extends(DynamicComponentLoader_, _super);
    function DynamicComponentLoader_(_compiler) {
      _super.call(this);
      this._compiler = _compiler;
    }
    DynamicComponentLoader_.prototype.loadAsRoot = function(type, overrideSelectorOrNode, injector, onDispose, projectableNodes) {
      return this._compiler.resolveComponent(type).then(function(componentFactory) {
        var componentRef = componentFactory.create(injector, projectableNodes, isPresent(overrideSelectorOrNode) ? overrideSelectorOrNode : componentFactory.selector);
        if (isPresent(onDispose)) {
          componentRef.onDestroy(onDispose);
        }
        return componentRef;
      });
    };
    DynamicComponentLoader_.prototype.loadNextToLocation = function(type, location, providers, projectableNodes) {
      if (providers === void 0) {
        providers = null;
      }
      if (projectableNodes === void 0) {
        projectableNodes = null;
      }
      return this._compiler.resolveComponent(type).then(function(componentFactory) {
        var contextInjector = location.parentInjector;
        var childInjector = isPresent(providers) && providers.length > 0 ? ReflectiveInjector.fromResolvedProviders(providers, contextInjector) : contextInjector;
        return location.createComponent(componentFactory, location.length, childInjector, projectableNodes);
      });
    };
    return DynamicComponentLoader_;
  }(DynamicComponentLoader));
  DynamicComponentLoader_.decorators = [{type: Injectable}];
  DynamicComponentLoader_.ctorParameters = [{type: ComponentResolver}];
  var EMPTY_CONTEXT$1 = new Object();
  var TemplateRef = (function() {
    function TemplateRef() {}
    Object.defineProperty(TemplateRef.prototype, "elementRef", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return TemplateRef;
  }());
  var TemplateRef_ = (function(_super) {
    __extends(TemplateRef_, _super);
    function TemplateRef_(_appElement, _viewFactory) {
      _super.call(this);
      this._appElement = _appElement;
      this._viewFactory = _viewFactory;
    }
    TemplateRef_.prototype.createEmbeddedView = function(context) {
      var view = this._viewFactory(this._appElement.parentView.viewUtils, this._appElement.parentInjector, this._appElement);
      if (isBlank(context)) {
        context = EMPTY_CONTEXT$1;
      }
      view.create(context, null, null);
      return view.ref;
    };
    Object.defineProperty(TemplateRef_.prototype, "elementRef", {
      get: function() {
        return this._appElement.elementRef;
      },
      enumerable: true,
      configurable: true
    });
    return TemplateRef_;
  }(TemplateRef));
  var ViewRef = (function() {
    function ViewRef() {}
    Object.defineProperty(ViewRef.prototype, "destroyed", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return ViewRef;
  }());
  var EmbeddedViewRef = (function(_super) {
    __extends(EmbeddedViewRef, _super);
    function EmbeddedViewRef() {
      _super.apply(this, arguments);
    }
    Object.defineProperty(EmbeddedViewRef.prototype, "context", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EmbeddedViewRef.prototype, "rootNodes", {
      get: function() {
        return unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    return EmbeddedViewRef;
  }(ViewRef));
  var ViewRef_ = (function() {
    function ViewRef_(_view) {
      this._view = _view;
      this._view = _view;
    }
    Object.defineProperty(ViewRef_.prototype, "internalView", {
      get: function() {
        return this._view;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "rootNodes", {
      get: function() {
        return this._view.flatRootNodes;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "context", {
      get: function() {
        return this._view.context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "destroyed", {
      get: function() {
        return this._view.destroyed;
      },
      enumerable: true,
      configurable: true
    });
    ViewRef_.prototype.markForCheck = function() {
      this._view.markPathToRootAsCheckOnce();
    };
    ViewRef_.prototype.detach = function() {
      this._view.cdMode = exports.ChangeDetectionStrategy.Detached;
    };
    ViewRef_.prototype.detectChanges = function() {
      this._view.detectChanges(false);
    };
    ViewRef_.prototype.checkNoChanges = function() {
      this._view.detectChanges(true);
    };
    ViewRef_.prototype.reattach = function() {
      this._view.cdMode = exports.ChangeDetectionStrategy.CheckAlways;
      this.markForCheck();
    };
    ViewRef_.prototype.onDestroy = function(callback) {
      this._view.disposables.push(callback);
    };
    ViewRef_.prototype.destroy = function() {
      this._view.destroy();
    };
    return ViewRef_;
  }());
  var EventListener = (function() {
    function EventListener(name, callback) {
      this.name = name;
      this.callback = callback;
    }
    ;
    return EventListener;
  }());
  var DebugNode = (function() {
    function DebugNode(nativeNode, parent, _debugInfo) {
      this._debugInfo = _debugInfo;
      this.nativeNode = nativeNode;
      if (isPresent(parent) && parent instanceof DebugElement) {
        parent.addChild(this);
      } else {
        this.parent = null;
      }
      this.listeners = [];
    }
    Object.defineProperty(DebugNode.prototype, "injector", {
      get: function() {
        return isPresent(this._debugInfo) ? this._debugInfo.injector : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "componentInstance", {
      get: function() {
        return isPresent(this._debugInfo) ? this._debugInfo.component : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "context", {
      get: function() {
        return isPresent(this._debugInfo) ? this._debugInfo.context : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "references", {
      get: function() {
        return isPresent(this._debugInfo) ? this._debugInfo.references : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "providerTokens", {
      get: function() {
        return isPresent(this._debugInfo) ? this._debugInfo.providerTokens : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "source", {
      get: function() {
        return isPresent(this._debugInfo) ? this._debugInfo.source : null;
      },
      enumerable: true,
      configurable: true
    });
    DebugNode.prototype.inject = function(token) {
      return this.injector.get(token);
    };
    return DebugNode;
  }());
  var DebugElement = (function(_super) {
    __extends(DebugElement, _super);
    function DebugElement(nativeNode, parent, _debugInfo) {
      _super.call(this, nativeNode, parent, _debugInfo);
      this.properties = {};
      this.attributes = {};
      this.childNodes = [];
      this.nativeElement = nativeNode;
    }
    DebugElement.prototype.addChild = function(child) {
      if (isPresent(child)) {
        this.childNodes.push(child);
        child.parent = this;
      }
    };
    DebugElement.prototype.removeChild = function(child) {
      var childIndex = this.childNodes.indexOf(child);
      if (childIndex !== -1) {
        child.parent = null;
        this.childNodes.splice(childIndex, 1);
      }
    };
    DebugElement.prototype.insertChildrenAfter = function(child, newChildren) {
      var siblingIndex = this.childNodes.indexOf(child);
      if (siblingIndex !== -1) {
        var previousChildren = this.childNodes.slice(0, siblingIndex + 1);
        var nextChildren = this.childNodes.slice(siblingIndex + 1);
        this.childNodes = ListWrapper.concat(ListWrapper.concat(previousChildren, newChildren), nextChildren);
        for (var i = 0; i < newChildren.length; ++i) {
          var newChild = newChildren[i];
          if (isPresent(newChild.parent)) {
            newChild.parent.removeChild(newChild);
          }
          newChild.parent = this;
        }
      }
    };
    DebugElement.prototype.query = function(predicate) {
      var results = this.queryAll(predicate);
      return results.length > 0 ? results[0] : null;
    };
    DebugElement.prototype.queryAll = function(predicate) {
      var matches = [];
      _queryElementChildren(this, predicate, matches);
      return matches;
    };
    DebugElement.prototype.queryAllNodes = function(predicate) {
      var matches = [];
      _queryNodeChildren(this, predicate, matches);
      return matches;
    };
    Object.defineProperty(DebugElement.prototype, "children", {
      get: function() {
        var children = [];
        this.childNodes.forEach(function(node) {
          if (node instanceof DebugElement) {
            children.push(node);
          }
        });
        return children;
      },
      enumerable: true,
      configurable: true
    });
    DebugElement.prototype.triggerEventHandler = function(eventName, eventObj) {
      this.listeners.forEach(function(listener) {
        if (listener.name == eventName) {
          listener.callback(eventObj);
        }
      });
    };
    return DebugElement;
  }(DebugNode));
  function asNativeElements(debugEls) {
    return debugEls.map(function(el) {
      return el.nativeElement;
    });
  }
  function _queryElementChildren(element, predicate, matches) {
    element.childNodes.forEach(function(node) {
      if (node instanceof DebugElement) {
        if (predicate(node)) {
          matches.push(node);
        }
        _queryElementChildren(node, predicate, matches);
      }
    });
  }
  function _queryNodeChildren(parentNode, predicate, matches) {
    if (parentNode instanceof DebugElement) {
      parentNode.childNodes.forEach(function(node) {
        if (predicate(node)) {
          matches.push(node);
        }
        if (node instanceof DebugElement) {
          _queryNodeChildren(node, predicate, matches);
        }
      });
    }
  }
  var _nativeNodeToDebugNode = new Map();
  function getDebugNode(nativeNode) {
    return _nativeNodeToDebugNode.get(nativeNode);
  }
  function indexDebugNode(node) {
    _nativeNodeToDebugNode.set(node.nativeNode, node);
  }
  function removeDebugNodeFromIndex(node) {
    _nativeNodeToDebugNode.delete(node.nativeNode);
  }
  var PLATFORM_DIRECTIVES = new OpaqueToken("Platform Directives");
  var PLATFORM_PIPES = new OpaqueToken("Platform Pipes");
  function _reflector() {
    return reflector;
  }
  var PLATFORM_COMMON_PROVIDERS = [PLATFORM_CORE_PROVIDERS, {
    provide: Reflector,
    useFactory: _reflector,
    deps: []
  }, {
    provide: ReflectorReader,
    useExisting: Reflector
  }, TestabilityRegistry, Console];
  var APPLICATION_COMMON_PROVIDERS = [APPLICATION_CORE_PROVIDERS, {
    provide: ComponentResolver,
    useClass: ReflectorComponentResolver
  }, APP_ID_RANDOM_PROVIDER, ViewUtils, {
    provide: IterableDiffers,
    useValue: defaultIterableDiffers
  }, {
    provide: KeyValueDiffers,
    useValue: defaultKeyValueDiffers
  }, {
    provide: DynamicComponentLoader,
    useClass: DynamicComponentLoader_
  }];
  var LifecycleHooks;
  (function(LifecycleHooks) {
    LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
    LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
    LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
    LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
    LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
    LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
    LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
    LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
  })(LifecycleHooks || (LifecycleHooks = {}));
  var LIFECYCLE_HOOKS_VALUES = [LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges, LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit, LifecycleHooks.AfterViewChecked];
  var StaticNodeDebugInfo = (function() {
    function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
      this.providerTokens = providerTokens;
      this.componentToken = componentToken;
      this.refTokens = refTokens;
    }
    return StaticNodeDebugInfo;
  }());
  var DebugContext = (function() {
    function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
      this._view = _view;
      this._nodeIndex = _nodeIndex;
      this._tplRow = _tplRow;
      this._tplCol = _tplCol;
    }
    Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
      get: function() {
        return isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "context", {
      get: function() {
        return this._view.context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "component", {
      get: function() {
        var staticNodeInfo = this._staticNodeInfo;
        if (isPresent(staticNodeInfo) && isPresent(staticNodeInfo.componentToken)) {
          return this.injector.get(staticNodeInfo.componentToken);
        }
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
      get: function() {
        var componentView = this._view;
        while (isPresent(componentView.declarationAppElement) && componentView.type !== ViewType.COMPONENT) {
          componentView = componentView.declarationAppElement.parentView;
        }
        return isPresent(componentView.declarationAppElement) ? componentView.declarationAppElement.nativeElement : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "injector", {
      get: function() {
        return this._view.injector(this._nodeIndex);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "renderNode", {
      get: function() {
        if (isPresent(this._nodeIndex) && isPresent(this._view.allNodes)) {
          return this._view.allNodes[this._nodeIndex];
        } else {
          return null;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "providerTokens", {
      get: function() {
        var staticNodeInfo = this._staticNodeInfo;
        return isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "source", {
      get: function() {
        return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "references", {
      get: function() {
        var _this = this;
        var varValues = {};
        var staticNodeInfo = this._staticNodeInfo;
        if (isPresent(staticNodeInfo)) {
          var refs = staticNodeInfo.refTokens;
          StringMapWrapper.forEach(refs, function(refToken, refName) {
            var varValue;
            if (isBlank(refToken)) {
              varValue = isPresent(_this._view.allNodes) ? _this._view.allNodes[_this._nodeIndex] : null;
            } else {
              varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
            }
            varValues[refName] = varValue;
          });
        }
        return varValues;
      },
      enumerable: true,
      configurable: true
    });
    return DebugContext;
  }());
  var _UNDEFINED = new Object();
  var ElementInjector = (function(_super) {
    __extends(ElementInjector, _super);
    function ElementInjector(_view, _nodeIndex) {
      _super.call(this);
      this._view = _view;
      this._nodeIndex = _nodeIndex;
    }
    ElementInjector.prototype.get = function(token, notFoundValue) {
      if (notFoundValue === void 0) {
        notFoundValue = THROW_IF_NOT_FOUND;
      }
      var result = _UNDEFINED;
      if (result === _UNDEFINED) {
        result = this._view.injectorGet(token, this._nodeIndex, _UNDEFINED);
      }
      if (result === _UNDEFINED) {
        result = this._view.parentInjector.get(token, notFoundValue);
      }
      return result;
    };
    return ElementInjector;
  }(Injector));
  var _scope_check = wtfCreateScope("AppView#check(ascii id)");
  var AppView = (function() {
    function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {
      this.clazz = clazz;
      this.componentType = componentType;
      this.type = type;
      this.viewUtils = viewUtils;
      this.parentInjector = parentInjector;
      this.declarationAppElement = declarationAppElement;
      this.cdMode = cdMode;
      this.contentChildren = [];
      this.viewChildren = [];
      this.viewContainerElement = null;
      this.cdState = ChangeDetectorState.NeverChecked;
      this.destroyed = false;
      this.ref = new ViewRef_(this);
      if (type === ViewType.COMPONENT || type === ViewType.HOST) {
        this.renderer = viewUtils.renderComponent(componentType);
      } else {
        this.renderer = declarationAppElement.parentView.renderer;
      }
    }
    AppView.prototype.create = function(context, givenProjectableNodes, rootSelectorOrNode) {
      this.context = context;
      var projectableNodes;
      switch (this.type) {
        case ViewType.COMPONENT:
          projectableNodes = ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);
          break;
        case ViewType.EMBEDDED:
          projectableNodes = this.declarationAppElement.parentView.projectableNodes;
          break;
        case ViewType.HOST:
          projectableNodes = givenProjectableNodes;
          break;
      }
      this._hasExternalHostElement = isPresent(rootSelectorOrNode);
      this.projectableNodes = projectableNodes;
      return this.createInternal(rootSelectorOrNode);
    };
    AppView.prototype.createInternal = function(rootSelectorOrNode) {
      return null;
    };
    AppView.prototype.init = function(rootNodesOrAppElements, allNodes, disposables, subscriptions) {
      this.rootNodesOrAppElements = rootNodesOrAppElements;
      this.allNodes = allNodes;
      this.disposables = disposables;
      this.subscriptions = subscriptions;
      if (this.type === ViewType.COMPONENT) {
        this.declarationAppElement.parentView.viewChildren.push(this);
        this.dirtyParentQueriesInternal();
      }
    };
    AppView.prototype.selectOrCreateHostElement = function(elementName, rootSelectorOrNode, debugInfo) {
      var hostElement;
      if (isPresent(rootSelectorOrNode)) {
        hostElement = this.renderer.selectRootElement(rootSelectorOrNode, debugInfo);
      } else {
        hostElement = this.renderer.createElement(null, elementName, debugInfo);
      }
      return hostElement;
    };
    AppView.prototype.injectorGet = function(token, nodeIndex, notFoundResult) {
      return this.injectorGetInternal(token, nodeIndex, notFoundResult);
    };
    AppView.prototype.injectorGetInternal = function(token, nodeIndex, notFoundResult) {
      return notFoundResult;
    };
    AppView.prototype.injector = function(nodeIndex) {
      if (isPresent(nodeIndex)) {
        return new ElementInjector(this, nodeIndex);
      } else {
        return this.parentInjector;
      }
    };
    AppView.prototype.destroy = function() {
      if (this._hasExternalHostElement) {
        this.renderer.detachView(this.flatRootNodes);
      } else if (isPresent(this.viewContainerElement)) {
        this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
      }
      this._destroyRecurse();
    };
    AppView.prototype._destroyRecurse = function() {
      if (this.destroyed) {
        return;
      }
      var children = this.contentChildren;
      for (var i = 0; i < children.length; i++) {
        children[i]._destroyRecurse();
      }
      children = this.viewChildren;
      for (var i = 0; i < children.length; i++) {
        children[i]._destroyRecurse();
      }
      this.destroyLocal();
      this.destroyed = true;
    };
    AppView.prototype.destroyLocal = function() {
      var hostElement = this.type === ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;
      for (var i = 0; i < this.disposables.length; i++) {
        this.disposables[i]();
      }
      for (var i = 0; i < this.subscriptions.length; i++) {
        ObservableWrapper.dispose(this.subscriptions[i]);
      }
      this.destroyInternal();
      if (this._hasExternalHostElement) {
        this.renderer.detachView(this.flatRootNodes);
      } else if (isPresent(this.viewContainerElement)) {
        this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
      } else {
        this.dirtyParentQueriesInternal();
      }
      this.renderer.destroyView(hostElement, this.allNodes);
    };
    AppView.prototype.destroyInternal = function() {};
    Object.defineProperty(AppView.prototype, "changeDetectorRef", {
      get: function() {
        return this.ref;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AppView.prototype, "parent", {
      get: function() {
        return isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AppView.prototype, "flatRootNodes", {
      get: function() {
        return flattenNestedViewRenderNodes(this.rootNodesOrAppElements);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AppView.prototype, "lastRootNode", {
      get: function() {
        var lastNode = this.rootNodesOrAppElements.length > 0 ? this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] : null;
        return _findLastRenderNode(lastNode);
      },
      enumerable: true,
      configurable: true
    });
    AppView.prototype.dirtyParentQueriesInternal = function() {};
    AppView.prototype.detectChanges = function(throwOnChange) {
      var s = _scope_check(this.clazz);
      if (this.cdMode === exports.ChangeDetectionStrategy.Detached || this.cdMode === exports.ChangeDetectionStrategy.Checked || this.cdState === ChangeDetectorState.Errored)
        return;
      if (this.destroyed) {
        this.throwDestroyedError('detectChanges');
      }
      this.detectChangesInternal(throwOnChange);
      if (this.cdMode === exports.ChangeDetectionStrategy.CheckOnce)
        this.cdMode = exports.ChangeDetectionStrategy.Checked;
      this.cdState = ChangeDetectorState.CheckedBefore;
      wtfLeave(s);
    };
    AppView.prototype.detectChangesInternal = function(throwOnChange) {
      this.detectContentChildrenChanges(throwOnChange);
      this.detectViewChildrenChanges(throwOnChange);
    };
    AppView.prototype.detectContentChildrenChanges = function(throwOnChange) {
      for (var i = 0; i < this.contentChildren.length; ++i) {
        this.contentChildren[i].detectChanges(throwOnChange);
      }
    };
    AppView.prototype.detectViewChildrenChanges = function(throwOnChange) {
      for (var i = 0; i < this.viewChildren.length; ++i) {
        this.viewChildren[i].detectChanges(throwOnChange);
      }
    };
    AppView.prototype.addToContentChildren = function(renderAppElement) {
      renderAppElement.parentView.contentChildren.push(this);
      this.viewContainerElement = renderAppElement;
      this.dirtyParentQueriesInternal();
    };
    AppView.prototype.removeFromContentChildren = function(renderAppElement) {
      ListWrapper.remove(renderAppElement.parentView.contentChildren, this);
      this.dirtyParentQueriesInternal();
      this.viewContainerElement = null;
    };
    AppView.prototype.markAsCheckOnce = function() {
      this.cdMode = exports.ChangeDetectionStrategy.CheckOnce;
    };
    AppView.prototype.markPathToRootAsCheckOnce = function() {
      var c = this;
      while (isPresent(c) && c.cdMode !== exports.ChangeDetectionStrategy.Detached) {
        if (c.cdMode === exports.ChangeDetectionStrategy.Checked) {
          c.cdMode = exports.ChangeDetectionStrategy.CheckOnce;
        }
        var parentEl = c.type === ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;
        c = isPresent(parentEl) ? parentEl.parentView : null;
      }
    };
    AppView.prototype.eventHandler = function(cb) {
      return cb;
    };
    AppView.prototype.throwDestroyedError = function(details) {
      throw new ViewDestroyedException(details);
    };
    return AppView;
  }());
  var DebugAppView = (function(_super) {
    __extends(DebugAppView, _super);
    function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {
      _super.call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode);
      this.staticNodeDebugInfos = staticNodeDebugInfos;
      this._currentDebugContext = null;
    }
    DebugAppView.prototype.create = function(context, givenProjectableNodes, rootSelectorOrNode) {
      this._resetDebug();
      try {
        return _super.prototype.create.call(this, context, givenProjectableNodes, rootSelectorOrNode);
      } catch (e) {
        this._rethrowWithContext(e, e.stack);
        throw e;
      }
    };
    DebugAppView.prototype.injectorGet = function(token, nodeIndex, notFoundResult) {
      this._resetDebug();
      try {
        return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
      } catch (e) {
        this._rethrowWithContext(e, e.stack);
        throw e;
      }
    };
    DebugAppView.prototype.destroyLocal = function() {
      this._resetDebug();
      try {
        _super.prototype.destroyLocal.call(this);
      } catch (e) {
        this._rethrowWithContext(e, e.stack);
        throw e;
      }
    };
    DebugAppView.prototype.detectChanges = function(throwOnChange) {
      this._resetDebug();
      try {
        _super.prototype.detectChanges.call(this, throwOnChange);
      } catch (e) {
        this._rethrowWithContext(e, e.stack);
        throw e;
      }
    };
    DebugAppView.prototype._resetDebug = function() {
      this._currentDebugContext = null;
    };
    DebugAppView.prototype.debug = function(nodeIndex, rowNum, colNum) {
      return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);
    };
    DebugAppView.prototype._rethrowWithContext = function(e, stack) {
      if (!(e instanceof ViewWrappedException)) {
        if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedException)) {
          this.cdState = ChangeDetectorState.Errored;
        }
        if (isPresent(this._currentDebugContext)) {
          throw new ViewWrappedException(e, stack, this._currentDebugContext);
        }
      }
    };
    DebugAppView.prototype.eventHandler = function(cb) {
      var _this = this;
      var superHandler = _super.prototype.eventHandler.call(this, cb);
      return function(event) {
        _this._resetDebug();
        try {
          return superHandler(event);
        } catch (e) {
          _this._rethrowWithContext(e, e.stack);
          throw e;
        }
      };
    };
    return DebugAppView;
  }(AppView));
  function _findLastRenderNode(node) {
    var lastNode;
    if (node instanceof AppElement) {
      var appEl = node;
      lastNode = appEl.nativeElement;
      if (isPresent(appEl.nestedViews)) {
        for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {
          var nestedView = appEl.nestedViews[i];
          if (nestedView.rootNodesOrAppElements.length > 0) {
            lastNode = _findLastRenderNode(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);
          }
        }
      }
    } else {
      lastNode = node;
    }
    return lastNode;
  }
  function wtfInit() {}
  var DebugDomRootRenderer = (function() {
    function DebugDomRootRenderer(_delegate) {
      this._delegate = _delegate;
    }
    DebugDomRootRenderer.prototype.renderComponent = function(componentProto) {
      return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
    };
    return DebugDomRootRenderer;
  }());
  var DebugDomRenderer = (function() {
    function DebugDomRenderer(_delegate) {
      this._delegate = _delegate;
    }
    DebugDomRenderer.prototype.selectRootElement = function(selectorOrNode, debugInfo) {
      var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
      var debugEl = new DebugElement(nativeEl, null, debugInfo);
      indexDebugNode(debugEl);
      return nativeEl;
    };
    DebugDomRenderer.prototype.createElement = function(parentElement, name, debugInfo) {
      var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
      var debugEl = new DebugElement(nativeEl, getDebugNode(parentElement), debugInfo);
      debugEl.name = name;
      indexDebugNode(debugEl);
      return nativeEl;
    };
    DebugDomRenderer.prototype.createViewRoot = function(hostElement) {
      return this._delegate.createViewRoot(hostElement);
    };
    DebugDomRenderer.prototype.createTemplateAnchor = function(parentElement, debugInfo) {
      var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
      var debugEl = new DebugNode(comment, getDebugNode(parentElement), debugInfo);
      indexDebugNode(debugEl);
      return comment;
    };
    DebugDomRenderer.prototype.createText = function(parentElement, value, debugInfo) {
      var text = this._delegate.createText(parentElement, value, debugInfo);
      var debugEl = new DebugNode(text, getDebugNode(parentElement), debugInfo);
      indexDebugNode(debugEl);
      return text;
    };
    DebugDomRenderer.prototype.projectNodes = function(parentElement, nodes) {
      var debugParent = getDebugNode(parentElement);
      if (isPresent(debugParent) && debugParent instanceof DebugElement) {
        var debugElement_1 = debugParent;
        nodes.forEach(function(node) {
          debugElement_1.addChild(getDebugNode(node));
        });
      }
      this._delegate.projectNodes(parentElement, nodes);
    };
    DebugDomRenderer.prototype.attachViewAfter = function(node, viewRootNodes) {
      var debugNode = getDebugNode(node);
      if (isPresent(debugNode)) {
        var debugParent = debugNode.parent;
        if (viewRootNodes.length > 0 && isPresent(debugParent)) {
          var debugViewRootNodes = [];
          viewRootNodes.forEach(function(rootNode) {
            return debugViewRootNodes.push(getDebugNode(rootNode));
          });
          debugParent.insertChildrenAfter(debugNode, debugViewRootNodes);
        }
      }
      this._delegate.attachViewAfter(node, viewRootNodes);
    };
    DebugDomRenderer.prototype.detachView = function(viewRootNodes) {
      viewRootNodes.forEach(function(node) {
        var debugNode = getDebugNode(node);
        if (isPresent(debugNode) && isPresent(debugNode.parent)) {
          debugNode.parent.removeChild(debugNode);
        }
      });
      this._delegate.detachView(viewRootNodes);
    };
    DebugDomRenderer.prototype.destroyView = function(hostElement, viewAllNodes) {
      viewAllNodes.forEach(function(node) {
        removeDebugNodeFromIndex(getDebugNode(node));
      });
      this._delegate.destroyView(hostElement, viewAllNodes);
    };
    DebugDomRenderer.prototype.listen = function(renderElement, name, callback) {
      var debugEl = getDebugNode(renderElement);
      if (isPresent(debugEl)) {
        debugEl.listeners.push(new EventListener(name, callback));
      }
      return this._delegate.listen(renderElement, name, callback);
    };
    DebugDomRenderer.prototype.listenGlobal = function(target, name, callback) {
      return this._delegate.listenGlobal(target, name, callback);
    };
    DebugDomRenderer.prototype.setElementProperty = function(renderElement, propertyName, propertyValue) {
      var debugEl = getDebugNode(renderElement);
      if (isPresent(debugEl) && debugEl instanceof DebugElement) {
        debugEl.properties[propertyName] = propertyValue;
      }
      this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
    };
    DebugDomRenderer.prototype.setElementAttribute = function(renderElement, attributeName, attributeValue) {
      var debugEl = getDebugNode(renderElement);
      if (isPresent(debugEl) && debugEl instanceof DebugElement) {
        debugEl.attributes[attributeName] = attributeValue;
      }
      this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
    };
    DebugDomRenderer.prototype.setBindingDebugInfo = function(renderElement, propertyName, propertyValue) {
      this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
    };
    DebugDomRenderer.prototype.setElementClass = function(renderElement, className, isAdd) {
      this._delegate.setElementClass(renderElement, className, isAdd);
    };
    DebugDomRenderer.prototype.setElementStyle = function(renderElement, styleName, styleValue) {
      this._delegate.setElementStyle(renderElement, styleName, styleValue);
    };
    DebugDomRenderer.prototype.invokeElementMethod = function(renderElement, methodName, args) {
      this._delegate.invokeElementMethod(renderElement, methodName, args);
    };
    DebugDomRenderer.prototype.setText = function(renderNode, text) {
      this._delegate.setText(renderNode, text);
    };
    return DebugDomRenderer;
  }());
  var __core_private__ = {
    isDefaultChangeDetectionStrategy: isDefaultChangeDetectionStrategy,
    ChangeDetectorState: ChangeDetectorState,
    CHANGE_DETECTION_STRATEGY_VALUES: CHANGE_DETECTION_STRATEGY_VALUES,
    constructDependencies: constructDependencies,
    LifecycleHooks: LifecycleHooks,
    LIFECYCLE_HOOKS_VALUES: LIFECYCLE_HOOKS_VALUES,
    ReflectorReader: ReflectorReader,
    ReflectorComponentResolver: ReflectorComponentResolver,
    AppElement: AppElement,
    AppView: AppView,
    DebugAppView: DebugAppView,
    ViewType: ViewType,
    MAX_INTERPOLATION_VALUES: MAX_INTERPOLATION_VALUES,
    checkBinding: checkBinding,
    flattenNestedViewRenderNodes: flattenNestedViewRenderNodes,
    interpolate: interpolate,
    ViewUtils: ViewUtils,
    VIEW_ENCAPSULATION_VALUES: VIEW_ENCAPSULATION_VALUES,
    DebugContext: DebugContext,
    StaticNodeDebugInfo: StaticNodeDebugInfo,
    devModeEqual: devModeEqual,
    uninitialized: uninitialized,
    ValueUnwrapper: ValueUnwrapper,
    RenderDebugInfo: RenderDebugInfo,
    SecurityContext: SecurityContext,
    SanitizationService: SanitizationService,
    TemplateRef_: TemplateRef_,
    wtfInit: wtfInit,
    ReflectionCapabilities: ReflectionCapabilities,
    makeDecorator: makeDecorator,
    DebugDomRootRenderer: DebugDomRootRenderer,
    createProvider: createProvider,
    isProviderLiteral: isProviderLiteral,
    EMPTY_ARRAY: EMPTY_ARRAY,
    EMPTY_MAP: EMPTY_MAP,
    pureProxy1: pureProxy1,
    pureProxy2: pureProxy2,
    pureProxy3: pureProxy3,
    pureProxy4: pureProxy4,
    pureProxy5: pureProxy5,
    pureProxy6: pureProxy6,
    pureProxy7: pureProxy7,
    pureProxy8: pureProxy8,
    pureProxy9: pureProxy9,
    pureProxy10: pureProxy10,
    castByValue: castByValue,
    Console: Console
  };
  exports.createPlatform = createPlatform;
  exports.assertPlatform = assertPlatform;
  exports.disposePlatform = disposePlatform;
  exports.getPlatform = getPlatform;
  exports.coreBootstrap = coreBootstrap;
  exports.coreLoadAndBootstrap = coreLoadAndBootstrap;
  exports.createNgZone = createNgZone;
  exports.PlatformRef = PlatformRef;
  exports.ApplicationRef = ApplicationRef;
  exports.APP_ID = APP_ID;
  exports.APP_INITIALIZER = APP_INITIALIZER;
  exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;
  exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;
  exports.DebugElement = DebugElement;
  exports.DebugNode = DebugNode;
  exports.asNativeElements = asNativeElements;
  exports.getDebugNode = getDebugNode;
  exports.wtfCreateScope = wtfCreateScope;
  exports.wtfLeave = wtfLeave;
  exports.wtfStartTimeRange = wtfStartTimeRange;
  exports.wtfEndTimeRange = wtfEndTimeRange;
  exports.Type = Type;
  exports.enableProdMode = enableProdMode;
  exports.EventEmitter = EventEmitter;
  exports.ExceptionHandler = ExceptionHandler;
  exports.WrappedException = WrappedException;
  exports.BaseException = BaseException;
  exports.Component = Component;
  exports.Directive = Directive;
  exports.Attribute = Attribute;
  exports.Query = Query;
  exports.ContentChildren = ContentChildren;
  exports.ContentChild = ContentChild;
  exports.ViewChildren = ViewChildren;
  exports.ViewChild = ViewChild;
  exports.ViewQuery = ViewQuery;
  exports.Pipe = Pipe;
  exports.Input = Input;
  exports.Output = Output;
  exports.HostBinding = HostBinding;
  exports.HostListener = HostListener;
  exports.QueryMetadata = QueryMetadata;
  exports.ContentChildrenMetadata = ContentChildrenMetadata;
  exports.ContentChildMetadata = ContentChildMetadata;
  exports.ViewChildrenMetadata = ViewChildrenMetadata;
  exports.ViewQueryMetadata = ViewQueryMetadata;
  exports.ViewChildMetadata = ViewChildMetadata;
  exports.AttributeMetadata = AttributeMetadata;
  exports.ComponentMetadata = ComponentMetadata;
  exports.DirectiveMetadata = DirectiveMetadata;
  exports.PipeMetadata = PipeMetadata;
  exports.InputMetadata = InputMetadata;
  exports.OutputMetadata = OutputMetadata;
  exports.HostBindingMetadata = HostBindingMetadata;
  exports.HostListenerMetadata = HostListenerMetadata;
  exports.ViewMetadata = ViewMetadata;
  exports.Class = Class;
  exports.InjectMetadata = InjectMetadata;
  exports.OptionalMetadata = OptionalMetadata;
  exports.InjectableMetadata = InjectableMetadata;
  exports.SelfMetadata = SelfMetadata;
  exports.HostMetadata = HostMetadata;
  exports.SkipSelfMetadata = SkipSelfMetadata;
  exports.DependencyMetadata = DependencyMetadata;
  exports.forwardRef = forwardRef;
  exports.resolveForwardRef = resolveForwardRef;
  exports.Injector = Injector;
  exports.ReflectiveInjector = ReflectiveInjector;
  exports.Binding = Binding;
  exports.ProviderBuilder = ProviderBuilder;
  exports.bind = bind;
  exports.Provider = Provider;
  exports.provide = provide;
  exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
  exports.ReflectiveDependency = ReflectiveDependency;
  exports.ReflectiveKey = ReflectiveKey;
  exports.NoProviderError = NoProviderError;
  exports.AbstractProviderError = AbstractProviderError;
  exports.CyclicDependencyError = CyclicDependencyError;
  exports.InstantiationError = InstantiationError;
  exports.InvalidProviderError = InvalidProviderError;
  exports.NoAnnotationError = NoAnnotationError;
  exports.OutOfBoundsError = OutOfBoundsError;
  exports.OpaqueToken = OpaqueToken;
  exports.Inject = Inject;
  exports.Optional = Optional;
  exports.Injectable = Injectable;
  exports.Self = Self;
  exports.Host = Host;
  exports.SkipSelf = SkipSelf;
  exports.NgZone = NgZone;
  exports.NgZoneError = NgZoneError;
  exports.RootRenderer = RootRenderer;
  exports.Renderer = Renderer;
  exports.RenderComponentType = RenderComponentType;
  exports.ComponentResolver = ComponentResolver;
  exports.QueryList = QueryList;
  exports.DynamicComponentLoader = DynamicComponentLoader;
  exports.ElementRef = ElementRef;
  exports.TemplateRef = TemplateRef;
  exports.EmbeddedViewRef = EmbeddedViewRef;
  exports.ViewRef = ViewRef;
  exports.ViewContainerRef = ViewContainerRef;
  exports.ComponentRef = ComponentRef;
  exports.ComponentFactory = ComponentFactory;
  exports.ExpressionChangedAfterItHasBeenCheckedException = ExpressionChangedAfterItHasBeenCheckedException;
  exports.Testability = Testability;
  exports.TestabilityRegistry = TestabilityRegistry;
  exports.setTestabilityGetter = setTestabilityGetter;
  exports.ChangeDetectorRef = ChangeDetectorRef;
  exports.WrappedValue = WrappedValue;
  exports.SimpleChange = SimpleChange;
  exports.DefaultIterableDiffer = DefaultIterableDiffer;
  exports.IterableDiffers = IterableDiffers;
  exports.KeyValueDiffers = KeyValueDiffers;
  exports.CollectionChangeRecord = CollectionChangeRecord;
  exports.KeyValueChangeRecord = KeyValueChangeRecord;
  exports.PLATFORM_DIRECTIVES = PLATFORM_DIRECTIVES;
  exports.PLATFORM_PIPES = PLATFORM_PIPES;
  exports.PLATFORM_COMMON_PROVIDERS = PLATFORM_COMMON_PROVIDERS;
  exports.APPLICATION_COMMON_PROVIDERS = APPLICATION_COMMON_PROVIDERS;
  exports.reflector = reflector;
  exports.Reflector = Reflector;
  exports.ReflectionInfo = ReflectionInfo;
  exports.__core_private__ = __core_private__;
}));

})();
$__System.registerDynamic("28", ["27"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var root_1 = $__require('27');
  var Symbol = root_1.root.Symbol;
  if (typeof Symbol === 'function') {
    if (Symbol.observable) {
      exports.$$observable = Symbol.observable;
    } else {
      if (typeof Symbol.for === 'function') {
        exports.$$observable = Symbol.for('observable');
      } else {
        exports.$$observable = Symbol('observable');
      }
      Symbol.observable = exports.$$observable;
    }
  } else {
    exports.$$observable = '@@observable';
  }
  return module.exports;
});

$__System.registerDynamic("29", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.isArray = Array.isArray || (function(x) {
    return x && typeof x.length === 'number';
  });
  return module.exports;
});

$__System.registerDynamic("2a", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  function isObject(x) {
    return x != null && typeof x === 'object';
  }
  exports.isObject = isObject;
  return module.exports;
});

$__System.registerDynamic("2b", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  function isFunction(x) {
    return typeof x === 'function';
  }
  exports.isFunction = isFunction;
  return module.exports;
});

$__System.registerDynamic("2c", ["2d"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var errorObject_1 = $__require('2d');
  var tryCatchTarget;
  function tryCatcher() {
    try {
      return tryCatchTarget.apply(this, arguments);
    } catch (e) {
      errorObject_1.errorObject.e = e;
      return errorObject_1.errorObject;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  exports.tryCatch = tryCatch;
  ;
  return module.exports;
});

$__System.registerDynamic("2d", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.errorObject = {e: {}};
  return module.exports;
});

$__System.registerDynamic("2e", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var UnsubscriptionError = (function(_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
      _super.call(this);
      this.errors = errors;
      this.name = 'UnsubscriptionError';
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return ((i + 1) + ") " + err.toString());
      }).join('\n') : '';
    }
    return UnsubscriptionError;
  }(Error));
  exports.UnsubscriptionError = UnsubscriptionError;
  return module.exports;
});

$__System.registerDynamic("23", ["29", "2a", "2b", "2c", "2d", "2e"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isArray_1 = $__require('29');
  var isObject_1 = $__require('2a');
  var isFunction_1 = $__require('2b');
  var tryCatch_1 = $__require('2c');
  var errorObject_1 = $__require('2d');
  var UnsubscriptionError_1 = $__require('2e');
  var Subscription = (function() {
    function Subscription(unsubscribe) {
      this.isUnsubscribed = false;
      if (unsubscribe) {
        this._unsubscribe = unsubscribe;
      }
    }
    Subscription.prototype.unsubscribe = function() {
      var hasErrors = false;
      var errors;
      if (this.isUnsubscribed) {
        return;
      }
      this.isUnsubscribed = true;
      var _a = this,
          _unsubscribe = _a._unsubscribe,
          _subscriptions = _a._subscriptions;
      this._subscriptions = null;
      if (isFunction_1.isFunction(_unsubscribe)) {
        var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
        if (trial === errorObject_1.errorObject) {
          hasErrors = true;
          (errors = errors || []).push(errorObject_1.errorObject.e);
        }
      }
      if (isArray_1.isArray(_subscriptions)) {
        var index = -1;
        var len = _subscriptions.length;
        while (++index < len) {
          var sub = _subscriptions[index];
          if (isObject_1.isObject(sub)) {
            var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
            if (trial === errorObject_1.errorObject) {
              hasErrors = true;
              errors = errors || [];
              var err = errorObject_1.errorObject.e;
              if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                errors = errors.concat(err.errors);
              } else {
                errors.push(err);
              }
            }
          }
        }
      }
      if (hasErrors) {
        throw new UnsubscriptionError_1.UnsubscriptionError(errors);
      }
    };
    Subscription.prototype.add = function(teardown) {
      if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {
        return;
      }
      var sub = teardown;
      switch (typeof teardown) {
        case 'function':
          sub = new Subscription(teardown);
        case 'object':
          if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
            break;
          } else if (this.isUnsubscribed) {
            sub.unsubscribe();
          } else {
            (this._subscriptions || (this._subscriptions = [])).push(sub);
          }
          break;
        default:
          throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
      }
      return sub;
    };
    Subscription.prototype.remove = function(subscription) {
      if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
        return;
      }
      var subscriptions = this._subscriptions;
      if (subscriptions) {
        var subscriptionIndex = subscriptions.indexOf(subscription);
        if (subscriptionIndex !== -1) {
          subscriptions.splice(subscriptionIndex, 1);
        }
      }
    };
    Subscription.EMPTY = (function(empty) {
      empty.isUnsubscribed = true;
      return empty;
    }(new Subscription()));
    return Subscription;
  }());
  exports.Subscription = Subscription;
  return module.exports;
});

$__System.registerDynamic("2f", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.empty = {
    isUnsubscribed: true,
    next: function(value) {},
    error: function(err) {
      throw err;
    },
    complete: function() {}
  };
  return module.exports;
});

$__System.registerDynamic("c", ["2b", "23", "26", "2f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var isFunction_1 = $__require('2b');
  var Subscription_1 = $__require('23');
  var rxSubscriber_1 = $__require('26');
  var Observer_1 = $__require('2f');
  var Subscriber = (function(_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
      _super.call(this);
      this.syncErrorValue = null;
      this.syncErrorThrown = false;
      this.syncErrorThrowable = false;
      this.isStopped = false;
      switch (arguments.length) {
        case 0:
          this.destination = Observer_1.empty;
          break;
        case 1:
          if (!destinationOrNext) {
            this.destination = Observer_1.empty;
            break;
          }
          if (typeof destinationOrNext === 'object') {
            if (destinationOrNext instanceof Subscriber) {
              this.destination = destinationOrNext;
              this.destination.add(this);
            } else {
              this.syncErrorThrowable = true;
              this.destination = new SafeSubscriber(this, destinationOrNext);
            }
            break;
          }
        default:
          this.syncErrorThrowable = true;
          this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
          break;
      }
    }
    Subscriber.create = function(next, error, complete) {
      var subscriber = new Subscriber(next, error, complete);
      subscriber.syncErrorThrowable = false;
      return subscriber;
    };
    Subscriber.prototype.next = function(value) {
      if (!this.isStopped) {
        this._next(value);
      }
    };
    Subscriber.prototype.error = function(err) {
      if (!this.isStopped) {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber.prototype.complete = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber.prototype.unsubscribe = function() {
      if (this.isUnsubscribed) {
        return;
      }
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber.prototype._error = function(err) {
      this.destination.error(err);
      this.unsubscribe();
    };
    Subscriber.prototype._complete = function() {
      this.destination.complete();
      this.unsubscribe();
    };
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function() {
      return this;
    };
    return Subscriber;
  }(Subscription_1.Subscription));
  exports.Subscriber = Subscriber;
  var SafeSubscriber = (function(_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parent, observerOrNext, error, complete) {
      _super.call(this);
      this._parent = _parent;
      var next;
      var context = this;
      if (isFunction_1.isFunction(observerOrNext)) {
        next = observerOrNext;
      } else if (observerOrNext) {
        context = observerOrNext;
        next = observerOrNext.next;
        error = observerOrNext.error;
        complete = observerOrNext.complete;
        if (isFunction_1.isFunction(context.unsubscribe)) {
          this.add(context.unsubscribe.bind(context));
        }
        context.unsubscribe = this.unsubscribe.bind(this);
      }
      this._context = context;
      this._next = next;
      this._error = error;
      this._complete = complete;
    }
    SafeSubscriber.prototype.next = function(value) {
      if (!this.isStopped && this._next) {
        var _parent = this._parent;
        if (!_parent.syncErrorThrowable) {
          this.__tryOrUnsub(this._next, value);
        } else if (this.__tryOrSetError(_parent, this._next, value)) {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber.prototype.error = function(err) {
      if (!this.isStopped) {
        var _parent = this._parent;
        if (this._error) {
          if (!_parent.syncErrorThrowable) {
            this.__tryOrUnsub(this._error, err);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parent, this._error, err);
            this.unsubscribe();
          }
        } else if (!_parent.syncErrorThrowable) {
          this.unsubscribe();
          throw err;
        } else {
          _parent.syncErrorValue = err;
          _parent.syncErrorThrown = true;
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber.prototype.complete = function() {
      if (!this.isStopped) {
        var _parent = this._parent;
        if (this._complete) {
          if (!_parent.syncErrorThrowable) {
            this.__tryOrUnsub(this._complete);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parent, this._complete);
            this.unsubscribe();
          }
        } else {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function(fn, value) {
      try {
        fn.call(this._context, value);
      } catch (err) {
        this.unsubscribe();
        throw err;
      }
    };
    SafeSubscriber.prototype.__tryOrSetError = function(parent, fn, value) {
      try {
        fn.call(this._context, value);
      } catch (err) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      }
      return false;
    };
    SafeSubscriber.prototype._unsubscribe = function() {
      var _parent = this._parent;
      this._context = null;
      this._parent = null;
      _parent.unsubscribe();
    };
    return SafeSubscriber;
  }(Subscriber));
  return module.exports;
});

$__System.registerDynamic("27", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };
  exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    exports.root = freeGlobal;
  }
  return module.exports;
});

$__System.registerDynamic("26", ["27"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var root_1 = $__require('27');
  var Symbol = root_1.root.Symbol;
  exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ? Symbol.for('rxSubscriber') : '@@rxSubscriber';
  return module.exports;
});

$__System.registerDynamic("30", ["c", "26"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Subscriber_1 = $__require('c');
  var rxSubscriber_1 = $__require('26');
  function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver === 'object') {
      if (nextOrObserver instanceof Subscriber_1.Subscriber) {
        return nextOrObserver;
      } else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {
        return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
      }
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
  }
  exports.toSubscriber = toSubscriber;
  return module.exports;
});

$__System.registerDynamic("7", ["27", "28", "30"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var root_1 = $__require('27');
  var observable_1 = $__require('28');
  var toSubscriber_1 = $__require('30');
  var Observable = (function() {
    function Observable(subscribe) {
      this._isScalar = false;
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable.prototype.lift = function(operator) {
      var observable = new Observable();
      observable.source = this;
      observable.operator = operator;
      return observable;
    };
    Observable.prototype.subscribe = function(observerOrNext, error, complete) {
      var operator = this.operator;
      var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
      sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
      return sink;
    };
    Observable.prototype.forEach = function(next, PromiseCtor) {
      var _this = this;
      if (!PromiseCtor) {
        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
          PromiseCtor = root_1.root.Rx.config.Promise;
        } else if (root_1.root.Promise) {
          PromiseCtor = root_1.root.Promise;
        }
      }
      if (!PromiseCtor) {
        throw new Error('no Promise impl found');
      }
      return new PromiseCtor(function(resolve, reject) {
        var subscription = _this.subscribe(function(value) {
          if (subscription) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscription.unsubscribe();
            }
          } else {
            next(value);
          }
        }, reject, resolve);
      });
    };
    Observable.prototype._subscribe = function(subscriber) {
      return this.source.subscribe(subscriber);
    };
    Observable.prototype[observable_1.$$observable] = function() {
      return this;
    };
    Observable.create = function(subscribe) {
      return new Observable(subscribe);
    };
    return Observable;
  }());
  exports.Observable = Observable;
  return module.exports;
});

(function() {
var define = $__System.amdDefine;
var __extends = (this && this.__extends) || function(d, b) {
  for (var p in b)
    if (b.hasOwnProperty(p))
      d[p] = b[p];
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Observable')) : typeof define === 'function' && define.amd ? define("f", ["exports", "3", "7"], factory) : (factory((global.ng = global.ng || {}, global.ng.http = global.ng.http || {}), global.ng.core, global.Rx));
}(this, function(exports, _angular_core, rxjs_Observable) {
  'use strict';
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  var global$1 = globalScope;
  global$1.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  function isString(obj) {
    return typeof obj === "string";
  }
  function isArray(obj) {
    return Array.isArray(obj);
  }
  var StringWrapper = (function() {
    function StringWrapper() {}
    StringWrapper.fromCharCode = function(code) {
      return String.fromCharCode(code);
    };
    StringWrapper.charCodeAt = function(s, index) {
      return s.charCodeAt(index);
    };
    StringWrapper.split = function(s, regExp) {
      return s.split(regExp);
    };
    StringWrapper.equals = function(s, s2) {
      return s === s2;
    };
    StringWrapper.stripLeft = function(s, charVal) {
      if (s && s.length) {
        var pos = 0;
        for (var i = 0; i < s.length; i++) {
          if (s[i] != charVal)
            break;
          pos++;
        }
        s = s.substring(pos);
      }
      return s;
    };
    StringWrapper.stripRight = function(s, charVal) {
      if (s && s.length) {
        var pos = s.length;
        for (var i = s.length - 1; i >= 0; i--) {
          if (s[i] != charVal)
            break;
          pos--;
        }
        s = s.substring(0, pos);
      }
      return s;
    };
    StringWrapper.replace = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.slice = function(s, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function(s, from, cb) {
      return s.replace(from, function() {
        var matches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          matches[_i - 0] = arguments[_i];
        }
        matches.splice(-2, 2);
        return cb(matches);
      });
    };
    StringWrapper.contains = function(s, substr) {
      return s.indexOf(substr) != -1;
    };
    StringWrapper.compare = function(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    return StringWrapper;
  }());
  function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
  }
  var Json = (function() {
    function Json() {}
    Json.parse = function(s) {
      return global$1.JSON.parse(s);
    };
    Json.stringify = function(data) {
      return global$1.JSON.stringify(data, null, 2);
    };
    return Json;
  }());
  var _symbolIterator = null;
  function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
      if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
        _symbolIterator = Symbol.iterator;
      } else {
        var keys = Object.getOwnPropertyNames(Map.prototype);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  var Map$1 = global$1.Map;
  var Set = global$1.Set;
  var createMapFromPairs = (function() {
    try {
      if (new Map$1([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new Map$1(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new Map$1();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new Map$1(new Map$1())) {
        return function createMapFromMap(m) {
          return new Map$1(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new Map$1();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new Map$1()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new Map$1()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var MapWrapper = (function() {
    function MapWrapper() {}
    MapWrapper.clone = function(m) {
      return createMapFromMap(m);
    };
    MapWrapper.createFromStringMap = function(stringMap) {
      var result = new Map$1();
      for (var prop in stringMap) {
        result.set(prop, stringMap[prop]);
      }
      return result;
    };
    MapWrapper.toStringMap = function(m) {
      var r = {};
      m.forEach(function(v, k) {
        return r[k] = v;
      });
      return r;
    };
    MapWrapper.createFromPairs = function(pairs) {
      return createMapFromPairs(pairs);
    };
    MapWrapper.clearValues = function(m) {
      _clearValues(m);
    };
    MapWrapper.iterable = function(m) {
      return m;
    };
    MapWrapper.keys = function(m) {
      return _arrayFromMap(m, false);
    };
    MapWrapper.values = function(m) {
      return _arrayFromMap(m, true);
    };
    return MapWrapper;
  }());
  var StringMapWrapper = (function() {
    function StringMapWrapper() {}
    StringMapWrapper.create = function() {
      return {};
    };
    StringMapWrapper.contains = function(map, key) {
      return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function(map, key) {
      return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function(map, key, value) {
      map[key] = value;
    };
    StringMapWrapper.keys = function(map) {
      return Object.keys(map);
    };
    StringMapWrapper.values = function(map) {
      return Object.keys(map).reduce(function(r, a) {
        r.push(map[a]);
        return r;
      }, []);
    };
    StringMapWrapper.isEmpty = function(map) {
      for (var prop in map) {
        return false;
      }
      return true;
    };
    StringMapWrapper.delete = function(map, key) {
      delete map[key];
    };
    StringMapWrapper.forEach = function(map, callback) {
      for (var prop in map) {
        if (map.hasOwnProperty(prop)) {
          callback(map[prop], prop);
        }
      }
    };
    StringMapWrapper.merge = function(m1, m2) {
      var m = {};
      for (var attr in m1) {
        if (m1.hasOwnProperty(attr)) {
          m[attr] = m1[attr];
        }
      }
      for (var attr in m2) {
        if (m2.hasOwnProperty(attr)) {
          m[attr] = m2[attr];
        }
      }
      return m;
    };
    StringMapWrapper.equals = function(m1, m2) {
      var k1 = Object.keys(m1);
      var k2 = Object.keys(m2);
      if (k1.length != k2.length) {
        return false;
      }
      var key;
      for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (m1[key] !== m2[key]) {
          return false;
        }
      }
      return true;
    };
    return StringMapWrapper;
  }());
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  function _flattenArray(source, target) {
    if (isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  function isListLikeIterable(obj) {
    if (!isJsObject(obj))
      return false;
    return isArray(obj) || (!(obj instanceof Map$1) && getSymbolIterator() in obj);
  }
  function iterateListLike(obj, fn) {
    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[getSymbolIterator()]();
      var item;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  var createSetFromList = (function() {
    var test = new Set([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new Set(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new Set(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var BaseException = (function(_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
      if (message === void 0) {
        message = "--";
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function() {
      return this.message;
    };
    return BaseException;
  }(Error));
  function makeTypeError(message) {
    return new TypeError(message);
  }
  var ConnectionBackend = (function() {
    function ConnectionBackend() {}
    return ConnectionBackend;
  }());
  var Connection = (function() {
    function Connection() {}
    return Connection;
  }());
  var Headers = (function() {
    function Headers(headers) {
      var _this = this;
      if (headers instanceof Headers) {
        this._headersMap = headers._headersMap;
        return;
      }
      this._headersMap = new Map$1();
      if (isBlank(headers)) {
        return;
      }
      StringMapWrapper.forEach(headers, function(v, k) {
        _this._headersMap.set(k, isListLikeIterable(v) ? v : [v]);
      });
    }
    Headers.fromResponseHeaderString = function(headersString) {
      return headersString.trim().split('\n').map(function(val) {
        return val.split(':');
      }).map(function(_a) {
        var key = _a[0],
            parts = _a.slice(1);
        return ([key.trim(), parts.join(':').trim()]);
      }).reduce(function(headers, _a) {
        var key = _a[0],
            value = _a[1];
        return !headers.set(key, value) && headers;
      }, new Headers());
    };
    Headers.prototype.append = function(name, value) {
      var mapName = this._headersMap.get(name);
      var list = isListLikeIterable(mapName) ? mapName : [];
      list.push(value);
      this._headersMap.set(name, list);
    };
    Headers.prototype.delete = function(name) {
      this._headersMap.delete(name);
    };
    Headers.prototype.forEach = function(fn) {
      this._headersMap.forEach(fn);
    };
    Headers.prototype.get = function(header) {
      return ListWrapper.first(this._headersMap.get(header));
    };
    Headers.prototype.has = function(header) {
      return this._headersMap.has(header);
    };
    Headers.prototype.keys = function() {
      return MapWrapper.keys(this._headersMap);
    };
    Headers.prototype.set = function(header, value) {
      var list = [];
      if (isListLikeIterable(value)) {
        var pushValue = value.join(',');
        list.push(pushValue);
      } else {
        list.push(value);
      }
      this._headersMap.set(header, list);
    };
    Headers.prototype.values = function() {
      return MapWrapper.values(this._headersMap);
    };
    Headers.prototype.toJSON = function() {
      var serializableHeaders = {};
      this._headersMap.forEach(function(values, name) {
        var list = [];
        iterateListLike(values, function(val) {
          return list = ListWrapper.concat(list, val.split(','));
        });
        serializableHeaders[name] = list;
      });
      return serializableHeaders;
    };
    Headers.prototype.getAll = function(header) {
      var headers = this._headersMap.get(header);
      return isListLikeIterable(headers) ? headers : [];
    };
    Headers.prototype.entries = function() {
      throw new BaseException('"entries" method is not implemented on Headers class');
    };
    return Headers;
  }());
  exports.RequestMethod;
  (function(RequestMethod) {
    RequestMethod[RequestMethod["Get"] = 0] = "Get";
    RequestMethod[RequestMethod["Post"] = 1] = "Post";
    RequestMethod[RequestMethod["Put"] = 2] = "Put";
    RequestMethod[RequestMethod["Delete"] = 3] = "Delete";
    RequestMethod[RequestMethod["Options"] = 4] = "Options";
    RequestMethod[RequestMethod["Head"] = 5] = "Head";
    RequestMethod[RequestMethod["Patch"] = 6] = "Patch";
  })(exports.RequestMethod || (exports.RequestMethod = {}));
  exports.ReadyState;
  (function(ReadyState) {
    ReadyState[ReadyState["Unsent"] = 0] = "Unsent";
    ReadyState[ReadyState["Open"] = 1] = "Open";
    ReadyState[ReadyState["HeadersReceived"] = 2] = "HeadersReceived";
    ReadyState[ReadyState["Loading"] = 3] = "Loading";
    ReadyState[ReadyState["Done"] = 4] = "Done";
    ReadyState[ReadyState["Cancelled"] = 5] = "Cancelled";
  })(exports.ReadyState || (exports.ReadyState = {}));
  exports.ResponseType;
  (function(ResponseType) {
    ResponseType[ResponseType["Basic"] = 0] = "Basic";
    ResponseType[ResponseType["Cors"] = 1] = "Cors";
    ResponseType[ResponseType["Default"] = 2] = "Default";
    ResponseType[ResponseType["Error"] = 3] = "Error";
    ResponseType[ResponseType["Opaque"] = 4] = "Opaque";
  })(exports.ResponseType || (exports.ResponseType = {}));
  function normalizeMethodName(method) {
    if (isString(method)) {
      var originalMethod = method;
      method = method.replace(/(\w)(\w*)/g, function(g0, g1, g2) {
        return g1.toUpperCase() + g2.toLowerCase();
      });
      method = exports.RequestMethod[method];
      if (typeof method !== 'number')
        throw makeTypeError("Invalid request method. The method \"" + originalMethod + "\" is not supported.");
    }
    return method;
  }
  var isSuccess = function(status) {
    return (status >= 200 && status < 300);
  };
  function getResponseURL(xhr) {
    if ('responseURL' in xhr) {
      return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
      return xhr.getResponseHeader('X-Request-URL');
    }
    return;
  }
  var Request = (function() {
    function Request(requestOptions) {
      var url = requestOptions.url;
      this.url = requestOptions.url;
      if (isPresent(requestOptions.search)) {
        var search = requestOptions.search.toString();
        if (search.length > 0) {
          var prefix = '?';
          if (StringWrapper.contains(this.url, '?')) {
            prefix = (this.url[this.url.length - 1] == '&') ? '' : '&';
          }
          this.url = url + prefix + search;
        }
      }
      this._body = requestOptions.body;
      this.method = normalizeMethodName(requestOptions.method);
      this.headers = new Headers(requestOptions.headers);
    }
    Request.prototype.text = function() {
      return isPresent(this._body) ? this._body.toString() : '';
    };
    return Request;
  }());
  function paramParser(rawParams) {
    if (rawParams === void 0) {
      rawParams = '';
    }
    var map = new Map$1();
    if (rawParams.length > 0) {
      var params = rawParams.split('&');
      params.forEach(function(param) {
        var split = param.split('=');
        var key = split[0];
        var val = split[1];
        var list = isPresent(map.get(key)) ? map.get(key) : [];
        list.push(val);
        map.set(key, list);
      });
    }
    return map;
  }
  var URLSearchParams = (function() {
    function URLSearchParams(rawParams) {
      if (rawParams === void 0) {
        rawParams = '';
      }
      this.rawParams = rawParams;
      this.paramsMap = paramParser(rawParams);
    }
    URLSearchParams.prototype.clone = function() {
      var clone = new URLSearchParams();
      clone.appendAll(this);
      return clone;
    };
    URLSearchParams.prototype.has = function(param) {
      return this.paramsMap.has(param);
    };
    URLSearchParams.prototype.get = function(param) {
      var storedParam = this.paramsMap.get(param);
      if (isListLikeIterable(storedParam)) {
        return ListWrapper.first(storedParam);
      } else {
        return null;
      }
    };
    URLSearchParams.prototype.getAll = function(param) {
      var mapParam = this.paramsMap.get(param);
      return isPresent(mapParam) ? mapParam : [];
    };
    URLSearchParams.prototype.set = function(param, val) {
      var mapParam = this.paramsMap.get(param);
      var list = isPresent(mapParam) ? mapParam : [];
      ListWrapper.clear(list);
      list.push(val);
      this.paramsMap.set(param, list);
    };
    URLSearchParams.prototype.setAll = function(searchParams) {
      var _this = this;
      searchParams.paramsMap.forEach(function(value, param) {
        var mapParam = _this.paramsMap.get(param);
        var list = isPresent(mapParam) ? mapParam : [];
        ListWrapper.clear(list);
        list.push(value[0]);
        _this.paramsMap.set(param, list);
      });
    };
    URLSearchParams.prototype.append = function(param, val) {
      var mapParam = this.paramsMap.get(param);
      var list = isPresent(mapParam) ? mapParam : [];
      list.push(val);
      this.paramsMap.set(param, list);
    };
    URLSearchParams.prototype.appendAll = function(searchParams) {
      var _this = this;
      searchParams.paramsMap.forEach(function(value, param) {
        var mapParam = _this.paramsMap.get(param);
        var list = isPresent(mapParam) ? mapParam : [];
        for (var i = 0; i < value.length; ++i) {
          list.push(value[i]);
        }
        _this.paramsMap.set(param, list);
      });
    };
    URLSearchParams.prototype.replaceAll = function(searchParams) {
      var _this = this;
      searchParams.paramsMap.forEach(function(value, param) {
        var mapParam = _this.paramsMap.get(param);
        var list = isPresent(mapParam) ? mapParam : [];
        ListWrapper.clear(list);
        for (var i = 0; i < value.length; ++i) {
          list.push(value[i]);
        }
        _this.paramsMap.set(param, list);
      });
    };
    URLSearchParams.prototype.toString = function() {
      var paramsList = [];
      this.paramsMap.forEach(function(values, k) {
        values.forEach(function(v) {
          return paramsList.push(k + '=' + v);
        });
      });
      return paramsList.join('&');
    };
    URLSearchParams.prototype.delete = function(param) {
      this.paramsMap.delete(param);
    };
    return URLSearchParams;
  }());
  var RequestOptions = (function() {
    function RequestOptions(_a) {
      var _b = _a === void 0 ? {} : _a,
          method = _b.method,
          headers = _b.headers,
          body = _b.body,
          url = _b.url,
          search = _b.search;
      this.method = isPresent(method) ? normalizeMethodName(method) : null;
      this.headers = isPresent(headers) ? headers : null;
      this.body = isPresent(body) ? body : null;
      this.url = isPresent(url) ? url : null;
      this.search = isPresent(search) ? (isString(search) ? new URLSearchParams((search)) : (search)) : null;
    }
    RequestOptions.prototype.merge = function(options) {
      return new RequestOptions({
        method: isPresent(options) && isPresent(options.method) ? options.method : this.method,
        headers: isPresent(options) && isPresent(options.headers) ? options.headers : this.headers,
        body: isPresent(options) && isPresent(options.body) ? options.body : this.body,
        url: isPresent(options) && isPresent(options.url) ? options.url : this.url,
        search: isPresent(options) && isPresent(options.search) ? (isString(options.search) ? new URLSearchParams((options.search)) : (options.search).clone()) : this.search
      });
    };
    return RequestOptions;
  }());
  var BaseRequestOptions = (function(_super) {
    __extends(BaseRequestOptions, _super);
    function BaseRequestOptions() {
      _super.call(this, {
        method: exports.RequestMethod.Get,
        headers: new Headers()
      });
    }
    return BaseRequestOptions;
  }(RequestOptions));
  BaseRequestOptions.decorators = [{type: _angular_core.Injectable}];
  BaseRequestOptions.ctorParameters = [];
  function httpRequest(backend, request) {
    return backend.createConnection(request).response;
  }
  function mergeOptions(defaultOpts, providedOpts, method, url) {
    var newOptions = defaultOpts;
    if (isPresent(providedOpts)) {
      return newOptions.merge(new RequestOptions({
        method: providedOpts.method || method,
        url: providedOpts.url || url,
        search: providedOpts.search,
        headers: providedOpts.headers,
        body: providedOpts.body
      }));
    }
    if (isPresent(method)) {
      return newOptions.merge(new RequestOptions({
        method: method,
        url: url
      }));
    } else {
      return newOptions.merge(new RequestOptions({url: url}));
    }
  }
  var Http = (function() {
    function Http(_backend, _defaultOptions) {
      this._backend = _backend;
      this._defaultOptions = _defaultOptions;
    }
    Http.prototype.request = function(url, options) {
      var responseObservable;
      if (isString(url)) {
        responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Get, url)));
      } else if (url instanceof Request) {
        responseObservable = httpRequest(this._backend, url);
      } else {
        throw makeTypeError('First argument must be a url string or Request instance.');
      }
      return responseObservable;
    };
    Http.prototype.get = function(url, options) {
      return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Get, url)));
    };
    Http.prototype.post = function(url, body, options) {
      return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({body: body})), options, exports.RequestMethod.Post, url)));
    };
    Http.prototype.put = function(url, body, options) {
      return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({body: body})), options, exports.RequestMethod.Put, url)));
    };
    Http.prototype.delete = function(url, options) {
      return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Delete, url)));
    };
    Http.prototype.patch = function(url, body, options) {
      return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({body: body})), options, exports.RequestMethod.Patch, url)));
    };
    Http.prototype.head = function(url, options) {
      return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Head, url)));
    };
    return Http;
  }());
  Http.decorators = [{type: _angular_core.Injectable}];
  Http.ctorParameters = [{type: ConnectionBackend}, {type: RequestOptions}];
  var Jsonp = (function(_super) {
    __extends(Jsonp, _super);
    function Jsonp(backend, defaultOptions) {
      _super.call(this, backend, defaultOptions);
    }
    Jsonp.prototype.request = function(url, options) {
      var responseObservable;
      if (isString(url)) {
        url = new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Get, url));
      }
      if (url instanceof Request) {
        if (url.method !== exports.RequestMethod.Get) {
          makeTypeError('JSONP requests must use GET request method.');
        }
        responseObservable = httpRequest(this._backend, url);
      } else {
        throw makeTypeError('First argument must be a url string or Request instance.');
      }
      return responseObservable;
    };
    return Jsonp;
  }(Http));
  Jsonp.decorators = [{type: _angular_core.Injectable}];
  Jsonp.ctorParameters = [{type: ConnectionBackend}, {type: RequestOptions}];
  var Response = (function() {
    function Response(responseOptions) {
      this._body = responseOptions.body;
      this.status = responseOptions.status;
      this.ok = (this.status >= 200 && this.status <= 299);
      this.statusText = responseOptions.statusText;
      this.headers = responseOptions.headers;
      this.type = responseOptions.type;
      this.url = responseOptions.url;
    }
    Response.prototype.blob = function() {
      throw new BaseException('"blob()" method not implemented on Response superclass');
    };
    Response.prototype.json = function() {
      var jsonResponse;
      if (isJsObject(this._body)) {
        jsonResponse = this._body;
      } else if (isString(this._body)) {
        jsonResponse = Json.parse(this._body);
      }
      return jsonResponse;
    };
    Response.prototype.text = function() {
      return this._body.toString();
    };
    Response.prototype.arrayBuffer = function() {
      throw new BaseException('"arrayBuffer()" method not implemented on Response superclass');
    };
    return Response;
  }());
  var ResponseOptions = (function() {
    function ResponseOptions(_a) {
      var _b = _a === void 0 ? {} : _a,
          body = _b.body,
          status = _b.status,
          headers = _b.headers,
          statusText = _b.statusText,
          type = _b.type,
          url = _b.url;
      this.body = isPresent(body) ? body : null;
      this.status = isPresent(status) ? status : null;
      this.headers = isPresent(headers) ? headers : null;
      this.statusText = isPresent(statusText) ? statusText : null;
      this.type = isPresent(type) ? type : null;
      this.url = isPresent(url) ? url : null;
    }
    ResponseOptions.prototype.merge = function(options) {
      return new ResponseOptions({
        body: isPresent(options) && isPresent(options.body) ? options.body : this.body,
        status: isPresent(options) && isPresent(options.status) ? options.status : this.status,
        headers: isPresent(options) && isPresent(options.headers) ? options.headers : this.headers,
        statusText: isPresent(options) && isPresent(options.statusText) ? options.statusText : this.statusText,
        type: isPresent(options) && isPresent(options.type) ? options.type : this.type,
        url: isPresent(options) && isPresent(options.url) ? options.url : this.url
      });
    };
    return ResponseOptions;
  }());
  var BaseResponseOptions = (function(_super) {
    __extends(BaseResponseOptions, _super);
    function BaseResponseOptions() {
      _super.call(this, {
        status: 200,
        statusText: 'Ok',
        type: exports.ResponseType.Default,
        headers: new Headers()
      });
    }
    return BaseResponseOptions;
  }(ResponseOptions));
  BaseResponseOptions.decorators = [{type: _angular_core.Injectable}];
  BaseResponseOptions.ctorParameters = [];
  var BrowserXhr = (function() {
    function BrowserXhr() {}
    BrowserXhr.prototype.build = function() {
      return (new XMLHttpRequest());
    };
    return BrowserXhr;
  }());
  BrowserXhr.decorators = [{type: _angular_core.Injectable}];
  BrowserXhr.ctorParameters = [];
  var XHRConnection = (function() {
    function XHRConnection(req, browserXHR, baseResponseOptions) {
      var _this = this;
      this.request = req;
      this.response = new rxjs_Observable.Observable(function(responseObserver) {
        var _xhr = browserXHR.build();
        _xhr.open(exports.RequestMethod[req.method].toUpperCase(), req.url);
        var onLoad = function() {
          var body = isPresent(_xhr.response) ? _xhr.response : _xhr.responseText;
          var headers = Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());
          var url = getResponseURL(_xhr);
          var status = _xhr.status === 1223 ? 204 : _xhr.status;
          if (status === 0) {
            status = body ? 200 : 0;
          }
          var responseOptions = new ResponseOptions({
            body: body,
            status: status,
            headers: headers,
            url: url
          });
          if (isPresent(baseResponseOptions)) {
            responseOptions = baseResponseOptions.merge(responseOptions);
          }
          var response = new Response(responseOptions);
          if (isSuccess(status)) {
            responseObserver.next(response);
            responseObserver.complete();
            return;
          }
          responseObserver.error(response);
        };
        var onError = function(err) {
          var responseOptions = new ResponseOptions({
            body: err,
            type: exports.ResponseType.Error
          });
          if (isPresent(baseResponseOptions)) {
            responseOptions = baseResponseOptions.merge(responseOptions);
          }
          responseObserver.error(new Response(responseOptions));
        };
        if (isPresent(req.headers)) {
          req.headers.forEach(function(values, name) {
            return _xhr.setRequestHeader(name, values.join(','));
          });
        }
        _xhr.addEventListener('load', onLoad);
        _xhr.addEventListener('error', onError);
        _xhr.send(_this.request.text());
        return function() {
          _xhr.removeEventListener('load', onLoad);
          _xhr.removeEventListener('error', onError);
          _xhr.abort();
        };
      });
    }
    return XHRConnection;
  }());
  var XHRBackend = (function() {
    function XHRBackend(_browserXHR, _baseResponseOptions) {
      this._browserXHR = _browserXHR;
      this._baseResponseOptions = _baseResponseOptions;
    }
    XHRBackend.prototype.createConnection = function(request) {
      return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);
    };
    return XHRBackend;
  }());
  XHRBackend.decorators = [{type: _angular_core.Injectable}];
  XHRBackend.ctorParameters = [{type: BrowserXhr}, {type: ResponseOptions}];
  var _nextRequestId = 0;
  var JSONP_HOME = '__ng_jsonp__';
  var _jsonpConnections = null;
  function _getJsonpConnections() {
    if (_jsonpConnections === null) {
      _jsonpConnections = global$1[JSONP_HOME] = {};
    }
    return _jsonpConnections;
  }
  var BrowserJsonp = (function() {
    function BrowserJsonp() {}
    BrowserJsonp.prototype.build = function(url) {
      var node = document.createElement('script');
      node.src = url;
      return node;
    };
    BrowserJsonp.prototype.nextRequestID = function() {
      return "__req" + _nextRequestId++;
    };
    BrowserJsonp.prototype.requestCallback = function(id) {
      return JSONP_HOME + "." + id + ".finished";
    };
    BrowserJsonp.prototype.exposeConnection = function(id, connection) {
      var connections = _getJsonpConnections();
      connections[id] = connection;
    };
    BrowserJsonp.prototype.removeConnection = function(id) {
      var connections = _getJsonpConnections();
      connections[id] = null;
    };
    BrowserJsonp.prototype.send = function(node) {
      document.body.appendChild((node));
    };
    BrowserJsonp.prototype.cleanup = function(node) {
      if (node.parentNode) {
        node.parentNode.removeChild((node));
      }
    };
    return BrowserJsonp;
  }());
  BrowserJsonp.decorators = [{type: _angular_core.Injectable}];
  var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
  var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';
  var JSONPConnection = (function() {
    function JSONPConnection() {}
    return JSONPConnection;
  }());
  var JSONPConnection_ = (function(_super) {
    __extends(JSONPConnection_, _super);
    function JSONPConnection_(req, _dom, baseResponseOptions) {
      var _this = this;
      _super.call(this);
      this._dom = _dom;
      this.baseResponseOptions = baseResponseOptions;
      this._finished = false;
      if (req.method !== exports.RequestMethod.Get) {
        throw makeTypeError(JSONP_ERR_WRONG_METHOD);
      }
      this.request = req;
      this.response = new rxjs_Observable.Observable(function(responseObserver) {
        _this.readyState = exports.ReadyState.Loading;
        var id = _this._id = _dom.nextRequestID();
        _dom.exposeConnection(id, _this);
        var callback = _dom.requestCallback(_this._id);
        var url = req.url;
        if (url.indexOf('=JSONP_CALLBACK&') > -1) {
          url = StringWrapper.replace(url, '=JSONP_CALLBACK&', "=" + callback + "&");
        } else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {
          url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + ("=" + callback);
        }
        var script = _this._script = _dom.build(url);
        var onLoad = function(event) {
          if (_this.readyState === exports.ReadyState.Cancelled)
            return;
          _this.readyState = exports.ReadyState.Done;
          _dom.cleanup(script);
          if (!_this._finished) {
            var responseOptions_1 = new ResponseOptions({
              body: JSONP_ERR_NO_CALLBACK,
              type: exports.ResponseType.Error,
              url: url
            });
            if (isPresent(baseResponseOptions)) {
              responseOptions_1 = baseResponseOptions.merge(responseOptions_1);
            }
            responseObserver.error(new Response(responseOptions_1));
            return;
          }
          var responseOptions = new ResponseOptions({
            body: _this._responseData,
            url: url
          });
          if (isPresent(_this.baseResponseOptions)) {
            responseOptions = _this.baseResponseOptions.merge(responseOptions);
          }
          responseObserver.next(new Response(responseOptions));
          responseObserver.complete();
        };
        var onError = function(error) {
          if (_this.readyState === exports.ReadyState.Cancelled)
            return;
          _this.readyState = exports.ReadyState.Done;
          _dom.cleanup(script);
          var responseOptions = new ResponseOptions({
            body: error.message,
            type: exports.ResponseType.Error
          });
          if (isPresent(baseResponseOptions)) {
            responseOptions = baseResponseOptions.merge(responseOptions);
          }
          responseObserver.error(new Response(responseOptions));
        };
        script.addEventListener('load', onLoad);
        script.addEventListener('error', onError);
        _dom.send(script);
        return function() {
          _this.readyState = exports.ReadyState.Cancelled;
          script.removeEventListener('load', onLoad);
          script.removeEventListener('error', onError);
          if (isPresent(script)) {
            _this._dom.cleanup(script);
          }
        };
      });
    }
    JSONPConnection_.prototype.finished = function(data) {
      this._finished = true;
      this._dom.removeConnection(this._id);
      if (this.readyState === exports.ReadyState.Cancelled)
        return;
      this._responseData = data;
    };
    return JSONPConnection_;
  }(JSONPConnection));
  var JSONPBackend = (function(_super) {
    __extends(JSONPBackend, _super);
    function JSONPBackend() {
      _super.apply(this, arguments);
    }
    return JSONPBackend;
  }(ConnectionBackend));
  var JSONPBackend_ = (function(_super) {
    __extends(JSONPBackend_, _super);
    function JSONPBackend_(_browserJSONP, _baseResponseOptions) {
      _super.call(this);
      this._browserJSONP = _browserJSONP;
      this._baseResponseOptions = _baseResponseOptions;
    }
    JSONPBackend_.prototype.createConnection = function(request) {
      return new JSONPConnection_(request, this._browserJSONP, this._baseResponseOptions);
    };
    return JSONPBackend_;
  }(JSONPBackend));
  JSONPBackend_.decorators = [{type: _angular_core.Injectable}];
  JSONPBackend_.ctorParameters = [{type: BrowserJsonp}, {type: ResponseOptions}];
  var HTTP_PROVIDERS = [_angular_core.provide(Http, {
    useFactory: function(xhrBackend, requestOptions) {
      return new Http(xhrBackend, requestOptions);
    },
    deps: [XHRBackend, RequestOptions]
  }), BrowserXhr, _angular_core.provide(RequestOptions, {useClass: BaseRequestOptions}), _angular_core.provide(ResponseOptions, {useClass: BaseResponseOptions}), XHRBackend];
  var HTTP_BINDINGS = HTTP_PROVIDERS;
  var JSONP_PROVIDERS = [_angular_core.provide(Jsonp, {
    useFactory: function(jsonpBackend, requestOptions) {
      return new Jsonp(jsonpBackend, requestOptions);
    },
    deps: [JSONPBackend, RequestOptions]
  }), BrowserJsonp, _angular_core.provide(RequestOptions, {useClass: BaseRequestOptions}), _angular_core.provide(ResponseOptions, {useClass: BaseResponseOptions}), _angular_core.provide(JSONPBackend, {useClass: JSONPBackend_})];
  var JSON_BINDINGS = JSONP_PROVIDERS;
  exports.HTTP_PROVIDERS = HTTP_PROVIDERS;
  exports.HTTP_BINDINGS = HTTP_BINDINGS;
  exports.JSONP_PROVIDERS = JSONP_PROVIDERS;
  exports.JSON_BINDINGS = JSON_BINDINGS;
  exports.Request = Request;
  exports.Response = Response;
  exports.Connection = Connection;
  exports.ConnectionBackend = ConnectionBackend;
  exports.BrowserXhr = BrowserXhr;
  exports.BaseRequestOptions = BaseRequestOptions;
  exports.RequestOptions = RequestOptions;
  exports.BaseResponseOptions = BaseResponseOptions;
  exports.ResponseOptions = ResponseOptions;
  exports.XHRBackend = XHRBackend;
  exports.XHRConnection = XHRConnection;
  exports.JSONPBackend = JSONPBackend;
  exports.JSONPConnection = JSONPConnection;
  exports.Http = Http;
  exports.Jsonp = Jsonp;
  exports.Headers = Headers;
  exports.URLSearchParams = URLSearchParams;
}));

})();
$__System.registerDynamic("1", ["a", "21", "f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var platform_browser_dynamic_1 = $__require('a');
  var app_component_1 = $__require('21');
  var http_1 = $__require('f');
  platform_browser_dynamic_1.bootstrap(app_component_1.AppComponent, [http_1.HTTP_PROVIDERS]);
  return module.exports;
});

})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define([], factory);
  else if (typeof module == 'object' && module.exports && typeof require == 'function')
    module.exports = factory();
  else
    factory();
});